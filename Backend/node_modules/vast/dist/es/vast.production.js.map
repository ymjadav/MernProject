{"version":3,"file":"vast.production.js","sources":["../../src/vast.ts"],"sourcesContent":["import {\n  CB,\n  DynamicValue,\n  Maybe,\n  isFunction,\n  optionalFunctionValue,\n} from 'vest-utils';\n\n// eslint-disable-next-line max-lines-per-function\nexport function createState(\n  onStateChange?: (...args: unknown[]) => unknown\n): CreateStateReturn {\n  const state: {\n    references: unknown[];\n  } = {\n    references: [],\n  };\n\n  const registrations: [\n    unknown,\n    (<S>(currentState: S, prevState: S) => void)?\n  ][] = [];\n\n  return {\n    registerStateKey,\n    reset,\n  };\n\n  /**\n   * Registers a new key in the state, takes the initial value (may be a function that returns the initial value), returns a function.\n   *\n   * @example\n   *\n   * const useColor = state.registerStateKey(\"blue\");\n   *\n   * let [color, setColor] = useColor(); // -> [\"blue\", Function]\n   *\n   * setColor(\"green\");\n   *\n   * useColor()[0]; -> \"green\"\n   */\n  function registerStateKey<S>(\n    initialState?: Maybe<StateInput<S>>,\n    onUpdate?: () => void\n  ): CB<StateHandlerReturn<S>> {\n    const key = registrations.length;\n    registrations.push([initialState, onUpdate]);\n    return initKey(key, initialState);\n  }\n\n  function reset(): void {\n    const prev = current();\n    state.references = [];\n    registrations.forEach(([initialValue], index) =>\n      initKey(index, initialValue, prev[index])\n    );\n  }\n\n  function initKey<S>(\n    key: number,\n    initialState?: Maybe<StateInput<S>>,\n    prevState?: Maybe<S>\n  ) {\n    current().push();\n    set(key, optionalFunctionValue(initialState, prevState));\n\n    return function useStateKey(): StateHandlerReturn<S> {\n      return [\n        current()[key],\n        (nextState: SetStateInput<S>) =>\n          set(key, optionalFunctionValue(nextState, current()[key])),\n      ];\n    };\n  }\n\n  function current(): any[] {\n    return state.references;\n  }\n\n  function set(index: number, value: unknown): void {\n    const prevValue = state.references[index];\n    state.references[index] = value;\n\n    const [, onUpdate] = registrations[index];\n\n    if (isFunction(onUpdate)) {\n      onUpdate(value, prevValue);\n    }\n\n    if (isFunction(onStateChange)) {\n      onStateChange();\n    }\n  }\n}\n\ntype StateInput<S> = DynamicValue<S, [prevState?: S]>;\ntype SetStateInput<S> = DynamicValue<S, [prevState: S]>;\n\nexport type State = CreateStateReturn;\nexport type StateHandlerReturn<S> = [S, (nextState: SetStateInput<S>) => void];\nexport type UseState<S> = CB<StateHandlerReturn<S>>;\n\ntype CreateStateReturn = {\n  reset: () => void;\n  registerStateKey: <S>(\n    initialState?: Maybe<StateInput<S>>,\n    onUpdate?: () => void\n  ) => CB<StateHandlerReturn<S>>;\n};\n"],"names":["createState","onStateChange","state","references","registrations","registerStateKey","initialState","onUpdate","key","length","push","initKey","reset","prev","current","forEach","initialValue","index","prevState","set","optionalFunctionValue","nextState","value","prevValue","isFunction"],"mappings":"mEASM,SAAUA,EACdC,GAEA,MAAMC,EAEF,CACFC,WAAY,IAGRC,EAGA,GAEN,MAAO,CACLC,iBAiBF,SACEC,EACAC,GAEA,MAAMC,EAAMJ,EAAcK,OAE1B,OADAL,EAAcM,KAAK,CAACJ,EAAcC,IAC3BI,EAAQH,EAAKF,EACrB,EAvBCM,MAyBF,WACE,MAAMC,EAAOC,IACbZ,EAAMC,WAAa,GACnBC,EAAcW,SAAQ,EAAEC,GAAeC,IACrCN,EAAQM,EAAOD,EAAcH,EAAKI,KAErC,GAED,SAASN,EACPH,EACAF,EACAY,GAKA,OAHAJ,IAAUJ,OACVS,EAAIX,EAAKY,EAAsBd,EAAcY,IAEtC,WACL,MAAO,CACLJ,IAAUN,GACTa,GACCF,EAAIX,EAAKY,EAAsBC,EAAWP,IAAUN,KAE1D,CACD,CAED,SAASM,IACP,OAAOZ,EAAMC,UACd,CAED,SAASgB,EAAIF,EAAeK,GAC1B,MAAMC,EAAYrB,EAAMC,WAAWc,GACnCf,EAAMC,WAAWc,GAASK,EAE1B,OAASf,GAAYH,EAAca,GAE/BO,EAAWjB,IACbA,EAASe,EAAOC,GAGdC,EAAWvB,IACbA,GAEH,CACH"}