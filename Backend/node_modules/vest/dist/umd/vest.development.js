(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('n4s'), require('vest-utils'), require('vestjs-runtime'), require('context')) :
  typeof define === 'function' && define.amd ? define(['exports', 'n4s', 'vest-utils', 'vestjs-runtime', 'context'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vest = {}, global.n4s, global["vest-utils"], global["vestjs-runtime"], global.context));
})(this, (function (exports, n4s, vestUtils, vestjsRuntime, context) { 'use strict';

  const VestIsolateType = {
      Each: 'Each',
      Focused: 'Focused',
      Group: 'Group',
      OmitWhen: 'OmitWhen',
      SkipWhen: 'SkipWhen',
      Suite: 'Suite',
      Test: 'Test',
  };

  function IsolateSuite(callback) {
      return vestjsRuntime.Isolate.create(VestIsolateType.Suite, callback, {
          optional: {},
      });
  }
  class SuiteOptionalFields {
      static setOptionalField(suite, fieldName, setter) {
          const current = suite.data.optional;
          const currentField = current[fieldName];
          vestUtils.assign(current, {
              [fieldName]: vestUtils.assign({}, currentField, setter(currentField)),
          });
      }
      static getOptionalField(suite, fieldName) {
          var _a;
          return (_a = SuiteOptionalFields.getOptionalFields(suite)[fieldName]) !== null && _a !== void 0 ? _a : {};
      }
      static getOptionalFields(suite) {
          var _a, _b;
          return (_b = (_a = suite.data) === null || _a === void 0 ? void 0 : _a.optional) !== null && _b !== void 0 ? _b : {};
      }
  }

  var OptionalFieldTypes;
  (function (OptionalFieldTypes) {
      OptionalFieldTypes[OptionalFieldTypes["CUSTOM_LOGIC"] = 0] = "CUSTOM_LOGIC";
      OptionalFieldTypes[OptionalFieldTypes["AUTO"] = 1] = "AUTO";
  })(OptionalFieldTypes || (OptionalFieldTypes = {}));

  exports.Modes = void 0;
  (function (Modes) {
      Modes["EAGER"] = "EAGER";
      Modes["ALL"] = "ALL";
      Modes["ONE"] = "ONE";
  })(exports.Modes || (exports.Modes = {}));

  const SuiteContext = context.createCascade((ctxRef, parentContext) => {
      if (parentContext) {
          return null;
      }
      return vestUtils.assign({
          inclusion: {},
          mode: vestUtils.tinyState.createTinyState(exports.Modes.EAGER),
          suiteParams: [],
          testMemoCache,
      }, ctxRef);
  });
  function useCurrentTest(msg) {
      return SuiteContext.useX(msg).currentTest;
  }
  function useGroupName() {
      return SuiteContext.useX().groupName;
  }
  function useInclusion() {
      return SuiteContext.useX().inclusion;
  }
  function useMode() {
      return SuiteContext.useX().mode();
  }
  function useSkipped() {
      var _a;
      return (_a = SuiteContext.useX().skipped) !== null && _a !== void 0 ? _a : false;
  }
  function useOmitted() {
      var _a;
      return (_a = SuiteContext.useX().omitted) !== null && _a !== void 0 ? _a : false;
  }
  const testMemoCache = vestUtils.cache(10);
  function useTestMemoCache() {
      return SuiteContext.useX().testMemoCache;
  }
  function useSuiteParams() {
      return SuiteContext.useX().suiteParams;
  }

  // @vx-allow use-use
  function optional(optionals) {
      var _a;
      const suiteRoot = vestjsRuntime.VestRuntime.useAvailableRoot();
      const suiteParams = useSuiteParams();
      const dataObject = (_a = suiteParams === null || suiteParams === void 0 ? void 0 : suiteParams[0]) !== null && _a !== void 0 ? _a : {};
      // There are two types of optional field declarations:
      // 1 AUTO: Vest will automatically determine whether the field should be omitted
      // Based on the current run. Vest will omit "auto" added fields without any
      // configuration if their tests did not run at all in the suite, or if the data object
      // contains a blank value for the field.
      //
      // 2 Custom logic: Vest will determine whether they should fail based on the custom
      // logic supplied by the developer.
      // If the developer supplies a function - when the function returns true, the field will be omitted.
      // If the developer supplies a boolean - the field will be omitted if the value is true.
      // If the developer supplies a value - the field will be omitted if the value is blank.
      // AUTO case (field name)
      if (vestUtils.isArray(optionals) || vestUtils.isStringValue(optionals)) {
          vestUtils.asArray(optionals).forEach(optionalField => {
              SuiteOptionalFields.setOptionalField(suiteRoot, optionalField, () => ({
                  type: OptionalFieldTypes.AUTO,
                  applied: vestUtils.hasOwnProperty(dataObject, optionalField)
                      ? n4s.enforce.isBlank().test(dataObject === null || dataObject === void 0 ? void 0 : dataObject[optionalField])
                      : false,
                  rule: null,
              }));
          });
      }
      else {
          // CUSTOM_LOGIC case (function or boolean)
          for (const field in optionals) {
              const value = optionals[field];
              SuiteOptionalFields.setOptionalField(suiteRoot, field, () => ({
                  type: OptionalFieldTypes.CUSTOM_LOGIC,
                  rule: value,
                  applied: n4s.enforce.isBlank().test(value) || value === true,
              }));
          }
      }
  }
  function useIsOptionalFieldApplied(fieldName) {
      var _a, _b;
      if (!fieldName) {
          return false;
      }
      const root = vestjsRuntime.VestRuntime.useAvailableRoot();
      return ((_b = (_a = SuiteOptionalFields.getOptionalField(root, fieldName)) === null || _a === void 0 ? void 0 : _a.applied) !== null && _b !== void 0 ? _b : false);
  }

  var ErrorStrings;
  (function (ErrorStrings) {
      ErrorStrings["HOOK_CALLED_OUTSIDE"] = "hook called outside of a running suite.";
      ErrorStrings["EXPECTED_VEST_TEST"] = "Expected value to be an instance of IsolateTest";
      ErrorStrings["FIELD_NAME_REQUIRED"] = "Field name must be passed";
      ErrorStrings["SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION"] = "Suite must be initialized with a function";
      ErrorStrings["PROMISIFY_REQUIRE_FUNCTION"] = "Vest.Promisify must be called with a function";
      ErrorStrings["PARSER_EXPECT_RESULT_OBJECT"] = "Vest parser: expected argument at position 0 to be Vest's result object.";
      ErrorStrings["WARN_MUST_BE_CALLED_FROM_TEST"] = "Warn must be called from within the body of a test function";
      ErrorStrings["EACH_CALLBACK_MUST_BE_A_FUNCTION"] = "Each must be called with a function";
      ErrorStrings["INVALID_PARAM_PASSED_TO_FUNCTION"] = "Incompatible params passed to {fn_name} function. \"{param}\" must be of type {expected}";
      ErrorStrings["TESTS_CALLED_IN_DIFFERENT_ORDER"] = "Vest Critical Error: Tests called in different order than previous run.\n    expected: {fieldName}\n    received: {prevName}\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state.";
      ErrorStrings["UNEXPECTED_TEST_REGISTRATION_ERROR"] = "Unexpected error encountered during test registration.\n      Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.\n      Error: {error}.";
      ErrorStrings["UNEXPECTED_TEST_RUN_ERROR"] = "Unexpected error encountered during test run. Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.";
      ErrorStrings["INCLUDE_SELF"] = "Trying to call include.when on the same field.";
  })(ErrorStrings || (ErrorStrings = {}));

  const CommonStates = {
      PENDING: 'PENDING',
      INITIAL: 'INITIAL',
  };
  const State = {
      [CommonStates.PENDING]: CommonStates.PENDING,
      [CommonStates.INITIAL]: CommonStates.INITIAL,
      DONE: 'DONE',
  };
  const machine$1 = {
      initial: State.INITIAL,
      states: {
          [State.DONE]: {},
          [State.INITIAL]: {
              [State.PENDING]: State.PENDING,
              [State.DONE]: State.DONE,
          },
          [State.PENDING]: {
              [State.DONE]: State.DONE,
          },
      },
  };
  function transition(from, to) {
      return CommonStateMachine.staticTransition(from !== null && from !== void 0 ? from : State.INITIAL, to);
  }
  function setDone(isolate) {
      isolate.status = transition(isolate.status, State.DONE);
  }
  function setPending(isolate) {
      isolate.status = transition(isolate.status, State.PENDING);
  }
  const CommonStateMachine = vestUtils.StateMachine(machine$1);

  const TestStatus = {
      [CommonStates.PENDING]: CommonStates.PENDING,
      CANCELED: 'CANCELED',
      FAILED: 'FAILED',
      OMITTED: 'OMITTED',
      PASSING: 'PASSING',
      SKIPPED: 'SKIPPED',
      UNTESTED: 'UNTESTED',
      WARNING: 'WARNING',
  };
  const TestAction = {
      RESET: 'RESET',
  };
  const machine = {
      initial: TestStatus.UNTESTED,
      states: {
          '*': {
              [TestStatus.OMITTED]: TestStatus.OMITTED,
              [TestAction.RESET]: TestStatus.UNTESTED,
          },
          [TestStatus.UNTESTED]: {
              [TestStatus.CANCELED]: TestStatus.CANCELED,
              [TestStatus.FAILED]: TestStatus.FAILED,
              [TestStatus.PASSING]: TestStatus.PASSING,
              [TestStatus.PENDING]: TestStatus.PENDING,
              [TestStatus.SKIPPED]: TestStatus.SKIPPED,
              [TestStatus.WARNING]: TestStatus.WARNING,
          },
          [TestStatus.PENDING]: {
              [TestStatus.CANCELED]: TestStatus.CANCELED,
              [TestStatus.FAILED]: TestStatus.FAILED,
              [TestStatus.PASSING]: TestStatus.PASSING,
              [TestStatus.SKIPPED]: [
                  TestStatus.SKIPPED,
                  (force) => force === true,
              ],
              [TestStatus.WARNING]: TestStatus.WARNING,
          },
          [TestStatus.SKIPPED]: {},
          [TestStatus.FAILED]: {},
          [TestStatus.WARNING]: {},
          [TestStatus.PASSING]: {},
          [TestStatus.CANCELED]: {},
          [TestStatus.OMITTED]: {},
      },
  };
  const IsolateTestStateMachine = vestUtils.StateMachine(machine);

  var Severity;
  (function (Severity) {
      Severity["WARNINGS"] = "warnings";
      Severity["ERRORS"] = "errors";
  })(Severity || (Severity = {}));
  var SeverityCount;
  (function (SeverityCount) {
      SeverityCount["ERROR_COUNT"] = "errorCount";
      SeverityCount["WARN_COUNT"] = "warnCount";
  })(SeverityCount || (SeverityCount = {}));
  function countKeyBySeverity(severity) {
      return severity === Severity.ERRORS
          ? SeverityCount.ERROR_COUNT
          : SeverityCount.WARN_COUNT;
  }
  var TestSeverity;
  (function (TestSeverity) {
      TestSeverity["Error"] = "error";
      TestSeverity["Warning"] = "warning";
  })(TestSeverity || (TestSeverity = {}));

  class VestIsolate {
      static getStatus(isolate) {
          var _a;
          return (_a = isolate.status) !== null && _a !== void 0 ? _a : CommonStates.INITIAL;
      }
      static setStatus(isolate, status, payload) {
          isolate.status = this.stateMachine.staticTransition(VestIsolate.getStatus(isolate), status, payload);
      }
      static statusEquals(isolate, status) {
          return VestIsolate.getStatus(isolate) === status;
      }
      static setPending(isolate) {
          this.setStatus(isolate, CommonStates.PENDING);
      }
      static isPending(isolate) {
          return VestIsolate.statusEquals(isolate, CommonStates.PENDING);
      }
  }
  VestIsolate.stateMachine = CommonStateMachine;

  class VestTest extends VestIsolate {
      // Read
      static getData(test) {
          vestUtils.invariant(test.data);
          return test.data;
      }
      static is(isolate) {
          return vestjsRuntime.IsolateSelectors.isIsolateType(isolate, VestIsolateType.Test);
      }
      static isX(isolate) {
          vestUtils.invariant(VestTest.is(isolate), ErrorStrings.EXPECTED_VEST_TEST);
      }
      static cast(isolate) {
          VestTest.isX(isolate);
          return isolate;
      }
      static warns(test) {
          return VestTest.getData(test).severity === TestSeverity.Warning;
      }
      static isOmitted(test) {
          return VestTest.statusEquals(test, TestStatus.OMITTED);
      }
      static isUntested(test) {
          return VestTest.statusEquals(test, TestStatus.UNTESTED);
      }
      static isFailing(test) {
          return VestTest.statusEquals(test, TestStatus.FAILED);
      }
      static isCanceled(test) {
          return VestTest.statusEquals(test, TestStatus.CANCELED);
      }
      static isSkipped(test) {
          return VestTest.statusEquals(test, TestStatus.SKIPPED);
      }
      static isPassing(test) {
          return VestTest.statusEquals(test, TestStatus.PASSING);
      }
      static isWarning(test) {
          return VestTest.statusEquals(test, TestStatus.WARNING);
      }
      static hasFailures(test) {
          return VestTest.isFailing(test) || VestTest.isWarning(test);
      }
      static isNonActionable(test) {
          return (VestTest.isSkipped(test) ||
              VestTest.isOmitted(test) ||
              VestTest.isCanceled(test));
      }
      static isTested(test) {
          return VestTest.hasFailures(test) || VestTest.isPassing(test);
      }
      static awaitsResolution(test) {
          // Is the test in a state where it can still be run, or complete running
          // and its final status is indeterminate?
          return (VestTest.isSkipped(test) ||
              VestTest.isUntested(test) ||
              VestTest.isPending(test));
      }
      static isAsyncTest(test) {
          return vestUtils.isPromise(VestTest.getData(test).asyncTest);
      }
      // Mutate
      // static setPending(test: TIsolateTest) {
      //   this.setStatus(test, TestStatus.PENDING);
      // }
      static fail(test) {
          VestTest.setStatus(test, VestTest.warns(test) ? TestStatus.WARNING : TestStatus.FAILED);
      }
      static pass(test) {
          VestTest.setStatus(test, TestStatus.PASSING);
      }
      static warn(test) {
          VestTest.setData(test, current => (Object.assign(Object.assign({}, current), { severity: TestSeverity.Warning })));
      }
      static setData(test, setter) {
          test.data = vestUtils.optionalFunctionValue(setter, VestTest.getData(test));
      }
      static skip(test, force) {
          // Without this force flag, the test will be marked as skipped even if it is pending.
          // This means that it will not be counted in "allIncomplete" and its done callbacks
          // will not be called, or will be called prematurely.
          // What this mostly say is that when we have a pending test for one field, and we then
          // start typing in a different field - the pending test will be canceled, which
          // is usually an unwanted behavior.
          // The only scenario in which we DO want to cancel the async test regardless
          // is when we specifically skip a test with `skipWhen`, which is handled by the
          // "force" boolean flag.
          // I am not a fan of this flag, but it gets the job done.
          VestTest.setStatus(test, TestStatus.SKIPPED, force);
      }
      static cancel(test) {
          VestTest.setStatus(test, TestStatus.CANCELED);
          vestjsRuntime.IsolateMutator.abort(test, TestStatus.CANCELED);
      }
      static omit(test) {
          VestTest.setStatus(test, TestStatus.OMITTED);
      }
      static reset(test) {
          VestTest.setStatus(test, TestAction.RESET);
      }
  }
  VestTest.stateMachine = IsolateTestStateMachine;

  function nonMatchingFieldName(WithFieldName, fieldName) {
      return !!fieldName && !matchingFieldName(WithFieldName, fieldName);
  }
  function matchingFieldName(WithFieldName, fieldName) {
      return !!(fieldName && WithFieldName.fieldName === fieldName);
  }
  function matchesOrHasNoFieldName(WithFieldName, fieldName) {
      if (fieldName) {
          return matchingFieldName(WithFieldName, fieldName);
      }
      return true;
  }

  function isSameProfileTest(testObject1, testObject2) {
      const { groupName: gn1 } = VestTest.getData(testObject1);
      const { groupName: gn2, fieldName: fn2 } = VestTest.getData(testObject2);
      return (matchingFieldName(VestTest.getData(testObject1), fn2) &&
          gn1 === gn2 &&
          // Specifically using == here. The reason is that when serializing
          // suite result, empty key gets removed, but it can also be null.
          testObject1.key == testObject2.key);
  }

  function cancelOverriddenPendingTest(prevRunTestObject, currentRunTestObject) {
      if (currentRunTestObject !== prevRunTestObject &&
          isSameProfileTest(prevRunTestObject, currentRunTestObject) &&
          VestTest.isPending(prevRunTestObject)) {
          VestTest.cancel(prevRunTestObject);
      }
  }

  var FocusModes;
  (function (FocusModes) {
      FocusModes[FocusModes["ONLY"] = 0] = "ONLY";
      FocusModes[FocusModes["SKIP"] = 1] = "SKIP";
  })(FocusModes || (FocusModes = {}));

  function IsolateFocused(focusMode, match) {
      return vestjsRuntime.Isolate.create(VestIsolateType.Focused, vestUtils.noop, {
          focusMode,
          match: vestUtils.asArray(match).filter(vestUtils.isStringValue),
          matchAll: match === true,
      });
  }
  class FocusSelectors {
      static isSkipFocused(focus, fieldName) {
          return ((focus === null || focus === void 0 ? void 0 : focus.data.focusMode) === FocusModes.SKIP &&
              (hasFocus(focus, fieldName) || focus.data.matchAll === true));
      }
      static isOnlyFocused(focus, fieldName) {
          return ((focus === null || focus === void 0 ? void 0 : focus.data.focusMode) === FocusModes.ONLY && hasFocus(focus, fieldName));
      }
      static isIsolateFocused(isolate) {
          return vestjsRuntime.IsolateSelectors.isIsolateType(isolate, VestIsolateType.Focused);
      }
  }
  /**
   * Adds a field or a list of fields into the inclusion list
   *
   * @example
   *
   * only('username');
   */
  // @vx-allow use-use
  function only(match) {
      return IsolateFocused(FocusModes.ONLY, defaultMatch(match));
  }
  /**
   * Adds a field or a list of fields into the exclusion list
   *
   * @example
   *
   * skip('username');
   */
  // @vx-allow use-use
  function skip(match) {
      return IsolateFocused(FocusModes.SKIP, defaultMatch(match));
  }
  function defaultMatch(match) {
      return match === false ? [] : match;
  }
  function hasFocus(focus, fieldName) {
      var _a, _b;
      return (vestUtils.isNotEmpty(focus === null || focus === void 0 ? void 0 : focus.data.match) &&
          (fieldName ? (_b = (_a = focus === null || focus === void 0 ? void 0 : focus.data.match) === null || _a === void 0 ? void 0 : _a.includes(fieldName)) !== null && _b !== void 0 ? _b : true : true));
  }

  const suiteResultCache = vestUtils.cache();
  function useCreateVestState({ suiteName, VestReconciler, }) {
      const stateRef = {
          doneCallbacks: vestUtils.tinyState.createTinyState(() => []),
          fieldCallbacks: vestUtils.tinyState.createTinyState(() => ({})),
          suiteId: vestUtils.seq(),
          suiteName,
          suiteResultCache,
      };
      return vestjsRuntime.VestRuntime.createRef(VestReconciler, stateRef);
  }
  function useX() {
      return vestjsRuntime.VestRuntime.useXAppData();
  }
  function useDoneCallbacks() {
      return useX().doneCallbacks();
  }
  function useFieldCallbacks() {
      return useX().fieldCallbacks();
  }
  function useSuiteName() {
      return useX().suiteName;
  }
  function useSuiteId() {
      return useX().suiteId;
  }
  function useSuiteResultCache(action) {
      const suiteResultCache = useX().suiteResultCache;
      return suiteResultCache([useSuiteId()], action);
  }
  function useExpireSuiteResultCache() {
      const suiteResultCache = useX().suiteResultCache;
      suiteResultCache.invalidate([useSuiteId()]);
  }
  function useResetCallbacks() {
      const [, , resetDoneCallbacks] = useDoneCallbacks();
      const [, , resetFieldCallbacks] = useFieldCallbacks();
      resetDoneCallbacks();
      resetFieldCallbacks();
  }
  function useResetSuite() {
      useResetCallbacks();
      vestjsRuntime.VestRuntime.reset();
  }
  function useLoadSuite(rootNode) {
      vestjsRuntime.VestRuntime.useLoadRootNode(rootNode);
      useExpireSuiteResultCache();
  }

  // calls collectAll or getByFieldName depending on whether fieldName is provided
  function gatherFailures(testGroup, severityKey, fieldName) {
      return fieldName
          ? getByFieldName(testGroup, severityKey, fieldName)
          : collectAll(testGroup, severityKey);
  }
  function getByFieldName(testGroup, severityKey, fieldName) {
      var _a;
      return ((_a = testGroup === null || testGroup === void 0 ? void 0 : testGroup[fieldName]) === null || _a === void 0 ? void 0 : _a[severityKey]) || [];
  }
  function collectAll(testGroup, severityKey) {
      const output = {};
      const countKey = countKeyBySeverity(severityKey);
      for (const field in testGroup) {
          if (vestUtils.isPositive(testGroup[field][countKey])) {
              // We will probably never get to the fallback array
              // leaving it just in case the implementation changes
              output[field] = testGroup[field][severityKey] || [];
          }
      }
      return output;
  }

  function bindSuiteSelectors(get) {
      return {
          getError: (...args) => get().getError(...args),
          getErrors: (...args) => get().getErrors(...args),
          getErrorsByGroup: (...args) => get().getErrorsByGroup(...args),
          getWarning: (...args) => get().getWarning(...args),
          getWarnings: (...args) => get().getWarnings(...args),
          getWarningsByGroup: (...args) => get().getWarningsByGroup(...args),
          hasErrors: (...args) => get().hasErrors(...args),
          hasErrorsByGroup: (...args) => get().hasErrorsByGroup(...args),
          hasWarnings: (...args) => get().hasWarnings(...args),
          hasWarningsByGroup: (...args) => get().hasWarningsByGroup(...args),
          isPending: (...args) => {
              return get().isPending(...args);
          },
          isTested: (...args) => get().isTested(...args),
          isValid: (...args) => get().isValid(...args),
          isValidByGroup: (...args) => get().isValidByGroup(...args),
      };
  }
  // eslint-disable-next-line max-lines-per-function, max-statements
  function suiteSelectors(summary) {
      const selectors = {
          getError,
          getErrors,
          getErrorsByGroup,
          getWarning,
          getWarnings,
          getWarningsByGroup,
          hasErrors,
          hasErrorsByGroup,
          hasWarnings,
          hasWarningsByGroup,
          isPending,
          isTested,
          isValid,
          isValidByGroup,
      };
      return selectors;
      // Booleans
      function isValid(fieldName) {
          var _a;
          return fieldName ? Boolean((_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.valid) : summary.valid;
      }
      function isValidByGroup(groupName, fieldName) {
          const group = summary.groups[groupName];
          if (!group) {
              return false;
          }
          if (fieldName) {
              return isFieldValid(group, fieldName);
          }
          for (const fieldName in group) {
              if (!isFieldValid(group, fieldName)) {
                  return false;
              }
          }
          return true;
      }
      function hasWarnings(fieldName) {
          return hasFailures(summary, SeverityCount.WARN_COUNT, fieldName);
      }
      function hasErrors(fieldName) {
          return hasFailures(summary, SeverityCount.ERROR_COUNT, fieldName);
      }
      function isTested(fieldName) {
          var _a;
          return vestUtils.isPositive((_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.testCount);
      }
      function hasWarningsByGroup(groupName, fieldName) {
          return hasFailuresByGroup(summary, SeverityCount.WARN_COUNT, groupName, fieldName);
      }
      function hasErrorsByGroup(groupName, fieldName) {
          return hasFailuresByGroup(summary, SeverityCount.ERROR_COUNT, groupName, fieldName);
      }
      function getWarnings(fieldName) {
          return getFailures(summary, Severity.WARNINGS, fieldName);
      }
      function getWarning(fieldName) {
          return getFailure(Severity.WARNINGS, summary, fieldName);
      }
      function getErrors(fieldName) {
          return getFailures(summary, Severity.ERRORS, fieldName);
      }
      function getError(fieldName) {
          return getFailure(Severity.ERRORS, summary, fieldName);
      }
      function getErrorsByGroup(groupName, fieldName) {
          return getFailuresByGroup(summary, Severity.ERRORS, groupName, fieldName);
      }
      function getWarningsByGroup(groupName, fieldName) {
          return getFailuresByGroup(summary, Severity.WARNINGS, groupName, fieldName);
      }
      function isPending(fieldName) {
          var _a;
          return fieldName
              ? vestUtils.greaterThan((_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.pendingCount, 0)
              : vestUtils.greaterThan(summary.pendingCount, 0);
      }
  }
  function getFailures(summary, severityKey, fieldName) {
      return gatherFailures(summary.tests, severityKey, fieldName);
  }
  // Gathers all failures of a given severity within a group
  // With a fieldName, it will only gather failures for that field
  function getFailuresByGroup(summary, severityKey, groupName, fieldName) {
      return gatherFailures(summary.groups[groupName], severityKey, fieldName);
  }
  // Checks if a field is valid within a container object - can be within a group or top level
  function isFieldValid(testContainer, fieldName) {
      var _a;
      return !!((_a = testContainer[fieldName]) === null || _a === void 0 ? void 0 : _a.valid);
  }
  // Checks if a there are any failures of a given severity within a group
  // If a fieldName is provided, it will only check for failures within that field
  function hasFailuresByGroup(summary, severityCount, groupName, fieldName) {
      var _a, _b;
      const group = summary.groups[groupName];
      if (!group) {
          return false;
      }
      if (fieldName) {
          return vestUtils.isPositive((_a = group[fieldName]) === null || _a === void 0 ? void 0 : _a[severityCount]);
      }
      for (const field in group) {
          if (vestUtils.isPositive((_b = group[field]) === null || _b === void 0 ? void 0 : _b[severityCount])) {
              return true;
          }
      }
      return false;
  }
  // Checks if there are any failures of a given severity
  // If a fieldName is provided, it will only check for failures within that field
  function hasFailures(summary, countKey, fieldName) {
      var _a;
      const failureCount = fieldName
          ? (_a = summary.tests[fieldName]) === null || _a === void 0 ? void 0 : _a[countKey]
          : summary[countKey] || 0;
      return vestUtils.isPositive(failureCount);
  }
  function getFailure(severity, summary, fieldName) {
      var _a;
      const summaryKey = summary[severity];
      if (!fieldName) {
          return summaryKey[0];
      }
      return (_a = summaryKey.find((summaryFailure) => matchingFieldName(summaryFailure, fieldName))) === null || _a === void 0 ? void 0 : _a.message;
  }

  var _a, _b;
  class SummaryBase {
      constructor() {
          this.errorCount = 0;
          this.warnCount = 0;
          this.testCount = 0;
          this.pendingCount = 0;
      }
  }
  class SuiteSummary extends SummaryBase {
      constructor() {
          super(...arguments);
          this[_a] = [];
          this[_b] = [];
          this.groups = {};
          this.tests = {};
          this.valid = false;
      }
  }
  _a = Severity.ERRORS, _b = Severity.WARNINGS;

  class SummaryFailure {
      constructor(fieldName, message, groupName) {
          this.fieldName = fieldName;
          this.message = message;
          this.groupName = groupName;
      }
      static fromTestObject(testObject) {
          const { fieldName, message, groupName } = VestTest.getData(testObject);
          return new SummaryFailure(fieldName, message, groupName);
      }
  }

  class TestWalker {
      static hasNoTests(root = TestWalker.defaultRoot()) {
          if (!root)
              return true;
          return !vestjsRuntime.Walker.has(root, VestTest.is);
      }
      static someTests(predicate, root = TestWalker.defaultRoot()) {
          if (!root)
              return false;
          return vestjsRuntime.Walker.some(root, isolate => {
              VestTest.isX(isolate);
              return predicate(isolate);
          }, VestTest.is);
      }
      static everyTest(predicate, root = TestWalker.defaultRoot()) {
          if (!root)
              return false;
          return vestjsRuntime.Walker.every(root, isolate => {
              VestTest.isX(isolate);
              return predicate(isolate);
          }, VestTest.is);
      }
      static walkTests(callback, root = TestWalker.defaultRoot()) {
          if (!root)
              return;
          vestjsRuntime.Walker.walk(root, (isolate, breakout) => {
              callback(VestTest.cast(isolate), breakout);
          }, VestTest.is);
      }
      static pluckTests(predicate, root = TestWalker.defaultRoot()) {
          if (!root)
              return;
          vestjsRuntime.Walker.pluck(root, isolate => {
              VestTest.isX(isolate);
              return predicate(isolate);
          }, VestTest.is);
      }
      static resetField(fieldName) {
          TestWalker.walkTests(testObject => {
              if (matchingFieldName(VestTest.getData(testObject), fieldName)) {
                  VestTest.reset(testObject);
              }
          }, TestWalker.defaultRoot());
      }
      static removeTestByFieldName(fieldName, root = TestWalker.defaultRoot()) {
          TestWalker.pluckTests(testObject => {
              return matchingFieldName(VestTest.getData(testObject), fieldName);
          }, root);
      }
  }
  TestWalker.defaultRoot = vestjsRuntime.VestRuntime.useAvailableRoot;

  class SuiteWalker {
      static hasPending(predicate) {
          const root = SuiteWalker.defaultRoot();
          if (!root) {
              return false;
          }
          return vestjsRuntime.Walker.some(root, vestUtils.Predicates.all(VestIsolate.isPending, predicate !== null && predicate !== void 0 ? predicate : true));
      }
      // Checks whether there are pending isolates in the tree.
      // If a fieldname is provided, will only check tests with a matching fieldname.
      static hasRemainingWithTestNameMatching(fieldName) {
          return SuiteWalker.hasPending(vestUtils.Predicates.any(vestUtils.isNullish(fieldName), vestUtils.Predicates.all(VestTest.is, (testObject) => {
              return matchesOrHasNoFieldName(VestTest.getData(testObject), fieldName);
          })));
      }
  }
  SuiteWalker.defaultRoot = vestjsRuntime.VestRuntime.useAvailableRoot;

  const nonMatchingGroupName = vestUtils.bindNot(matchingGroupName);
  function matchingGroupName(testObject, groupName) {
      return VestTest.getData(testObject).groupName === groupName;
  }

  /**
   * Checks that a given test object matches the currently specified severity level
   */
  function nonMatchingSeverityProfile(severity, testObject) {
      return vestUtils.either(severity === Severity.WARNINGS, VestTest.warns(testObject));
  }

  /**
   * The difference between this file and hasFailures is that hasFailures uses the static
   * summary object, while this one uses the actual validation state
   */
  function hasErrorsByTestObjects(fieldName) {
      return hasFailuresByTestObjects(Severity.ERRORS, fieldName);
  }
  function hasFailuresByTestObjects(severityKey, fieldName) {
      return TestWalker.someTests(testObject => {
          return hasFailuresByTestObject(testObject, severityKey, fieldName);
      });
  }
  function hasGroupFailuresByTestObjects(severityKey, groupName, fieldName) {
      return TestWalker.someTests(testObject => {
          if (nonMatchingGroupName(testObject, groupName)) {
              return false;
          }
          return hasFailuresByTestObject(testObject, severityKey, fieldName);
      });
  }
  /**
   * Determines whether a certain test profile has failures.
   */
  function hasFailuresByTestObject(testObject, severityKey, fieldName) {
      if (!VestTest.hasFailures(testObject)) {
          return false;
      }
      if (nonMatchingFieldName(VestTest.getData(testObject), fieldName)) {
          return false;
      }
      if (nonMatchingSeverityProfile(severityKey, testObject)) {
          return false;
      }
      return true;
  }

  function useShouldAddValidProperty(fieldName) {
      // Is the field optional, and the optional condition is applied
      if (useIsOptionalFieldApplied(fieldName)) {
          return true;
      }
      // Are there no tests?
      if (TestWalker.hasNoTests()) {
          return false;
      }
      // // Does the field have any tests with errors?
      if (hasErrorsByTestObjects(fieldName)) {
          return false;
      }
      // Does the given field have any pending tests that are not optional?
      if (useHasNonOptionalIncomplete(fieldName)) {
          return false;
      }
      // Does the field have no missing tests?
      return useNoMissingTests(fieldName);
  }
  function useShouldAddValidPropertyInGroup(groupName, fieldName) {
      if (useIsOptionalFieldApplied(fieldName)) {
          return true;
      }
      if (hasGroupFailuresByTestObjects(Severity.ERRORS, groupName, fieldName)) {
          return false;
      }
      // Do the given group/field have any pending tests that are not optional?
      if (useHasNonOptionalIncompleteByGroup(groupName, fieldName)) {
          return false;
      }
      return useNoMissingTestsByGroup(groupName, fieldName);
  }
  // Does the given field have any pending tests that are not optional?
  function useHasNonOptionalIncomplete(fieldName) {
      return SuiteWalker.hasPending(vestUtils.Predicates.all(VestTest.is, (testObject) => !nonMatchingFieldName(VestTest.getData(testObject), fieldName), () => !useIsOptionalFieldApplied(fieldName)));
  }
  // Do the given group/field have any pending tests that are not optional?
  function useHasNonOptionalIncompleteByGroup(groupName, fieldName) {
      return SuiteWalker.hasPending(vestUtils.Predicates.all(VestTest.is, (testObject) => !nonMatchingGroupName(testObject, groupName), (testObject) => !nonMatchingFieldName(VestTest.getData(testObject), fieldName), () => !useIsOptionalFieldApplied(fieldName)));
  }
  // Did all of the tests for the provided field run/omit?
  // This makes sure that the fields are not skipped or pending.
  function useNoMissingTests(fieldName) {
      return TestWalker.everyTest(testObject => {
          return useNoMissingTestsLogic(testObject, fieldName);
      });
  }
  // Does the group have no missing tests?
  function useNoMissingTestsByGroup(groupName, fieldName) {
      return TestWalker.everyTest(testObject => {
          if (nonMatchingGroupName(testObject, groupName)) {
              return true;
          }
          return useNoMissingTestsLogic(testObject, fieldName);
      });
  }
  function useNoMissingTestsLogic(testObject, fieldName) {
      if (nonMatchingFieldName(VestTest.getData(testObject), fieldName)) {
          return true;
      }
      /**
       * The reason we're checking for the optional field here and not in "omitOptionalFields"
       * is because that unlike the bool/function check we do there, here it only depends on
       * whether the field was tested already or not.
       *
       * We qualify the test as not missing only if it was already run, if it is omitted,
       * or if it is marked as optional, even if the optional check did not apply yet -
       * but the test did not reach its final state.
       */
      return (VestTest.isOmitted(testObject) ||
          VestTest.isTested(testObject) ||
          useOptionalTestAwaitsResolution(testObject));
  }
  function useOptionalTestAwaitsResolution(testObject) {
      // Does the test belong to an optional field,
      // and the test itself is still in an indeterminate state?
      const root = vestjsRuntime.VestRuntime.useAvailableRoot();
      const { fieldName } = VestTest.getData(testObject);
      return (SuiteOptionalFields.getOptionalField(root, fieldName).type ===
          OptionalFieldTypes.AUTO && VestTest.awaitsResolution(testObject));
  }

  function useProduceSuiteSummary() {
      const summary = new SuiteSummary();
      TestWalker.walkTests(testObject => {
          summary.tests = useAppendToTest(summary.tests, testObject);
          summary.groups = useAppendToGroup(summary.groups, testObject);
          summary.errors = appendFailures(Severity.ERRORS, summary.errors, testObject);
          summary.warnings = appendFailures(Severity.WARNINGS, summary.warnings, testObject);
      });
      summary.valid = useShouldAddValidProperty();
      return countOverallStates(summary);
  }
  function appendFailures(key, failures, testObject) {
      if (VestTest.isOmitted(testObject)) {
          return failures;
      }
      const shouldAppend = key === Severity.WARNINGS
          ? VestTest.isWarning(testObject)
          : VestTest.isFailing(testObject);
      if (shouldAppend) {
          return failures.concat(SummaryFailure.fromTestObject(testObject));
      }
      return failures;
  }
  function useAppendToTest(tests, testObject) {
      const fieldName = VestTest.getData(testObject).fieldName;
      const newTests = Object.assign({}, tests);
      newTests[fieldName] = appendTestObject(newTests[fieldName], testObject);
      // If `valid` is false to begin with, keep it that way. Otherwise, assess.
      newTests[fieldName].valid =
          newTests[fieldName].valid === false
              ? false
              : useShouldAddValidProperty(fieldName);
      return newTests;
  }
  /**
   * Appends to a group object if within a group
   */
  function useAppendToGroup(groups, testObject) {
      const { groupName, fieldName } = VestTest.getData(testObject);
      if (!groupName) {
          return groups;
      }
      const newGroups = Object.assign({}, groups);
      newGroups[groupName] = newGroups[groupName] || {};
      newGroups[groupName][fieldName] = appendTestObject(newGroups[groupName][fieldName], testObject);
      newGroups[groupName][fieldName].valid =
          newGroups[groupName][fieldName].valid === false
              ? false
              : useShouldAddValidPropertyInGroup(groupName, fieldName);
      return newGroups;
  }
  /**
   * Counts the failed tests and adds global counters
   */
  function countOverallStates(summary) {
      for (const test in summary.tests) {
          summary.errorCount += summary.tests[test].errorCount;
          summary.warnCount += summary.tests[test].warnCount;
          summary.testCount += summary.tests[test].testCount;
          summary.pendingCount += summary.tests[test].pendingCount;
      }
      return summary;
  }
  /**
   * Appends the test to a results object.
   */
  // eslint-disable-next-line max-statements, complexity
  function appendTestObject(summaryKey, testObject) {
      const { message } = VestTest.getData(testObject);
      // Let's first create a new object, so we don't mutate the original.
      const nextSummaryKey = vestUtils.defaultTo(summaryKey ? Object.assign({}, summaryKey) : null, baseTestStats);
      // If the test is not actionable, we don't need to append it to the summary.
      if (VestTest.isNonActionable(testObject))
          return nextSummaryKey;
      // Increment the pending count if the test is pending.
      if (VestTest.isPending(testObject)) {
          nextSummaryKey.pendingCount++;
      }
      // Increment the error count if the test is failing.
      if (VestTest.isFailing(testObject)) {
          incrementFailures(Severity.ERRORS);
      }
      else if (VestTest.isWarning(testObject)) {
          // Increment the warning count if the test is warning.
          incrementFailures(Severity.WARNINGS);
      }
      // Increment the test count.
      nextSummaryKey.testCount++;
      return nextSummaryKey;
      // Helper function to increment the failure count.
      function incrementFailures(severity) {
          const countKey = countKeyBySeverity(severity);
          nextSummaryKey[countKey]++;
          if (message) {
              nextSummaryKey[severity] = (nextSummaryKey[severity] || []).concat(message);
          }
      }
  }
  function baseTestStats() {
      return vestUtils.assign(new SummaryBase(), {
          errors: [],
          valid: true,
          warnings: [],
      });
  }

  function useCreateSuiteResult() {
      return useSuiteResultCache(() => {
          // @vx-allow use-use
          const summary = useProduceSuiteSummary();
          // @vx-allow use-use
          const suiteName = useSuiteName();
          return Object.freeze(vestUtils.assign(summary, suiteSelectors(summary), {
              suiteName,
          }));
      });
  }

  /**
   * Conditionally skips running tests within the callback.
   *
   * @example
   *
   * skipWhen(res => res.hasErrors('username'), () => {
   *  test('username', 'User already taken', async () => await doesUserExist(username)
   * });
   */
  // @vx-allow use-use
  function skipWhen(condition, callback) {
      vestjsRuntime.Isolate.create(VestIsolateType.SkipWhen, () => {
          SuiteContext.run({
              skipped: 
              // Checking for nested conditional. If we're in a nested skipWhen,
              // we should skip the test if the parent conditional is true.
              useIsExcludedIndividually() ||
                  // Otherwise, we should skip the test if the conditional is true.
                  vestUtils.optionalFunctionValue(condition, vestUtils.optionalFunctionValue(useCreateSuiteResult)),
          }, callback);
      });
  }
  function useIsExcludedIndividually() {
      return useSkipped();
  }

  /**
   * Checks if context has included tests
   */
  function useHasOnliedTests(testObject, fieldName) {
      return vestUtils.isNotNullish(vestjsRuntime.Walker.findClosest(testObject, (child) => {
          if (!FocusSelectors.isIsolateFocused(child))
              return false;
          return FocusSelectors.isOnlyFocused(child, fieldName);
      }));
  }

  //Checks whether a certain test profile excluded by any of the exclusion groups.
  function useClosestMatchingFocus(testObject) {
      return vestjsRuntime.Walker.findClosest(testObject, (child) => {
          var _a;
          if (!FocusSelectors.isIsolateFocused(child))
              return false;
          const { fieldName } = VestTest.getData(testObject);
          return ((_a = child.data.match) === null || _a === void 0 ? void 0 : _a.includes(fieldName)) || child.data.matchAll;
      });
  }
  function useIsExcluded(testObject) {
      const { fieldName } = VestTest.getData(testObject);
      if (useIsExcludedIndividually())
          return true;
      const inclusion = useInclusion();
      const focusMatch = useClosestMatchingFocus(testObject);
      // if test is skipped
      // no need to proceed
      if (FocusSelectors.isSkipFocused(focusMatch))
          return true;
      const isTestIncluded = FocusSelectors.isOnlyFocused(focusMatch);
      // if field is only'ed
      if (isTestIncluded)
          return false;
      // If there is _ANY_ `only`ed test (and we already know this one isn't) return true
      if (useHasOnliedTests(testObject)) {
          // Check if inclusion rules for this field (`include` hook)
          return !vestUtils.optionalFunctionValue(inclusion[fieldName], testObject);
      }
      // We're done here. This field is not excluded
      return false;
  }

  /**
   * Sets the current execution mode for the current suite.
   *
   * Supported modes:
   * - `EAGER` - (default) Runs all tests, but stops on first failure for each given field.
   * - `ALL` - Runs all tests, regardless of failures.
   * - `ONE` - Stops suite execution on first failure of any field.
   *
   * @example
   * ```js
   * import {Modes, create} from 'vest';
   *
   * const suite = create('suite_name', () => {
   *  vest.mode(Modes.ALL);
   *
   *  // ...
   * });
   * ```
   * @param 'ALL' | 'EAGER' | 'ONE' mode - The mode to set.
   */
  // @vx-allow use-use
  function mode(mode) {
      const [, setMode] = useMode();
      setMode(mode);
  }
  function useIsMode(mode) {
      const [currentMode] = useMode();
      return currentMode === mode;
  }
  function useIsEager() {
      return useIsMode(exports.Modes.EAGER);
  }
  function useIsOne() {
      return useIsMode(exports.Modes.ONE);
  }
  function useShouldSkipBasedOnMode(testData) {
      if (useIsOne()) {
          return hasErrorsByTestObjects();
      }
      if (useIsEager()) {
          return hasErrorsByTestObjects(testData.fieldName);
      }
      return false;
  }

  /**
   * Conditionally omits tests from the suite.
   *
   * @example
   *
   * omitWhen(res => res.hasErrors('username'), () => {
   *  test('username', 'User already taken', async () => await doesUserExist(username)
   * });
   */
  // @vx-allow use-use
  function omitWhen(conditional, callback) {
      vestjsRuntime.Isolate.create(VestIsolateType.OmitWhen, () => {
          SuiteContext.run({
              omitted: useWithinActiveOmitWhen() ||
                  vestUtils.optionalFunctionValue(conditional, vestUtils.optionalFunctionValue(useCreateSuiteResult)),
          }, callback);
      });
  }
  // Checks that we're currently in an active omitWhen block
  function useWithinActiveOmitWhen() {
      return useOmitted();
  }

  function useVerifyTestRun(testObject, collisionResult = testObject) {
      const testData = VestTest.getData(testObject);
      if (useShouldSkipBasedOnMode(testData)) {
          return skipTestAndReturn(testObject);
      }
      if (useShouldOmit(testData.fieldName)) {
          return omitTestAndReturn(testObject);
      }
      if (useIsExcluded(testObject)) {
          return useForceSkipIfInSkipWhen(collisionResult);
      }
      return testObject;
  }
  function useShouldOmit(fieldName) {
      return useWithinActiveOmitWhen() || useIsOptionalFieldApplied(fieldName);
  }
  function skipTestAndReturn(testNode) {
      VestTest.skip(testNode);
      return testNode;
  }
  function omitTestAndReturn(testNode) {
      VestTest.omit(testNode);
      return testNode;
  }
  function useForceSkipIfInSkipWhen(testNode) {
      // We're forcing skipping the pending test
      // if we're directly within a skipWhen block
      // This mostly means that we're probably giving
      // up on this async test intentionally.
      VestTest.skip(testNode, useIsExcludedIndividually());
      return testNode;
  }

  class IsolateTestReconciler {
      static match(currentNode, historyNode) {
          return VestTest.is(currentNode) && VestTest.is(historyNode);
      }
      static reconcile(currentNode, historyNode) {
          const reconcilerOutput = usePickNode(currentNode, historyNode);
          const nextNode = useVerifyTestRun(currentNode, reconcilerOutput);
          cancelOverriddenPendingTestOnTestReRun(nextNode, currentNode, historyNode);
          return nextNode;
      }
  }
  function usePickNode(newNode, prevNode) {
      if (vestjsRuntime.IsolateInspector.usesKey(newNode)) {
          return useHandleTestWithKey(newNode);
      }
      if (vestjsRuntime.Reconciler.dropNextNodesOnReorder(nodeReorderDetected, newNode, prevNode)) {
          throwTestOrderError(newNode, prevNode);
          return newNode;
      }
      if (!VestTest.is(prevNode)) {
          // I believe we cannot actually reach this point.
          // Because it should already be handled by nodeReorderDetected.
          /* istanbul ignore next */
          return newNode;
      }
      // FIXME: May-13-2023
      // This may not be the most ideal solution.
      // In short: if the node was omitted in the previous run,
      // we want to re-evaluate it. The reason is that we may incorrectly
      // identify it is "optional" because it was omitted in the previous run.
      // There may be a better way to handle this. Need to revisit this.
      if (VestTest.isOmitted(prevNode)) {
          return newNode;
      }
      return prevNode;
  }
  function useHandleTestWithKey(newNode) {
      return VestTest.cast(vestjsRuntime.Reconciler.handleIsolateNodeWithKey(newNode, (prevNode) => {
          // This is the revoke callback. it determines whether we should revoke the previous node and use the new one.
          if (VestTest.isNonActionable(prevNode)) {
              return true;
          }
          if (useIsExcluded(newNode)) {
              return false;
          }
          return true;
      }));
  }
  function cancelOverriddenPendingTestOnTestReRun(nextNode, currentNode, prevTestObject) {
      if (nextNode === currentNode && VestTest.is(currentNode)) {
          cancelOverriddenPendingTest(prevTestObject, currentNode);
      }
  }
  function nodeReorderDetected(newNode, prevNode) {
      return VestTest.is(prevNode) && !isSameProfileTest(prevNode, newNode);
  }
  function throwTestOrderError(newNode, prevNode) {
      if (vestjsRuntime.IsolateInspector.canReorder(newNode)) {
          return;
      }
      vestUtils.deferThrow(vestUtils.text(ErrorStrings.TESTS_CALLED_IN_DIFFERENT_ORDER, {
          fieldName: VestTest.getData(newNode).fieldName,
          prevName: VestTest.is(prevNode)
              ? VestTest.getData(prevNode).fieldName
              : undefined,
      }));
  }

  const reconcilers = [IsolateTestReconciler];
  function registerReconciler(reconciler) {
      if (reconcilers.includes(reconciler)) {
          return;
      }
      reconcilers.push(reconciler);
  }
  function VestReconciler(currentNode, historyNode) {
      var _a, _b;
      return ((_b = (_a = reconcilers
          .find(reconciler => reconciler.match(currentNode, historyNode))) === null || _a === void 0 ? void 0 : _a.reconcile(currentNode, historyNode)) !== null && _b !== void 0 ? _b : null);
  }

  function group(...args) {
      const [callback, groupName] = args.reverse();
      return vestjsRuntime.Isolate.create(VestIsolateType.Group, () => {
          return SuiteContext.run(Object.assign({}, (groupName && { groupName })), callback);
      });
  }

  /**
   * Conditionally includes a field for testing, based on specified criteria.
   *
   * @param {string} fieldName - The name of the field to include for testing.
   *
   * @example
   * include('confirm').when('password');
   * // Includes the "confirm" field for testing when the "password" field is included
   *
   * include('confirm').when(someValue);
   * // Includes the "confirm" field for testing when the value of `someValue` is true
   *
   * include('confirm').when(() => someValue);
   * // Includes the "confirm" field for testing when the callback function returns true
   *
   * include('username').when(result => result.hasErrors('username'));
   * // Includes the "username" field for testing when there are errors associated with it in the current suite result
   */
  // @vx-allow use-use
  function include(fieldName) {
      vestUtils.invariant(vestUtils.isStringValue(fieldName));
      const inclusion = useInclusion();
      inclusion[fieldName] = true;
      return { when };
      /**
       * Specifies the inclusion criteria for the field in `include` function.
       */
      function when(condition) {
          vestUtils.invariant(condition !== fieldName, ErrorStrings.INCLUDE_SELF);
          const inclusion = useInclusion();
          // This callback will run as part of the "isExcluded" series of checks
          inclusion[fieldName] = function isIncluded(currentNode) {
              if (vestUtils.isStringValue(condition)) {
                  return useHasOnliedTests(currentNode, condition);
              }
              return vestUtils.optionalFunctionValue(condition, vestUtils.optionalFunctionValue(useCreateSuiteResult));
          };
      }
  }

  var Events;
  (function (Events) {
      Events["TEST_RUN_STARTED"] = "test_run_started";
      Events["TEST_COMPLETED"] = "test_completed";
      Events["ALL_RUNNING_TESTS_FINISHED"] = "all_running_tests_finished";
      Events["REMOVE_FIELD"] = "remove_field";
      Events["RESET_FIELD"] = "reset_field";
      Events["RESET_SUITE"] = "reset_suite";
      Events["SUITE_RUN_STARTED"] = "suite_run_started";
      Events["SUITE_CALLBACK_RUN_FINISHED"] = "SUITE_CALLBACK_RUN_FINISHED";
      Events["DONE_TEST_OMISSION_PASS"] = "DONE_TEST_OMISSION_PASS";
  })(Events || (Events = {}));

  function IsolateTest(callback, input, key) {
      const payload = Object.assign(Object.assign({}, IsolateTestBase()), { fieldName: input.fieldName, testFn: input.testFn });
      if (input.groupName) {
          payload.groupName = input.groupName;
      }
      if (input.message) {
          payload.message = input.message;
      }
      const isolate = vestjsRuntime.Isolate.create(VestIsolateType.Test, callback, payload, key !== null && key !== void 0 ? key : null);
      return isolate;
  }
  function IsolateTestBase() {
      return {
          severity: TestSeverity.Error,
          status: IsolateTestStateMachine.initial(),
      };
  }

  function shouldUseErrorAsMessage(message, error) {
      // kind of cheating with this safe guard, but it does the job
      return vestUtils.isUndefined(message) && vestUtils.isStringValue(error);
  }

  // eslint-disable-next-line max-statements
  function useAttemptRunTest(testObject) {
      useVerifyTestRun(testObject);
      if (VestTest.isUntested(testObject)) {
          return useRunTest(testObject);
      }
      if (!VestTest.isNonActionable(testObject)) {
          // Probably unreachable. If we get here, it means that
          // something was really wrong and should be reported.
          /* istanbul ignore next */
          vestUtils.deferThrow(vestUtils.text(ErrorStrings.UNEXPECTED_TEST_REGISTRATION_ERROR, {
              testObject: JSON.stringify(testObject),
          }));
      }
  }
  function runSyncTest(testObject) {
      return SuiteContext.run({ currentTest: testObject }, () => {
          let result;
          const { message, testFn } = VestTest.getData(testObject);
          try {
              result = testFn({ signal: testObject.abortController.signal });
          }
          catch (error) {
              if (shouldUseErrorAsMessage(message, error)) {
                  VestTest.getData(testObject).message = error;
              }
              result = false;
          }
          if (result === false) {
              VestTest.fail(testObject);
          }
          return result;
      });
  }
  /**
   * runs test, if async - adds to pending array
   */
  function useRunTest(testObject) {
      // Run test callback.
      // If a promise is returned, set as async and
      // Move to pending list.
      const result = runSyncTest(testObject);
      try {
          // try catch for safe property access
          // in case object is an enforce chain
          if (vestUtils.isPromise(result)) {
              VestTest.getData(testObject).asyncTest = result;
              return useRunAsyncTest(testObject);
          }
          onTestCompleted(testObject);
      }
      catch (e) {
          // Probably unreachable. If we get here, it means that
          // something was really wrong and should be reported.
          /* istanbul ignore next */
          throw new Error(vestUtils.text(ErrorStrings.UNEXPECTED_TEST_REGISTRATION_ERROR, {
              testObject: JSON.stringify(testObject),
              error: e,
          }));
      }
  }
  /**
   * Runs async test.
   */
  function useRunAsyncTest(testObject) {
      const { asyncTest, message } = VestTest.getData(testObject);
      if (!vestUtils.isPromise(asyncTest))
          return;
      // VestTest.setPending(testObject);
      const done = vestjsRuntime.VestRuntime.persist(() => {
          onTestCompleted(testObject);
      });
      const fail = vestjsRuntime.VestRuntime.persist((rejectionMessage) => {
          if (VestTest.isCanceled(testObject)) {
              return;
          }
          VestTest.getData(testObject).message = vestUtils.isStringValue(rejectionMessage)
              ? rejectionMessage
              : message;
          VestTest.fail(testObject);
          done();
      });
      return asyncTest.then(done, fail);
  }
  function onTestCompleted(testObject) {
      // Attempts passing if the test is not already failed.
      // or is not canceled/omitted.
      VestTest.pass(testObject);
  }

  // @vx-allow use-use
  function wrapTestMemo(test) {
      function memo(fieldName, ...args) {
          const [deps, testFn, msg] = args.reverse();
          // Implicit dependency for better specificity
          const dependencies = [
              useSuiteId(),
              fieldName,
              vestjsRuntime.VestRuntime.useCurrentCursor(),
          ].concat(deps);
          return useGetTestFromCache(dependencies, cacheAction);
          function cacheAction() {
              return test(fieldName, msg, testFn);
          }
      }
      return memo;
  }
  function useGetTestFromCache(dependencies, cacheAction) {
      const cache = useTestMemoCache();
      const cached = cache.get(dependencies);
      if (vestUtils.isNull(cached)) {
          // cache miss
          return cache(dependencies, cacheAction);
      }
      const [, cachedValue] = cached;
      if (VestTest.isCanceled(cachedValue)) {
          // cache hit, but test is canceled
          cache.invalidate(dependencies);
          return cache(dependencies, cacheAction);
      }
      vestjsRuntime.VestRuntime.addNodeToHistory(cachedValue);
      return cachedValue;
  }

  // @vx-allow use-use
  function vestTest(fieldName, ...args) {
      const [message, testFn, key] = (vestUtils.isFunction(args[1]) ? args : [undefined, ...args]);
      validateTestParams(fieldName, testFn);
      const groupName = useGroupName();
      const testObjectInput = { fieldName, groupName, message, testFn };
      // This invalidates the suite cache.
      vestjsRuntime.Bus.useEmit(Events.TEST_RUN_STARTED);
      return IsolateTest(useAttemptRunTest, testObjectInput, key);
  }
  const test = vestUtils.assign(vestTest, {
      memo: wrapTestMemo(vestTest),
  });
  function validateTestParams(fieldName, testFn) {
      const fnName = 'test';
      vestUtils.invariant(vestUtils.isStringValue(fieldName), vestUtils.text(ErrorStrings.INVALID_PARAM_PASSED_TO_FUNCTION, {
          fn_name: fnName,
          param: 'fieldName',
          expected: 'string',
      }));
      vestUtils.invariant(vestUtils.isFunction(testFn), vestUtils.text(ErrorStrings.INVALID_PARAM_PASSED_TO_FUNCTION, {
          fn_name: fnName,
          param: 'callback',
          expected: 'function',
      }));
  }

  // import { optional, skipWhen, omitWhen, IsolateTest, group } from 'vest';
  function getTypedMethods() {
      return {
          group,
          include,
          omitWhen,
          only,
          optional,
          skip,
          skipWhen,
          test,
      };
  }

  /**
   * This module gets triggered once the suite is done running its sync tests.
   *
   * It goes over all the tests in the state, and checks if they need to be omitted.
   */
  function useOmitOptionalFields() {
      const root = vestjsRuntime.VestRuntime.useAvailableRoot();
      const optionalFields = SuiteOptionalFields.getOptionalFields(root);
      // If there are no optional fields, we don't need to do anything
      if (vestUtils.isEmpty(optionalFields)) {
          return;
      }
      // Create an object to store the fields that need to be omitted
      const shouldOmit = new Set();
      // iterate over each of the tests in the state
      TestWalker.walkTests(testObject => {
          if (VestTest.isPending(testObject)) {
              return;
          }
          const { fieldName } = VestTest.getData(testObject);
          // If we already added the current field (not this test specifically)
          // no need for further checks, go and omit the test
          if (shouldOmit.has(fieldName)) {
              verifyAndOmit(testObject);
          }
          else {
              // check if the field has an optional function
              // if so, run it and verify/omit the test
              runOptionalConfig(testObject);
          }
      });
      vestjsRuntime.Bus.useEmit(Events.DONE_TEST_OMISSION_PASS);
      function verifyAndOmit(testObject) {
          const { fieldName } = VestTest.getData(testObject);
          if (shouldOmit.has(fieldName)) {
              VestTest.omit(testObject);
              SuiteOptionalFields.setOptionalField(root, fieldName, current => (Object.assign(Object.assign({}, current), { applied: true })));
          }
      }
      function runOptionalConfig(testObject) {
          const { fieldName } = VestTest.getData(testObject);
          // Ge the optional configuration for the given field
          const optionalConfig = SuiteOptionalFields.getOptionalField(root, fieldName);
          // If the optional was set to a function or a boolean, run it and verify/omit the test
          if (vestUtils.optionalFunctionValue(optionalConfig.rule) === true) {
              shouldOmit.add(fieldName);
          }
          verifyAndOmit(testObject);
      }
  }

  /**
   * Runs done callback per field when async tests are finished running.
   */
  function useRunFieldCallbacks(fieldName) {
      const [fieldCallbacks] = useFieldCallbacks();
      if (fieldName &&
          !SuiteWalker.hasRemainingWithTestNameMatching(fieldName) &&
          vestUtils.isArray(fieldCallbacks[fieldName])) {
          vestUtils.callEach(fieldCallbacks[fieldName]);
      }
  }
  /**
   * Runs unlabelled done callback when async tests are finished running.
   */
  function useRunDoneCallbacks() {
      const [doneCallbacks] = useDoneCallbacks();
      vestUtils.callEach(doneCallbacks);
  }

  // eslint-disable-next-line max-statements, max-lines-per-function
  function useInitVestBus() {
      const VestBus = vestjsRuntime.Bus.useBus();
      // Report a the completion of a test. There may be other tests with the same
      // name that are still running, or not yet started.
      on(Events.TEST_COMPLETED, (testObject) => {
          if (VestTest.isCanceled(testObject)) {
              return;
          }
          const { fieldName } = VestTest.getData(testObject);
          useRunFieldCallbacks(fieldName);
      });
      on(Events.TEST_RUN_STARTED, () => {
          /* Let's just invalidate the suite cache for now */
      });
      on(vestjsRuntime.RuntimeEvents.ISOLATE_PENDING, (isolate) => {
          if (VestTest.is(isolate)) {
              VestTest.setPending(isolate);
          }
          setPending(isolate);
      });
      on(vestjsRuntime.RuntimeEvents.ISOLATE_DONE, (isolate) => {
          if (VestTest.is(isolate)) {
              VestBus.emit(Events.TEST_COMPLETED, isolate);
          }
          setDone(isolate);
          if (!SuiteWalker.hasPending()) {
              // When no more tests are running, emit the done event
              VestBus.emit(Events.ALL_RUNNING_TESTS_FINISHED);
          }
      });
      on(Events.DONE_TEST_OMISSION_PASS, () => {
          /* We NEED to refresh the cache here. Don't ask */
      });
      // Called when all the tests, including async, are done running
      on(Events.ALL_RUNNING_TESTS_FINISHED, () => {
          // Small optimization. We don't need to run this if there are no async tests
          // The reason is that we run this function immediately after the suite callback
          // is run, so if the suite is only comprised of sync tests, we don't need to
          // run this function twice since we know for a fact the state is up to date
          if (TestWalker.someTests(VestTest.isAsyncTest)) {
              useOmitOptionalFields();
          }
          useRunDoneCallbacks();
      });
      on(Events.RESET_FIELD, (fieldName) => {
          TestWalker.resetField(fieldName);
      });
      on(Events.SUITE_RUN_STARTED, () => {
          useResetCallbacks();
      });
      on(Events.SUITE_CALLBACK_RUN_FINISHED, () => {
          useOmitOptionalFields();
      });
      on(Events.REMOVE_FIELD, (fieldName) => {
          TestWalker.removeTestByFieldName(fieldName);
      });
      on(Events.RESET_SUITE, () => {
          useResetSuite();
      });
      return {
          subscribe,
      };
      function subscribe(cb) {
          return VestBus.on('*', () => {
              cb();
          }).off;
      }
      function on(event, cb) {
          VestBus.on(event, (...args) => {
              // This is more concise, but it might be an overkill
              // if we're adding events that don't need to invalidate the cache
              useExpireSuiteResultCache();
              cb(...args);
          });
      }
  }

  function useDeferDoneCallback(doneCallback, fieldName) {
      const [, setFieldCallbacks] = useFieldCallbacks();
      const [, setDoneCallbacks] = useDoneCallbacks();
      if (fieldName) {
          setFieldCallbacks(fieldCallbacks => vestUtils.assign(fieldCallbacks, {
              [fieldName]: (fieldCallbacks[fieldName] || []).concat(doneCallback),
          }));
          return;
      }
      setDoneCallbacks(doneCallbacks => doneCallbacks.concat(doneCallback));
  }

  /**
   * DONE is here and not in its own module to prevent circular dependency issues.
   */
  function shouldSkipDoneRegistration(callback, fieldName, output) {
      var _a, _b;
      // If we do not have any test runs for the current field
      return !!(!vestUtils.isFunction(callback) ||
          (fieldName && vestUtils.numberEquals((_b = (_a = output.tests[fieldName]) === null || _a === void 0 ? void 0 : _a.testCount) !== null && _b !== void 0 ? _b : 0, 0)));
  }

  function useSuiteRunResult() {
      return Object.freeze(vestUtils.assign({
          done: vestjsRuntime.VestRuntime.persist(done),
      }, useCreateSuiteResult()));
  }
  /**
   * Registers done callbacks.
   * @register {Object} Vest output object.
   */
  // @vx-allow use-use
  function done(...args) {
      const [callback, fieldName] = args.reverse();
      const output = useSuiteRunResult();
      if (shouldSkipDoneRegistration(callback, fieldName, output)) {
          return output;
      }
      const useDoneCallback = () => callback(useCreateSuiteResult());
      if (!SuiteWalker.hasRemainingWithTestNameMatching(fieldName)) {
          useDoneCallback();
          return output;
      }
      useDeferDoneCallback(useDoneCallback, fieldName);
      return output;
  }

  function validateSuiteCallback(suiteCallback) {
      vestUtils.invariant(vestUtils.isFunction(suiteCallback), ErrorStrings.SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION);
  }

  // @vx-allow use-use
  // eslint-disable-next-line max-lines-per-function
  function createSuite(...args) {
      const [suiteCallback, suiteName] = args.reverse();
      validateSuiteCallback(suiteCallback);
      // Create a stateRef for the suite
      // It holds the suite's persisted values that may remain between runs.
      const stateRef = useCreateVestState({ suiteName, VestReconciler });
      function suite(...args) {
          return SuiteContext.run({
              suiteParams: args,
          }, () => {
              vestjsRuntime.Bus.useEmit(Events.SUITE_RUN_STARTED);
              return IsolateSuite(useRunSuiteCallback(suiteCallback, ...args));
          }).output;
      }
      const mountedStatic = staticSuite(...args);
      // Assign methods to the suite
      // We do this within the VestRuntime so that the suite methods
      // will be bound to the suite's stateRef and be able to access it.
      return vestjsRuntime.VestRuntime.Run(stateRef, () => {
          // @vx-allow use-use
          const VestBus = useInitVestBus();
          return vestUtils.assign(
          // We're also binding the suite to the stateRef, so that the suite
          // can access the stateRef when it's called.
          vestjsRuntime.VestRuntime.persist(suite), Object.assign(Object.assign({ dump: vestjsRuntime.VestRuntime.persist(() => vestjsRuntime.VestRuntime.useAvailableRoot()), get: vestjsRuntime.VestRuntime.persist(useCreateSuiteResult), remove: vestjsRuntime.Bus.usePrepareEmitter(Events.REMOVE_FIELD), reset: vestjsRuntime.Bus.usePrepareEmitter(Events.RESET_SUITE), resetField: vestjsRuntime.Bus.usePrepareEmitter(Events.RESET_FIELD), resume: vestjsRuntime.VestRuntime.persist(useLoadSuite), runStatic: (...args) => mountedStatic(...args), subscribe: VestBus.subscribe }, bindSuiteSelectors(vestjsRuntime.VestRuntime.persist(useCreateSuiteResult))), getTypedMethods()));
      });
  }
  function useRunSuiteCallback(suiteCallback, ...args) {
      const emit = vestjsRuntime.Bus.useEmit();
      return () => {
          suiteCallback(...args);
          emit(Events.SUITE_CALLBACK_RUN_FINISHED);
          return useSuiteRunResult();
      };
  }
  // @vx-allow use-use
  // eslint-disable-next-line max-lines-per-function
  function staticSuite(...createArgs) {
      return vestUtils.assign((...args) => {
          const suite = createSuite(...createArgs);
          const result = suite(...args);
          return Object.freeze(vestUtils.assign({
              dump: suite.dump,
          }, result));
      }, Object.assign({}, getTypedMethods()));
  }

  function IsolateEach(callback) {
      return vestjsRuntime.Isolate.create(VestIsolateType.Each, callback, {
          allowReorder: true,
      });
  }

  /**
   * Iterates over an array of items, allowing to run tests individually per item.
   *
   * Requires setting a "key" property on each item tested.
   *
   * @example
   *
   * each(itemsArray, (item) => {
   *  test(item.name, 'Item value must not be empty', () => {
   *    enforce(item.value).isNotEmpty();
   *  }, item.id)
   * })
   */
  function each(list, callback) {
      vestUtils.invariant(vestUtils.isFunction(callback), ErrorStrings.EACH_CALLBACK_MUST_BE_A_FUNCTION);
      IsolateEach(() => {
          list.forEach((arg, index) => {
              callback(arg, index);
          });
      });
  }

  const ERROR_OUTSIDE_OF_TEST = ErrorStrings.WARN_MUST_BE_CALLED_FROM_TEST;
  /**
   * Sets the severity level of a test to `warn`, allowing it to fail without marking the suite as invalid.
   * Use this function within the body of a test to create warn-only tests.
   *
   * @returns {void}
   *
   * @example
   *   test('password', 'Your password strength is: WEAK', () => {
   *     warn();
   *
   *     enforce(data.password).matches(/0-9/);
   *   });
   *
   * @limitations
   * - The `warn` function should only be used within the body of a `test` function.
   * - When using `warn()` in an async test, it should be called in the synchronous portion of the test, not after an `await` call or in the Promise body.
   * - It is recommended to call `warn()` at the top of the test function.
   */
  // @vx-allow use-use
  function warn() {
      const currentTest = useCurrentTest(ErrorStrings.HOOK_CALLED_OUTSIDE);
      vestUtils.invariant(currentTest, ERROR_OUTSIDE_OF_TEST);
      VestTest.warn(currentTest);
  }

  Object.defineProperty(exports, 'enforce', {
    enumerable: true,
    get: function () { return n4s.enforce; }
  });
  exports.create = createSuite;
  exports.each = each;
  exports.group = group;
  exports.include = include;
  exports.mode = mode;
  exports.omitWhen = omitWhen;
  exports.only = only;
  exports.optional = optional;
  exports.registerReconciler = registerReconciler;
  exports.skip = skip;
  exports.skipWhen = skipWhen;
  exports.staticSuite = staticSuite;
  exports.suiteSelectors = suiteSelectors;
  exports.test = test;
  exports.warn = warn;

}));
//# sourceMappingURL=vest.development.js.map
