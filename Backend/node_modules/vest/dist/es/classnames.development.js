import { invariant, hasOwnProperty, isNullish, isPositive, isFunction } from 'vest-utils';
import { suiteSelectors } from 'vest';

var ErrorStrings;
(function (ErrorStrings) {
    ErrorStrings["HOOK_CALLED_OUTSIDE"] = "hook called outside of a running suite.";
    ErrorStrings["EXPECTED_VEST_TEST"] = "Expected value to be an instance of IsolateTest";
    ErrorStrings["FIELD_NAME_REQUIRED"] = "Field name must be passed";
    ErrorStrings["SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION"] = "Suite must be initialized with a function";
    ErrorStrings["PROMISIFY_REQUIRE_FUNCTION"] = "Vest.Promisify must be called with a function";
    ErrorStrings["PARSER_EXPECT_RESULT_OBJECT"] = "Vest parser: expected argument at position 0 to be Vest's result object.";
    ErrorStrings["WARN_MUST_BE_CALLED_FROM_TEST"] = "Warn must be called from within the body of a test function";
    ErrorStrings["EACH_CALLBACK_MUST_BE_A_FUNCTION"] = "Each must be called with a function";
    ErrorStrings["INVALID_PARAM_PASSED_TO_FUNCTION"] = "Incompatible params passed to {fn_name} function. \"{param}\" must be of type {expected}";
    ErrorStrings["TESTS_CALLED_IN_DIFFERENT_ORDER"] = "Vest Critical Error: Tests called in different order than previous run.\n    expected: {fieldName}\n    received: {prevName}\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state.";
    ErrorStrings["UNEXPECTED_TEST_REGISTRATION_ERROR"] = "Unexpected error encountered during test registration.\n      Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.\n      Error: {error}.";
    ErrorStrings["UNEXPECTED_TEST_RUN_ERROR"] = "Unexpected error encountered during test run. Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.";
    ErrorStrings["INCLUDE_SELF"] = "Trying to call include.when on the same field.";
})(ErrorStrings || (ErrorStrings = {}));

function parse(summary) {
    invariant(summary && hasOwnProperty(summary, 'valid'), ErrorStrings.PARSER_EXPECT_RESULT_OBJECT);
    const sel = suiteSelectors(summary);
    const testedStorage = {};
    const selectors = {
        invalid: sel.hasErrors,
        pending: sel.isPending,
        tested: isTested,
        untested: isUntested,
        valid: sel.isValid,
        warning: sel.hasWarnings,
    };
    return selectors;
    // Booleans
    function isTested(fieldName) {
        if (isNullish(fieldName)) {
            return isPositive(summary.testCount);
        }
        if (hasOwnProperty(testedStorage, fieldName)) {
            return testedStorage[fieldName];
        }
        addFieldToTestedStorage(fieldName);
        return selectors.tested(fieldName);
    }
    function addFieldToTestedStorage(fieldName) {
        testedStorage[fieldName] =
            hasOwnProperty(summary.tests, fieldName) &&
                isPositive(summary.tests[fieldName].testCount);
    }
    function isUntested(fieldName) {
        return !(isPositive(summary.testCount) && selectors.tested(fieldName));
    }
}

/**
 * Creates a function that returns class names that match the validation result
 */
function classnames(res, classes = {}) {
    const selectors = parse(res);
    return function cn(fieldName) {
        const classesArray = [];
        for (const selector in classes) {
            const sel = selector;
            if (isFunction(selectors[sel]) && selectors[sel](fieldName)) {
                classesArray.push(classes[sel]);
            }
        }
        return classesArray.join(' ');
    };
}

export { classnames as default };
//# sourceMappingURL=classnames.development.js.map
