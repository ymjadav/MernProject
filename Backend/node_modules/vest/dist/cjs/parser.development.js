'use strict';

var vest = require('vest');
var vestUtils = require('vest-utils');

var ErrorStrings;
(function (ErrorStrings) {
    ErrorStrings["HOOK_CALLED_OUTSIDE"] = "hook called outside of a running suite.";
    ErrorStrings["EXPECTED_VEST_TEST"] = "Expected value to be an instance of IsolateTest";
    ErrorStrings["FIELD_NAME_REQUIRED"] = "Field name must be passed";
    ErrorStrings["SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION"] = "Suite must be initialized with a function";
    ErrorStrings["PROMISIFY_REQUIRE_FUNCTION"] = "Vest.Promisify must be called with a function";
    ErrorStrings["PARSER_EXPECT_RESULT_OBJECT"] = "Vest parser: expected argument at position 0 to be Vest's result object.";
    ErrorStrings["WARN_MUST_BE_CALLED_FROM_TEST"] = "Warn must be called from within the body of a test function";
    ErrorStrings["EACH_CALLBACK_MUST_BE_A_FUNCTION"] = "Each must be called with a function";
    ErrorStrings["INVALID_PARAM_PASSED_TO_FUNCTION"] = "Incompatible params passed to {fn_name} function. \"{param}\" must be of type {expected}";
    ErrorStrings["TESTS_CALLED_IN_DIFFERENT_ORDER"] = "Vest Critical Error: Tests called in different order than previous run.\n    expected: {fieldName}\n    received: {prevName}\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state.";
    ErrorStrings["UNEXPECTED_TEST_REGISTRATION_ERROR"] = "Unexpected error encountered during test registration.\n      Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.\n      Error: {error}.";
    ErrorStrings["UNEXPECTED_TEST_RUN_ERROR"] = "Unexpected error encountered during test run. Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.";
    ErrorStrings["INCLUDE_SELF"] = "Trying to call include.when on the same field.";
})(ErrorStrings || (ErrorStrings = {}));

function parse(summary) {
    vestUtils.invariant(summary && vestUtils.hasOwnProperty(summary, 'valid'), ErrorStrings.PARSER_EXPECT_RESULT_OBJECT);
    const sel = vest.suiteSelectors(summary);
    const testedStorage = {};
    const selectors = {
        invalid: sel.hasErrors,
        pending: sel.isPending,
        tested: isTested,
        untested: isUntested,
        valid: sel.isValid,
        warning: sel.hasWarnings,
    };
    return selectors;
    // Booleans
    function isTested(fieldName) {
        if (vestUtils.isNullish(fieldName)) {
            return vestUtils.isPositive(summary.testCount);
        }
        if (vestUtils.hasOwnProperty(testedStorage, fieldName)) {
            return testedStorage[fieldName];
        }
        addFieldToTestedStorage(fieldName);
        return selectors.tested(fieldName);
    }
    function addFieldToTestedStorage(fieldName) {
        testedStorage[fieldName] =
            vestUtils.hasOwnProperty(summary.tests, fieldName) &&
                vestUtils.isPositive(summary.tests[fieldName].testCount);
    }
    function isUntested(fieldName) {
        return !(vestUtils.isPositive(summary.testCount) && selectors.tested(fieldName));
    }
}

exports.parse = parse;
//# sourceMappingURL=parser.development.js.map
