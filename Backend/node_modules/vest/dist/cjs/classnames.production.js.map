{"version":3,"file":"classnames.production.js","sources":["../../src/errors/ErrorStrings.ts","../../src/exports/classnames.ts","../../src/exports/parser.ts"],"sourcesContent":["export enum ErrorStrings {\n  HOOK_CALLED_OUTSIDE = 'hook called outside of a running suite.',\n  EXPECTED_VEST_TEST = 'Expected value to be an instance of IsolateTest',\n  FIELD_NAME_REQUIRED = 'Field name must be passed',\n  SUITE_MUST_BE_INITIALIZED_WITH_FUNCTION = 'Suite must be initialized with a function',\n  PROMISIFY_REQUIRE_FUNCTION = 'Vest.Promisify must be called with a function',\n  PARSER_EXPECT_RESULT_OBJECT = \"Vest parser: expected argument at position 0 to be Vest's result object.\",\n  WARN_MUST_BE_CALLED_FROM_TEST = 'Warn must be called from within the body of a test function',\n  EACH_CALLBACK_MUST_BE_A_FUNCTION = 'Each must be called with a function',\n  INVALID_PARAM_PASSED_TO_FUNCTION = 'Incompatible params passed to {fn_name} function. \"{param}\" must be of type {expected}',\n  TESTS_CALLED_IN_DIFFERENT_ORDER = `Vest Critical Error: Tests called in different order than previous run.\n    expected: {fieldName}\n    received: {prevName}\n    This can happen on one of two reasons:\n    1. You're using if/else statements to conditionally select tests. Instead, use \"skipWhen\".\n    2. You are iterating over a list of tests, and their order changed. Use \"each\" and a custom key prop so that Vest retains their state.`,\n  UNEXPECTED_TEST_REGISTRATION_ERROR = `Unexpected error encountered during test registration.\n      Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.\n      Error: {error}.`,\n  UNEXPECTED_TEST_RUN_ERROR = `Unexpected error encountered during test run. Please report this issue to Vest's Github repository.\n      Test Object: {testObject}.`,\n  INCLUDE_SELF = 'Trying to call include.when on the same field.',\n}\n","import { isFunction } from 'vest-utils';\n\nimport { SuiteSummary, TFieldName, TGroupName } from 'SuiteResultTypes';\nimport { ParsedVestObject, parse } from 'parser';\n\n/**\n * Creates a function that returns class names that match the validation result\n */\nexport default function classnames<F extends TFieldName, G extends TGroupName>(\n  res: SuiteSummary<F, G>,\n  classes: SupportedClasses = {}\n): (fieldName: F) => string {\n  const selectors = parse(res);\n\n  return function cn(fieldName: F): string {\n    const classesArray: string[] = [];\n\n    for (const selector in classes) {\n      const sel = selector as keyof SupportedClasses;\n      if (isFunction(selectors[sel]) && selectors[sel](fieldName)) {\n        classesArray.push(classes[sel] as string);\n      }\n    }\n\n    return classesArray.join(' ');\n  };\n}\n\ntype SupportedClasses = {\n  [K in keyof ParsedVestObject<TFieldName>]?: string;\n};\n","import { suiteSelectors } from 'vest';\nimport { hasOwnProperty, invariant, isNullish, isPositive } from 'vest-utils';\n\nimport { ErrorStrings } from 'ErrorStrings';\nimport { SuiteSummary, TFieldName, TGroupName } from 'SuiteResultTypes';\n\nexport function parse<F extends TFieldName, G extends TGroupName>(\n  summary: SuiteSummary<F, G>\n): ParsedVestObject<F> {\n  invariant(\n    summary && hasOwnProperty(summary, 'valid'),\n    ErrorStrings.PARSER_EXPECT_RESULT_OBJECT\n  );\n\n  const sel = suiteSelectors(summary);\n\n  const testedStorage: Record<string, boolean> = {};\n\n  const selectors = {\n    invalid: sel.hasErrors,\n    pending: sel.isPending,\n    tested: isTested,\n    untested: isUntested,\n    valid: sel.isValid,\n    warning: sel.hasWarnings,\n  };\n\n  return selectors;\n\n  // Booleans\n  function isTested(fieldName?: F): boolean {\n    if (isNullish(fieldName)) {\n      return isPositive(summary.testCount);\n    }\n\n    if (hasOwnProperty(testedStorage, fieldName)) {\n      return testedStorage[fieldName];\n    }\n\n    addFieldToTestedStorage(fieldName);\n\n    return selectors.tested(fieldName);\n  }\n\n  function addFieldToTestedStorage(fieldName: F): void {\n    testedStorage[fieldName] =\n      hasOwnProperty(summary.tests, fieldName) &&\n      isPositive(summary.tests[fieldName].testCount);\n  }\n\n  function isUntested(fieldName?: F): boolean {\n    return !(isPositive(summary.testCount) && selectors.tested(fieldName));\n  }\n}\n\nexport type ParsedVestObject<F extends TFieldName> = {\n  valid(fieldName?: F): boolean;\n  tested(fieldName?: F): boolean;\n  invalid(fieldName?: F): boolean;\n  untested(fieldName?: F): boolean;\n  warning(fieldName?: F): boolean;\n  pending(fieldName?: F): boolean;\n};\n"],"names":["ErrorStrings","res","classes","selectors","summary","invariant","hasOwnProperty","PARSER_EXPECT_RESULT_OBJECT","sel","suiteSelectors","testedStorage","invalid","hasErrors","pending","isPending","tested","fieldName","isNullish","isPositive","testCount","addFieldToTestedStorage","untested","valid","isValid","warning","hasWarnings","tests","parse","classesArray","selector","isFunction","push","join"],"mappings":"iBAAYA,6CAAZ,SAAYA,GACVA,EAAA,oBAAA,0CACAA,EAAA,mBAAA,kDACAA,EAAA,oBAAA,4BACAA,EAAA,wCAAA,4CACAA,EAAA,2BAAA,gDACAA,EAAA,4BAAA,2EACAA,EAAA,8BAAA,8DACAA,EAAA,iCAAA,sCACAA,EAAA,iCAAA,yFACAA,EAAA,gCAAA,wZAMAA,EAAA,mCAAA,+KAIAA,EAAA,0BAAA,wIAEAA,EAAA,aAAA,gDACD,CAvBD,CAAYA,IAAAA,EAuBX,CAAA,mBCfuB,SACtBC,EACAC,EAA4B,IAE5B,MAAMC,ECNF,SACJC,GAEAC,EAASA,UACPD,GAAWE,iBAAeF,EAAS,SACnCJ,EAAaO,6BAGf,MAAMC,EAAMC,iBAAeL,GAErBM,EAAyC,CAAA,EAEzCP,EAAY,CAChBQ,QAASH,EAAII,UACbC,QAASL,EAAIM,UACbC,OASF,SAAkBC,GAChB,OAAIC,EAAAA,UAAUD,GACLE,EAAUA,WAACd,EAAQe,WAGxBb,EAAcA,eAACI,EAAeM,GACzBN,EAAcM,IAGvBI,EAAwBJ,GAEjBb,EAAUY,OAAOC,GACzB,EApBCK,SA4BF,SAAoBL,GAClB,QAASE,EAAAA,WAAWd,EAAQe,YAAchB,EAAUY,OAAOC,GAC5D,EA7BCM,MAAOd,EAAIe,QACXC,QAAShB,EAAIiB,aAGf,OAAOtB,EAiBP,SAASiB,EAAwBJ,GAC/BN,EAAcM,GACZV,iBAAeF,EAAQsB,MAAOV,IAC9BE,EAAAA,WAAWd,EAAQsB,MAAMV,GAAWG,UACvC,CAKH,CDzCoBQ,CAAM1B,GAExB,OAAO,SAAYe,GACjB,MAAMY,EAAyB,GAE/B,IAAK,MAAMC,KAAY3B,EAAS,CAC9B,MAAMM,EAAMqB,EACRC,EAAUA,WAAC3B,EAAUK,KAASL,EAAUK,GAAKQ,IAC/CY,EAAaG,KAAK7B,EAAQM,GAE7B,CAED,OAAOoB,EAAaI,KAAK,IAC3B,CACF"}