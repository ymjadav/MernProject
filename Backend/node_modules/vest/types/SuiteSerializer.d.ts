/// <reference types="node" />
import { CB, DynamicValue, OneOrMoreOf, Maybe, ValueOf } from 'vest-utils';
import { TIsolate, IsolateKey } from "vestjs-runtime";
declare enum Severity {
    WARNINGS = "warnings",
    ERRORS = "errors"
}
declare enum TestSeverity {
    Error = "error",
    Warning = "warning"
}
declare const TestStatus: {
    [x: string]: string;
    CANCELED: string;
    FAILED: string;
    OMITTED: string;
    PASSING: string;
    SKIPPED: string;
    UNTESTED: string;
    WARNING: string;
};
type TestStatus = ValueOf<typeof TestStatus>;
type TestFnPayload = {
    signal: AbortSignal;
};
type TestFn = (payload: TestFnPayload) => TestResult;
type AsyncTest = Promise<void>;
type TestResult = Maybe<AsyncTest | boolean> | void;
type WithFieldName<F extends TFieldName = TFieldName> = {
    fieldName: F;
};
type TIsolateTest<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = TIsolate<CommonTestFields<F, G> & IsolateTestPayload>;
type IsolateTestPayload<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = CommonTestFields<F, G> & {
    severity: TestSeverity;
    status: TestStatus;
    asyncTest?: AsyncTest;
};
type CommonTestFields<F extends TFieldName = TFieldName, G extends TGroupName = TGroupName> = {
    message?: Maybe<string>;
    groupName?: G;
    fieldName: F;
    testFn: TestFn;
};
declare class SummaryFailure<F extends TFieldName, G extends TGroupName> implements WithFieldName<F> {
    fieldName: F;
    message: string | undefined;
    groupName: G | undefined;
    constructor(fieldName: F, message: string | undefined, groupName: G | undefined);
    static fromTestObject<F extends TFieldName, G extends TGroupName>(testObject: TIsolateTest<F, G>): SummaryFailure<F & string, G & string>;
}
interface Done<F extends TFieldName, G extends TGroupName> {
    (...args: [
        cb: (res: SuiteResult<F, G>) => void
    ]): SuiteRunResult<F, G>;
    (...args: [
        fieldName: F,
        cb: (res: SuiteResult<F, G>) => void
    ]): SuiteRunResult<F, G>;
}
interface SuiteSelectors<F extends TFieldName, G extends TGroupName> {
    getWarning(): SummaryFailure<F, G> | undefined;
    getWarning(fieldName: F): string | undefined;
    getWarning(fieldName?: F): SummaryFailure<F, G> | string | undefined;
    getError(): SummaryFailure<F, G> | undefined;
    getError(fieldName: F): string | undefined;
    getError(fieldName?: F): SummaryFailure<F, G> | string | undefined;
    getErrors(): FailureMessages;
    getErrors(fieldName: F): string[];
    getErrors(fieldName?: F): string[] | FailureMessages;
    getWarnings(): FailureMessages;
    getWarnings(fieldName: F): string[];
    getWarnings(fieldName?: F): string[] | FailureMessages;
    getErrorsByGroup(groupName: G): FailureMessages;
    getErrorsByGroup(groupName: G, fieldName: F): string[];
    getErrorsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;
    getWarningsByGroup(groupName: G): FailureMessages;
    getWarningsByGroup(groupName: G, fieldName: F): string[];
    getWarningsByGroup(groupName: G, fieldName?: F): string[] | FailureMessages;
    hasErrors(fieldName?: F): boolean;
    hasWarnings(fieldName?: F): boolean;
    hasErrorsByGroup(groupName: G, fieldName?: F): boolean;
    hasWarningsByGroup(groupName: G, fieldName?: F): boolean;
    isTested(fieldName: F): boolean;
    isPending(fieldName?: F): boolean;
    isValid(fieldName?: F): boolean;
    isValidByGroup(groupName: G, fieldName?: F): boolean;
}
declare class SummaryBase {
    errorCount: number;
    warnCount: number;
    testCount: number;
    pendingCount: number;
}
declare class SuiteSummary<F extends TFieldName, G extends TGroupName> extends SummaryBase {
    [Severity.ERRORS]: SummaryFailure<F, G>[];
    [Severity.WARNINGS]: SummaryFailure<F, G>[];
    groups: Groups<G, F>;
    tests: Tests<F>;
    valid: boolean;
}
type GroupTestSummary = SingleTestSummary;
type Groups<G extends TGroupName, F extends TFieldName> = Record<G, Group<F>>;
type Group<F extends TFieldName> = Record<F, GroupTestSummary>;
type Tests<F extends TFieldName> = Record<F, SingleTestSummary>;
type SingleTestSummary = SummaryBase & {
    errors: string[];
    warnings: string[];
    valid: boolean;
    pendingCount: number;
};
type FailureMessages = Record<string, string[]>;
type SuiteResult<F extends TFieldName, G extends TGroupName> = SuiteSummary<F, G> & SuiteSelectors<F, G> & {
    suiteName: SuiteName;
};
type SuiteRunResult<F extends TFieldName, G extends TGroupName> = SuiteResult<F, G> & {
    done: Done<F, G>;
};
type SuiteName = Maybe<string>;
type TFieldName<T extends string = string> = T;
type TGroupName<G extends string = string> = G;
type OptionalFields = Record<string, OptionalFieldDeclaration>;
type OptionalsInput<F extends TFieldName> = OneOrMoreOf<F> | OptionalsObject<F>;
type OptionalsObject<F extends TFieldName> = Record<F, TOptionalRule | any>;
type ImmediateOptionalFieldDeclaration = {
    type: OptionalFieldTypes.CUSTOM_LOGIC;
    rule: TOptionalRule;
    applied: boolean;
};
type DelayedOptionalFieldDeclaration = {
    type: OptionalFieldTypes.AUTO;
    applied: boolean;
    rule: null;
};
type TOptionalRule = DynamicValue<boolean>;
type OptionalFieldDeclaration = ImmediateOptionalFieldDeclaration | DelayedOptionalFieldDeclaration;
declare enum OptionalFieldTypes {
    CUSTOM_LOGIC = 0,
    AUTO = 1
}
type TIsolateSuite = TIsolate<{
    optional: OptionalFields;
}>;
type FieldExclusion<F extends TFieldName> = Maybe<OneOrMoreOf<F>>;
declare function vestTest<F extends TFieldName>(fieldName: F, message: string, cb: TestFn): TIsolateTest;
declare function vestTest<F extends TFieldName>(fieldName: F, cb: TestFn): TIsolateTest;
declare function vestTest<F extends TFieldName>(fieldName: F, message: string, cb: TestFn, key: IsolateKey): TIsolateTest;
declare function vestTest<F extends TFieldName>(fieldName: F, cb: TestFn, key: IsolateKey): TIsolateTest;
declare const test: typeof vestTest & {
    memo: TestMemo<string>;
};
type TestMemo<F extends TFieldName> = {
    (fieldName: F, ...args: ParametersWithoutMessage): TIsolateTest;
    (fieldName: F, ...args: ParametersWithMessage): TIsolateTest;
};
type ParametersWithoutMessage = [
    test: TestFn,
    dependencies: unknown[]
];
type ParametersWithMessage = [
    message: string,
    test: TestFn,
    dependencies: unknown[]
];
type TTypedMethods<F extends TFieldName, G extends TGroupName> = {
    include: (fieldName: F) => {
        when: (condition: F | TDraftCondition<F, G>) => void;
    };
    omitWhen: (conditional: TDraftCondition<F, G>, callback: CB) => void;
    only: {
        (item: FieldExclusion<F>): void;
    };
    optional: (optionals: OptionalsInput<F>) => void;
    skip: {
        (item: FieldExclusion<F>): void;
    };
    skipWhen: (condition: TDraftCondition<F, G>, callback: CB) => void;
    test: {
        (fieldName: F, message: string, cb: TestFn): TIsolateTest;
        (fieldName: F, cb: TestFn): TIsolateTest;
        (fieldName: F, message: string, cb: TestFn, key: IsolateKey): TIsolateTest;
        (fieldName: F, cb: TestFn, key: IsolateKey): TIsolateTest;
    } & {
        memo: TestMemo<F>;
    };
    group: {
        (callback: () => void): TIsolate;
        (groupName: G, callback: () => void): TIsolate;
    };
};
type TDraftCondition<F extends TFieldName, G extends TGroupName> = DynamicValue<boolean, [
    draft: SuiteResult<F, G>
]>;
type StaticSuiteRunResult<F extends TFieldName = string, G extends TGroupName = string> = SuiteRunResult<F, G> & {
    dump: CB<TIsolateSuite>;
} & TTypedMethods<F, G>;
type Suite<F extends TFieldName, G extends TGroupName, T extends CB = CB> = ((...args: Parameters<T>) => SuiteRunResult<F, G>) & SuiteMethods<F, G, T>;
type SuiteMethods<F extends TFieldName, G extends TGroupName, T extends CB> = {
    dump: CB<TIsolateSuite>;
    get: CB<SuiteResult<F, G>>;
    resume: CB<void, [
        TIsolateSuite
    ]>;
    reset: CB<void>;
    remove: CB<void, [
        fieldName: F
    ]>;
    resetField: CB<void, [
        fieldName: F
    ]>;
    runStatic: CB<StaticSuiteRunResult<F, G>, Parameters<T>>;
    subscribe: (cb: CB) => CB<void>;
} & TTypedMethods<F, G> & SuiteSelectors<F, G>;
type Dumpable = {
    dump: CB<TIsolateSuite>;
};
declare class SuiteSerializer {
    static serialize(suite: Dumpable): string;
    static deserialize(serialized: string | TIsolateSuite | Record<string, any>): TIsolateSuite;
    static resume(suite: Suite<TFieldName, TGroupName>, root: string | TIsolateSuite | Record<string, any>): void;
}
export { Dumpable, SuiteSerializer };
//# sourceMappingURL=SuiteSerializer.d.ts.map