{"version":3,"file":"vestjs-runtime.development.js","sources":["../../src/RuntimeEvents.ts","../../src/errors/ErrorStrings.ts","../../src/Isolate/IsolateInspector.ts","../../src/Isolate/IsolateMutator.ts","../../src/VestRuntime.ts","../../src/Bus.ts","../../src/Isolate/IsolateKeys.ts","../../src/Isolate/IsolateSelectors.ts","../../src/Reconciler.ts","../../src/Isolate/Isolate.ts","../../src/IsolateWalker.ts","../../src/exports/IsolateSerializer.ts"],"sourcesContent":["export const RuntimeEvents = {\n  ISOLATE_ENTER: 'ISOLATE_ENTER',\n  ISOLATE_PENDING: 'ISOLATE_PENDING',\n  ISOLATE_DONE: 'ISOLATE_DONE',\n};\n","export enum ErrorStrings {\n  NO_ACTIVE_ISOLATE = 'Not within an active isolate',\n  UNABLE_TO_PICK_NEXT_ISOLATE = 'Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.',\n  ENCOUNTERED_THE_SAME_KEY_TWICE = `Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.`,\n  INVALID_ISOLATE_CANNOT_PARSE = `Invalid isolate was passed to IsolateSerializer. Cannot proceed.`,\n}\n","import { Nullable, isNotNullish, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateInspector {\n  static at(isolate: Nullable<TIsolate>, at: number): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.children?.[at] ?? null;\n  }\n\n  static cursor(isolate: Nullable<TIsolate>): number {\n    if (isNullish(isolate)) {\n      return 0;\n    }\n    return isolate.children?.length ?? 0;\n  }\n\n  static canReorder<I extends TIsolate>(isolate: Nullable<I>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n\n    return IsolateInspector.allowsReorder(isolate.parent);\n  }\n\n  static allowsReorder<I extends Record<any, any>>(\n    isolate: Nullable<I>\n  ): boolean {\n    return isolate?.allowReorder === true;\n  }\n\n  static usesKey(isolate: Nullable<TIsolate>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n    return isNotNullish(isolate.key);\n  }\n\n  static getChildByKey(\n    isolate: Nullable<TIsolate>,\n    key: string\n  ): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.keys?.[key] ?? null;\n  }\n}\n","import { Nullable, invariant, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateMutator {\n  static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate {\n    isolate.parent = parent;\n    return isolate;\n  }\n\n  static saveOutput(isolate: TIsolate, output: any): TIsolate {\n    isolate.output = output;\n    return isolate;\n  }\n\n  static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate {\n    isolate.key = key;\n    return isolate;\n  }\n\n  static addChild(isolate: TIsolate, child: TIsolate): void {\n    invariant(isolate);\n\n    isolate.children = isolate.children ?? [];\n\n    isolate.children.push(child);\n    IsolateMutator.setParent(child, isolate);\n  }\n\n  static removeChild(isolate: TIsolate, node: TIsolate): void {\n    isolate.children =\n      isolate.children?.filter(child => child !== node) ?? null;\n  }\n\n  static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void {\n    invariant(isolate);\n\n    isolate.keys = isolate.keys ?? {};\n\n    isolate.keys[key] = node;\n  }\n\n  static slice(isolate: TIsolate, at: number): void {\n    if (isNullish(isolate.children)) {\n      return;\n    }\n    isolate.children.length = at;\n  }\n\n  static setData(isolate: TIsolate, data: any): void {\n    isolate.data = data;\n  }\n\n  static abort(isolate: TIsolate, reason?: string): void {\n    if (isNullish(isolate.abortController)) {\n      return;\n    }\n    isolate.abortController.abort(reason);\n  }\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { createCascade } from 'context';\nimport {\n  invariant,\n  deferThrow,\n  isNullish,\n  assign,\n  TinyState,\n  text,\n  optionalFunctionValue,\n  tinyState,\n  BusType,\n  bus,\n  Nullable,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { IRecociler } from 'Reconciler';\n\ntype CTXType = StateRefType & {\n  historyNode: Nullable<TIsolate>;\n  runtimeNode: Nullable<TIsolate>;\n  runtimeRoot: Nullable<TIsolate>;\n  stateRef: StateRefType;\n};\n\nexport type StateRefType = {\n  Bus: BusType;\n  appData: Record<string, any>;\n  historyRoot: TinyState<Nullable<TIsolate>>;\n  Reconciler: IRecociler;\n};\n\nconst PersistedContext = createCascade<CTXType>((stateRef, parentContext) => {\n  if (parentContext) {\n    return null;\n  }\n\n  invariant(stateRef.historyRoot);\n\n  const [historyRootNode] = stateRef.historyRoot();\n\n  const ctxRef = {} as CTXType;\n\n  assign(ctxRef, {\n    historyNode: historyRootNode,\n    runtimeNode: null,\n    runtimeRoot: null,\n    stateRef,\n  });\n\n  return ctxRef;\n});\n\nexport const Run = PersistedContext.run;\n\nexport const RuntimeApi = {\n  Run,\n  addNodeToHistory,\n  createRef,\n  persist,\n  reset,\n  useAvailableRoot,\n  useCurrentCursor,\n  useHistoryRoot,\n  useLoadRootNode,\n  useXAppData,\n};\n\nexport function useXAppData<T = object>() {\n  return useX().stateRef.appData as T;\n}\n\nexport function createRef(\n  Reconciler: IRecociler,\n  setter: DynamicValue<Record<string, any>>\n): StateRefType {\n  return Object.freeze({\n    Bus: bus.createBus(),\n    Reconciler,\n    appData: optionalFunctionValue(setter),\n    historyRoot: tinyState.createTinyState<Nullable<TIsolate>>(null),\n  });\n}\n\nexport function useReconciler() {\n  return useX().stateRef.Reconciler;\n}\n\nexport function persist<T extends (...args: any[]) => any>(cb: T): T {\n  const prev = PersistedContext.useX();\n\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    const ctxToUse = PersistedContext.use() ?? prev;\n    return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));\n  }) as T;\n}\nexport function useX<T = object>(): CTXType & T {\n  return PersistedContext.useX() as CTXType & T;\n}\n\nexport function useHistoryRoot() {\n  return useX().stateRef.historyRoot();\n}\nexport function useHistoryIsolate() {\n  return useX().historyNode;\n}\n\n/**\n * Returns the history isolate at the current position.\n * If there is a parent isolate, it returns the history node from the parent's children.\n * Otherwise, it returns the history node.\n * @returns {Nullable<TIsolate>} The history isolate at the current position.\n */\nexport function useHistoryIsolateAtCurrentPosition() {\n  const parent = useIsolate();\n\n  // This is most likely the historic counterpart of the parent node\n\n  const historyNode = useHistoryIsolate();\n\n  if (parent) {\n    // If we have a parent, we need to get the history node from the parent's children\n    // We take the history node from the cursor of the active node's children\n    return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));\n  }\n\n  return historyNode;\n}\n\nexport function addNodeToHistory(node: TIsolate): void {\n  const parent = useIsolate();\n  if (parent) {\n    useSetNextIsolateChild(node);\n  } else {\n    useSetHistory(node);\n  }\n\n  IsolateMutator.setParent(node, parent);\n}\n\nexport function useSetHistory(history: TIsolate) {\n  const [, setHistoryRoot] = useHistoryRoot();\n  setHistoryRoot(history);\n}\nexport function useHistoryKey(key?: Nullable<string>): Nullable<TIsolate> {\n  if (isNullish(key)) {\n    return null;\n  }\n\n  const historyNode = useX().historyNode;\n\n  return IsolateInspector.getChildByKey(historyNode, key);\n}\n\nexport function useIsolate() {\n  return useX().runtimeNode ?? null;\n}\nexport function useCurrentCursor() {\n  const isolate = useIsolate();\n  return isolate ? IsolateInspector.cursor(isolate) : 0;\n}\nexport function useRuntimeRoot() {\n  return useX().runtimeRoot;\n}\nexport function useSetNextIsolateChild(child: TIsolate): void {\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  IsolateMutator.addChild(currentIsolate, child);\n}\nexport function useSetIsolateKey(key: Nullable<string>, node: TIsolate): void {\n  if (!key) {\n    return;\n  }\n\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  if (isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {\n    IsolateMutator.addChildKey(currentIsolate, key, node);\n\n    return;\n  }\n\n  deferThrow(text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));\n}\nexport function useAvailableRoot<I extends TIsolate = TIsolate>(): I {\n  const root = useRuntimeRoot();\n\n  if (root) {\n    return root as I;\n  }\n\n  const [historyRoot] = useHistoryRoot();\n\n  return historyRoot as I;\n}\n\nexport function reset() {\n  const [, , resetHistoryRoot] = useHistoryRoot();\n\n  resetHistoryRoot();\n}\n\nexport function useLoadRootNode(root: TIsolate): void {\n  useSetHistory(root);\n}\n","import { isNullish } from 'vest-utils';\n\nimport { persist, useX } from 'VestRuntime';\n\nexport function useBus() {\n  return useX().stateRef.Bus;\n}\n\n/*\n  Returns an emitter, but it also has a shortcut for emitting an event immediately\n  by passing an event name.\n*/\nexport function useEmit(event?: string, data?: any) {\n  const emit = useBus().emit;\n\n  if (!isNullish(event)) {\n    emit(event, data);\n  }\n\n  return persist(emit);\n}\n\nexport function usePrepareEmitter<T = void>(event: string): (arg: T) => void {\n  const emit = useEmit();\n\n  return (arg: T) => emit(event, arg);\n}\n","export enum IsolateKeys {\n  Type = '$type',\n  Keys = 'keys',\n  Key = 'key',\n  Parent = 'parent',\n  Data = 'data',\n  AllowReorder = 'allowReorder',\n  Status = 'status',\n  AbortController = 'abortController',\n  Children = 'children',\n}\n\nexport const ExcludedFromDump = new Set([\n  IsolateKeys.AbortController,\n  IsolateKeys.Parent,\n  IsolateKeys.Keys,\n]);\n","import { Maybe } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateKeys } from 'IsolateKeys';\n\nexport function isIsolateType<I extends TIsolate>(\n  node: Maybe<TIsolate>,\n  type: string\n): node is I {\n  return node?.[IsolateKeys.Type] === type;\n}\n\nexport function isSameIsolateType<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return isIsolateType(a, b[IsolateKeys.Type]);\n}\n\nexport function isSameIsolateIdentity<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { type TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { isSameIsolateType } from 'IsolateSelectors';\nimport * as VestRuntime from 'VestRuntime';\nimport {\n  Maybe,\n  Nullable,\n  invariant,\n  isNullish,\n  optionalFunctionValue,\n} from 'vest-utils';\n// import { isSameIsolateType } from 'IsolateSelectors';\n\n// I would rather not use `any` here, but instead use `Isolate`.\n// The problem is that it breaks the actual implementation of `Isolate` in `IsolateTest`\n// As it is not properly extending `Isolate`.\nexport interface IRecociler<I = any> {\n  (currentNode: I, historyNode: I): Nullable<I>;\n}\n\nfunction BaseReconciler(\n  currentNode: TIsolate,\n  historyNode: TIsolate,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return currentNode;\n  }\n  return currentNode;\n}\n\nexport class Reconciler {\n  /**\n   * Reconciles the current isolate with the history isolate.\n   * If the current isolate is of a different type than the history isolate,\n   * the current isolate is returned.\n   * Otherwise, the reconciler function is called to determine the next isolate.\n   * If the reconciler function returns null or undefined, the base reconciler is used.\n   * If no history isolate exists, the current isolate is returned.\n   * @param node The current isolate to reconcile.\n   * @returns The next isolate after reconciliation.\n   */\n  static reconcile(node: TIsolate): TIsolate {\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const nextNodeResult = pickNextNode(node, localHistoryNode);\n\n    invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);\n\n    return nextNodeResult;\n  }\n\n  static dropNextNodesOnReorder<I extends TIsolate>(\n    reorderLogic: (newNode: I, prevNode: Maybe<TIsolate>) => boolean,\n    newNode: I,\n    prevNode: Maybe<TIsolate>,\n  ): boolean {\n    const didReorder = reorderLogic(newNode, prevNode);\n\n    if (didReorder) {\n      removeAllNextNodesInIsolate();\n    }\n\n    return didReorder;\n  }\n\n  static handleIsolateNodeWithKey<I extends TIsolate>(\n    node: TIsolate,\n\n    // The revoke function allows the caller to revoke the previous node\n    revoke: ((node: I) => boolean) | false,\n  ): TIsolate {\n    invariant(IsolateInspector.usesKey(node));\n\n    const prevNodeByKey = VestRuntime.useHistoryKey(node.key);\n    let nextNode = node;\n\n    if (\n      !isNullish(prevNodeByKey) &&\n      !optionalFunctionValue(revoke, prevNodeByKey)\n    ) {\n      nextNode = prevNodeByKey;\n    }\n\n    VestRuntime.useSetIsolateKey(node.key, nextNode);\n\n    return nextNode;\n  }\n}\n\nfunction pickNextNode(\n  currentNode: TIsolate,\n  historyNode: Nullable<TIsolate>,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return handleNoHistoryNode(currentNode);\n  }\n\n  if (!isSameIsolateType(currentNode, historyNode)) {\n    return currentNode;\n  }\n\n  const reconciler = VestRuntime.useReconciler();\n\n  return (\n    reconciler(currentNode, historyNode) ??\n    BaseReconciler(currentNode, historyNode)\n  );\n}\n\nfunction handleNoHistoryNode<I extends TIsolate>(newNode: I): I {\n  if (IsolateInspector.usesKey(newNode)) {\n    return Reconciler.handleIsolateNodeWithKey(newNode, false) as I;\n  }\n\n  return newNode;\n}\n\nfunction removeAllNextNodesInIsolate() {\n  const currentNode = VestRuntime.useIsolate();\n  const historyNode = VestRuntime.useHistoryIsolate();\n\n  if (!historyNode || !currentNode) {\n    // This is probably unreachable, but TS is not convinced.\n    // Let's play it safe.\n    /* istanbul ignore next */\n    return;\n  }\n\n  IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));\n}\n","import { CB, Maybe, Nullable, isNotNullish, isPromise } from 'vest-utils';\n\nimport { useEmit } from 'Bus';\nimport { IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { Reconciler } from 'Reconciler';\nimport { RuntimeEvents } from 'RuntimeEvents';\nimport * as VestRuntime from 'VestRuntime';\n\nexport type IsolateKey = Nullable<string>;\n\nexport type TIsolate<P extends IsolatePayload = IsolatePayload> = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Parent]: Nullable<TIsolate>;\n  [IsolateKeys.Type]: string;\n  [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;\n  [IsolateKeys.Data]: DataOnly<P>;\n  [IsolateKeys.Status]?: string;\n  [IsolateKeys.AbortController]: AbortController;\n  children: Nullable<TIsolate[]>;\n  key: IsolateKey;\n  output: any;\n} & UsedFeaturesOnly<P>;\n\ntype DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;\ntype UsedFeaturesOnly<P extends IsolatePayload> = Pick<\n  P,\n  keyof IsolateFeatures\n>;\n\nexport class Isolate {\n  static create<Payload extends IsolatePayload>(\n    type: string,\n    callback: CB,\n    payload: Maybe<Payload> = undefined,\n    key?: IsolateKey,\n  ): TIsolate<Payload> {\n    const parent = VestRuntime.useIsolate();\n\n    const newCreatedNode = IsolateMutator.setParent(\n      baseIsolate(type, payload, key),\n      parent,\n    );\n\n    const nextIsolateChild = Reconciler.reconcile(newCreatedNode);\n\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const shouldRunNew = Object.is(nextIsolateChild, newCreatedNode);\n\n    VestRuntime.addNodeToHistory(nextIsolateChild);\n\n    const output = shouldRunNew\n      ? useRunAsNew(localHistoryNode, newCreatedNode, callback)\n      : nextIsolateChild.output;\n\n    IsolateMutator.saveOutput(nextIsolateChild, output);\n\n    return nextIsolateChild as TIsolate<Payload>;\n  }\n\n  static isIsolate(node: any): node is TIsolate {\n    return isNotNullish(node) && node[IsolateKeys.Type];\n  }\n}\n\n/**\n * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.\n * Runs the callback function and returns its output.\n * @param localHistoryNode The local history node.\n * @param current The current isolate.\n * @param callback The callback function to execute.\n * @returns The output of the callback function.\n */\nfunction useRunAsNew<Callback extends CB = CB>(\n  localHistoryNode: Nullable<TIsolate>,\n  current: TIsolate,\n  callback: CB,\n): ReturnType<Callback> {\n  const runtimeRoot = VestRuntime.useRuntimeRoot();\n  const emit = useEmit();\n\n  // We're creating a new child isolate context where the local history node\n  // is the current history node, thus advancing the history cursor.\n  const output = VestRuntime.Run(\n    {\n      historyNode: localHistoryNode,\n      runtimeNode: current,\n      ...(!runtimeRoot && { runtimeRoot: current }),\n    },\n    () => {\n      emit(RuntimeEvents.ISOLATE_ENTER, current);\n      const output = callback(current);\n\n      if (isPromise(output)) {\n        emit(RuntimeEvents.ISOLATE_PENDING, current);\n        output.then(iso => {\n          if (Isolate.isIsolate(iso)) {\n            IsolateMutator.addChild(current, iso);\n          }\n\n          emit(RuntimeEvents.ISOLATE_DONE, current);\n        });\n      } else {\n        emit(RuntimeEvents.ISOLATE_DONE, current);\n      }\n\n      return output;\n    },\n  );\n\n  current.output = output;\n  return output;\n}\n\nfunction baseIsolate(\n  type: string,\n  payload: Maybe<IsolatePayload> = undefined,\n  key: IsolateKey = null,\n): TIsolate {\n  const { allowReorder, status, ...data } = payload ?? {};\n  return {\n    [IsolateKeys.AllowReorder]: allowReorder,\n    [IsolateKeys.AbortController]: new AbortController(),\n    [IsolateKeys.Keys]: null,\n    [IsolateKeys.Parent]: null,\n    [IsolateKeys.Type]: type,\n    [IsolateKeys.Data]: data as IsolateData,\n    ...(status && { [IsolateKeys.Status]: status }),\n    children: null,\n    key,\n    output: null,\n  };\n}\n\ntype IsolateData = Record<string, any>;\ntype IsolatePayload = IsolateData & IsolateFeatures;\ntype IsolateFeatures = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Status]?: string;\n};\n","import { CB, Nullable, isNullish, optionalFunctionValue } from 'vest-utils';\n\nimport { type TIsolate } from 'Isolate';\nimport { IsolateMutator } from 'IsolateMutator';\n\ntype VisitOnlyPredicate = (isolate: TIsolate) => boolean;\n\n// eslint-disable-next-line\nexport function walk(\n  startNode: TIsolate,\n  callback: (isolate: TIsolate, breakout: CB<void>) => void,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  // If the startNode has no children, there is nothing to walk.\n  if (isNullish(startNode.children)) {\n    return;\n  }\n\n  let broke = false;\n\n  // For each child Isolate object, call the callback function.\n  for (const isolate of startNode.children) {\n    if (broke) {\n      return;\n    }\n\n    // If visitOnly is not provided or the predicate is satisfied, call the callback function.\n    if (isNullish(visitOnly) || optionalFunctionValue(visitOnly, isolate)) {\n      callback(isolate, breakout);\n    }\n\n    // If the breakout function has been called, stop the walk.\n    if (broke) {\n      return;\n    }\n\n    // Recursively walk through the child Isolate object.\n    walk(\n      isolate,\n      (child, innerBreakout) => {\n        callback(child, () => {\n          innerBreakout();\n          breakout();\n        });\n      },\n      visitOnly,\n    );\n  }\n\n  function breakout() {\n    broke = true;\n  }\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function some(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = false;\n\n  // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        hasMatch = true;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function has(startNode: TIsolate, match: VisitOnlyPredicate): boolean {\n  return some(startNode, () => true, match);\n}\n\n// traverses up to a parent node that satisfies the predicate\n// and returns the first direct descendant that satisfies the predicate\nexport function findClosest<I extends TIsolate = TIsolate>(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<I> {\n  let found: Nullable<TIsolate> = null;\n  let current: Nullable<TIsolate> = startNode;\n\n  while (current) {\n    found = current.children?.find(predicate) ?? null;\n\n    if (found) {\n      break;\n    }\n\n    current = current.parent;\n  }\n\n  return found as Nullable<I>;\n}\n\n// This function returns the first Isolate object in the tree that satisfies the given predicate function.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function find(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): Nullable<TIsolate> {\n  let found = null;\n\n  // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        found = node;\n      }\n    },\n    visitOnly,\n  );\n\n  return found;\n}\n\n// This function returns true if the given predicate function returns true for every Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function every(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = true;\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (!predicate(node)) {\n        breakout();\n        hasMatch = false;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function removes all Isolate objects in the tree that\n// satisfy the given predicate function and have a parent.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function pluck(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  walk(\n    startNode,\n    node => {\n      if (predicate(node) && node.parent) {\n        IsolateMutator.removeChild(node.parent, node);\n      }\n    },\n    visitOnly,\n  );\n}\n\n// Returns the closest ancestor Isolate object of the given\n//startNode that satisfies the given predicate function.\nexport function closest(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<TIsolate> {\n  let current: Nullable<TIsolate> = startNode;\n  do {\n    if (predicate(current)) {\n      return current;\n    }\n    current = current.parent;\n  } while (current);\n  return null;\n}\n\n// This function returns true if the closest ancestor Isolates of the\n// given startNode that satisfies the given predicate function exists.\nexport function closestExists(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): boolean {\n  return !!closest(startNode, predicate);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Nullable,\n  hasOwnProperty,\n  invariant,\n  isNullish,\n  isStringValue,\n  text,\n} from 'vest-utils';\nimport { expandObject, minifyObject } from 'vest-utils/minifyObject';\n\nimport { TIsolate } from 'Isolate';\nimport { ExcludedFromDump, IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\n\nexport class IsolateSerializer {\n  // eslint-disable-next-line max-statements, complexity, max-lines-per-function\n  static deserialize(node: Record<string, any> | TIsolate | string): TIsolate {\n    // Validate the root object\n    const root = (\n      isStringValue(node) ? JSON.parse(node) : ({ ...node } as TIsolate)\n    ) as [any, any];\n\n    const expanded = expandObject(...root);\n\n    IsolateSerializer.validateIsolate(expanded);\n\n    const queue = [expanded];\n\n    // Iterate over the queue until it's empty\n    while (queue.length) {\n      // Get the next item from the queue\n      const current = queue.shift();\n\n      if (!current) {\n        continue;\n      }\n\n      const children = current.children;\n\n      // If there are no children, nothing to do.\n      if (!children) {\n        continue;\n      }\n\n      // Copy the children and set their parent to the current node.\n      current.children = children.map(child => {\n        const nextChild = { ...child };\n\n        IsolateMutator.setParent(nextChild, current);\n        queue.push(nextChild);\n\n        // If the child has a key, add it to the parent's keys.\n        const key = nextChild.key;\n\n        if (key) {\n          current.keys = current.keys ?? {};\n          current.keys[key] = nextChild;\n        }\n\n        return nextChild;\n      });\n    }\n\n    return expanded;\n  }\n\n  static serialize(isolate: Nullable<TIsolate>): string {\n    if (isNullish(isolate)) {\n      return '';\n    }\n\n    const minified = minifyObject(isolate, ExcludedFromDump);\n\n    return JSON.stringify(minified);\n  }\n\n  static validateIsolate(\n    node: Record<string, any> | TIsolate,\n  ): asserts node is TIsolate {\n    invariant(\n      hasOwnProperty(node, IsolateKeys.Type),\n      text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE),\n    );\n  }\n}\n"],"names":["isNullish","isNotNullish","invariant","createCascade","assign","bus","optionalFunctionValue","tinyState","deferThrow","text","VestRuntime.useHistoryIsolateAtCurrentPosition","VestRuntime.useHistoryKey","VestRuntime.useSetIsolateKey","VestRuntime.useReconciler","VestRuntime.useIsolate","VestRuntime.useHistoryIsolate","VestRuntime.addNodeToHistory","VestRuntime.useRuntimeRoot","VestRuntime.Run","isPromise","isStringValue","expandObject","minifyObject","hasOwnProperty"],"mappings":"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"}