'use strict';

var vestUtils = require('vest-utils');
var minifyObject = require('vest-utils/minifyObject');

var ErrorStrings;
(function (ErrorStrings) {
    ErrorStrings["NO_ACTIVE_ISOLATE"] = "Not within an active isolate";
    ErrorStrings["UNABLE_TO_PICK_NEXT_ISOLATE"] = "Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.";
    ErrorStrings["ENCOUNTERED_THE_SAME_KEY_TWICE"] = "Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.";
    ErrorStrings["INVALID_ISOLATE_CANNOT_PARSE"] = "Invalid isolate was passed to IsolateSerializer. Cannot proceed.";
})(ErrorStrings || (ErrorStrings = {}));

var IsolateKeys;
(function (IsolateKeys) {
    IsolateKeys["Type"] = "$type";
    IsolateKeys["Keys"] = "keys";
    IsolateKeys["Key"] = "key";
    IsolateKeys["Parent"] = "parent";
    IsolateKeys["Data"] = "data";
    IsolateKeys["AllowReorder"] = "allowReorder";
    IsolateKeys["Status"] = "status";
    IsolateKeys["AbortController"] = "abortController";
    IsolateKeys["Children"] = "children";
})(IsolateKeys || (IsolateKeys = {}));
const ExcludedFromDump = new Set([
    IsolateKeys.AbortController,
    IsolateKeys.Parent,
    IsolateKeys.Keys,
]);

class IsolateMutator {
    static setParent(isolate, parent) {
        isolate.parent = parent;
        return isolate;
    }
    static saveOutput(isolate, output) {
        isolate.output = output;
        return isolate;
    }
    static setKey(isolate, key) {
        isolate.key = key;
        return isolate;
    }
    static addChild(isolate, child) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.children = (_a = isolate.children) !== null && _a !== void 0 ? _a : [];
        isolate.children.push(child);
        IsolateMutator.setParent(child, isolate);
    }
    static removeChild(isolate, node) {
        var _a, _b;
        isolate.children =
            (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.filter(child => child !== node)) !== null && _b !== void 0 ? _b : null;
    }
    static addChildKey(isolate, key, node) {
        var _a;
        vestUtils.invariant(isolate);
        isolate.keys = (_a = isolate.keys) !== null && _a !== void 0 ? _a : {};
        isolate.keys[key] = node;
    }
    static slice(isolate, at) {
        if (vestUtils.isNullish(isolate.children)) {
            return;
        }
        isolate.children.length = at;
    }
    static setData(isolate, data) {
        isolate.data = data;
    }
    static abort(isolate, reason) {
        if (vestUtils.isNullish(isolate.abortController)) {
            return;
        }
        isolate.abortController.abort(reason);
    }
}

class IsolateSerializer {
    // eslint-disable-next-line max-statements, complexity, max-lines-per-function
    static deserialize(node) {
        // Validate the root object
        const root = (vestUtils.isStringValue(node) ? JSON.parse(node) : Object.assign({}, node));
        const expanded = minifyObject.expandObject(...root);
        IsolateSerializer.validateIsolate(expanded);
        const queue = [expanded];
        // Iterate over the queue until it's empty
        while (queue.length) {
            // Get the next item from the queue
            const current = queue.shift();
            if (!current) {
                continue;
            }
            const children = current.children;
            // If there are no children, nothing to do.
            if (!children) {
                continue;
            }
            // Copy the children and set their parent to the current node.
            current.children = children.map(child => {
                var _a;
                const nextChild = Object.assign({}, child);
                IsolateMutator.setParent(nextChild, current);
                queue.push(nextChild);
                // If the child has a key, add it to the parent's keys.
                const key = nextChild.key;
                if (key) {
                    current.keys = (_a = current.keys) !== null && _a !== void 0 ? _a : {};
                    current.keys[key] = nextChild;
                }
                return nextChild;
            });
        }
        return expanded;
    }
    static serialize(isolate) {
        if (vestUtils.isNullish(isolate)) {
            return '';
        }
        const minified = minifyObject.minifyObject(isolate, ExcludedFromDump);
        return JSON.stringify(minified);
    }
    static validateIsolate(node) {
        vestUtils.invariant(vestUtils.hasOwnProperty(node, IsolateKeys.Type), vestUtils.text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE));
    }
}

exports.IsolateSerializer = IsolateSerializer;
//# sourceMappingURL=IsolateSerializer.development.js.map
