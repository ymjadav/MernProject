{"version":3,"file":"vestjs-runtime.production.js","sources":["../../src/RuntimeEvents.ts","../../src/errors/ErrorStrings.ts","../../src/Isolate/IsolateInspector.ts","../../src/Isolate/IsolateMutator.ts","../../src/VestRuntime.ts","../../src/Bus.ts","../../src/Isolate/IsolateKeys.ts","../../src/Isolate/IsolateSelectors.ts","../../src/Reconciler.ts","../../src/Isolate/Isolate.ts","../../src/IsolateWalker.ts","../../src/exports/IsolateSerializer.ts"],"sourcesContent":["export const RuntimeEvents = {\n  ISOLATE_ENTER: 'ISOLATE_ENTER',\n  ISOLATE_PENDING: 'ISOLATE_PENDING',\n  ISOLATE_DONE: 'ISOLATE_DONE',\n};\n","export enum ErrorStrings {\n  NO_ACTIVE_ISOLATE = 'Not within an active isolate',\n  UNABLE_TO_PICK_NEXT_ISOLATE = 'Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.',\n  ENCOUNTERED_THE_SAME_KEY_TWICE = `Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.`,\n  INVALID_ISOLATE_CANNOT_PARSE = `Invalid isolate was passed to IsolateSerializer. Cannot proceed.`,\n}\n","import { Nullable, isNotNullish, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateInspector {\n  static at(isolate: Nullable<TIsolate>, at: number): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.children?.[at] ?? null;\n  }\n\n  static cursor(isolate: Nullable<TIsolate>): number {\n    if (isNullish(isolate)) {\n      return 0;\n    }\n    return isolate.children?.length ?? 0;\n  }\n\n  static canReorder<I extends TIsolate>(isolate: Nullable<I>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n\n    return IsolateInspector.allowsReorder(isolate.parent);\n  }\n\n  static allowsReorder<I extends Record<any, any>>(\n    isolate: Nullable<I>\n  ): boolean {\n    return isolate?.allowReorder === true;\n  }\n\n  static usesKey(isolate: Nullable<TIsolate>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n    return isNotNullish(isolate.key);\n  }\n\n  static getChildByKey(\n    isolate: Nullable<TIsolate>,\n    key: string\n  ): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.keys?.[key] ?? null;\n  }\n}\n","import { Nullable, invariant, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateMutator {\n  static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate {\n    isolate.parent = parent;\n    return isolate;\n  }\n\n  static saveOutput(isolate: TIsolate, output: any): TIsolate {\n    isolate.output = output;\n    return isolate;\n  }\n\n  static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate {\n    isolate.key = key;\n    return isolate;\n  }\n\n  static addChild(isolate: TIsolate, child: TIsolate): void {\n    invariant(isolate);\n\n    isolate.children = isolate.children ?? [];\n\n    isolate.children.push(child);\n    IsolateMutator.setParent(child, isolate);\n  }\n\n  static removeChild(isolate: TIsolate, node: TIsolate): void {\n    isolate.children =\n      isolate.children?.filter(child => child !== node) ?? null;\n  }\n\n  static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void {\n    invariant(isolate);\n\n    isolate.keys = isolate.keys ?? {};\n\n    isolate.keys[key] = node;\n  }\n\n  static slice(isolate: TIsolate, at: number): void {\n    if (isNullish(isolate.children)) {\n      return;\n    }\n    isolate.children.length = at;\n  }\n\n  static setData(isolate: TIsolate, data: any): void {\n    isolate.data = data;\n  }\n\n  static abort(isolate: TIsolate, reason?: string): void {\n    if (isNullish(isolate.abortController)) {\n      return;\n    }\n    isolate.abortController.abort(reason);\n  }\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { createCascade } from 'context';\nimport {\n  invariant,\n  deferThrow,\n  isNullish,\n  assign,\n  TinyState,\n  text,\n  optionalFunctionValue,\n  tinyState,\n  BusType,\n  bus,\n  Nullable,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { IRecociler } from 'Reconciler';\n\ntype CTXType = StateRefType & {\n  historyNode: Nullable<TIsolate>;\n  runtimeNode: Nullable<TIsolate>;\n  runtimeRoot: Nullable<TIsolate>;\n  stateRef: StateRefType;\n};\n\nexport type StateRefType = {\n  Bus: BusType;\n  appData: Record<string, any>;\n  historyRoot: TinyState<Nullable<TIsolate>>;\n  Reconciler: IRecociler;\n};\n\nconst PersistedContext = createCascade<CTXType>((stateRef, parentContext) => {\n  if (parentContext) {\n    return null;\n  }\n\n  invariant(stateRef.historyRoot);\n\n  const [historyRootNode] = stateRef.historyRoot();\n\n  const ctxRef = {} as CTXType;\n\n  assign(ctxRef, {\n    historyNode: historyRootNode,\n    runtimeNode: null,\n    runtimeRoot: null,\n    stateRef,\n  });\n\n  return ctxRef;\n});\n\nexport const Run = PersistedContext.run;\n\nexport const RuntimeApi = {\n  Run,\n  addNodeToHistory,\n  createRef,\n  persist,\n  reset,\n  useAvailableRoot,\n  useCurrentCursor,\n  useHistoryRoot,\n  useLoadRootNode,\n  useXAppData,\n};\n\nexport function useXAppData<T = object>() {\n  return useX().stateRef.appData as T;\n}\n\nexport function createRef(\n  Reconciler: IRecociler,\n  setter: DynamicValue<Record<string, any>>\n): StateRefType {\n  return Object.freeze({\n    Bus: bus.createBus(),\n    Reconciler,\n    appData: optionalFunctionValue(setter),\n    historyRoot: tinyState.createTinyState<Nullable<TIsolate>>(null),\n  });\n}\n\nexport function useReconciler() {\n  return useX().stateRef.Reconciler;\n}\n\nexport function persist<T extends (...args: any[]) => any>(cb: T): T {\n  const prev = PersistedContext.useX();\n\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    const ctxToUse = PersistedContext.use() ?? prev;\n    return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));\n  }) as T;\n}\nexport function useX<T = object>(): CTXType & T {\n  return PersistedContext.useX() as CTXType & T;\n}\n\nexport function useHistoryRoot() {\n  return useX().stateRef.historyRoot();\n}\nexport function useHistoryIsolate() {\n  return useX().historyNode;\n}\n\n/**\n * Returns the history isolate at the current position.\n * If there is a parent isolate, it returns the history node from the parent's children.\n * Otherwise, it returns the history node.\n * @returns {Nullable<TIsolate>} The history isolate at the current position.\n */\nexport function useHistoryIsolateAtCurrentPosition() {\n  const parent = useIsolate();\n\n  // This is most likely the historic counterpart of the parent node\n\n  const historyNode = useHistoryIsolate();\n\n  if (parent) {\n    // If we have a parent, we need to get the history node from the parent's children\n    // We take the history node from the cursor of the active node's children\n    return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));\n  }\n\n  return historyNode;\n}\n\nexport function addNodeToHistory(node: TIsolate): void {\n  const parent = useIsolate();\n  if (parent) {\n    useSetNextIsolateChild(node);\n  } else {\n    useSetHistory(node);\n  }\n\n  IsolateMutator.setParent(node, parent);\n}\n\nexport function useSetHistory(history: TIsolate) {\n  const [, setHistoryRoot] = useHistoryRoot();\n  setHistoryRoot(history);\n}\nexport function useHistoryKey(key?: Nullable<string>): Nullable<TIsolate> {\n  if (isNullish(key)) {\n    return null;\n  }\n\n  const historyNode = useX().historyNode;\n\n  return IsolateInspector.getChildByKey(historyNode, key);\n}\n\nexport function useIsolate() {\n  return useX().runtimeNode ?? null;\n}\nexport function useCurrentCursor() {\n  const isolate = useIsolate();\n  return isolate ? IsolateInspector.cursor(isolate) : 0;\n}\nexport function useRuntimeRoot() {\n  return useX().runtimeRoot;\n}\nexport function useSetNextIsolateChild(child: TIsolate): void {\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  IsolateMutator.addChild(currentIsolate, child);\n}\nexport function useSetIsolateKey(key: Nullable<string>, node: TIsolate): void {\n  if (!key) {\n    return;\n  }\n\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  if (isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {\n    IsolateMutator.addChildKey(currentIsolate, key, node);\n\n    return;\n  }\n\n  deferThrow(text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));\n}\nexport function useAvailableRoot<I extends TIsolate = TIsolate>(): I {\n  const root = useRuntimeRoot();\n\n  if (root) {\n    return root as I;\n  }\n\n  const [historyRoot] = useHistoryRoot();\n\n  return historyRoot as I;\n}\n\nexport function reset() {\n  const [, , resetHistoryRoot] = useHistoryRoot();\n\n  resetHistoryRoot();\n}\n\nexport function useLoadRootNode(root: TIsolate): void {\n  useSetHistory(root);\n}\n","import { isNullish } from 'vest-utils';\n\nimport { persist, useX } from 'VestRuntime';\n\nexport function useBus() {\n  return useX().stateRef.Bus;\n}\n\n/*\n  Returns an emitter, but it also has a shortcut for emitting an event immediately\n  by passing an event name.\n*/\nexport function useEmit(event?: string, data?: any) {\n  const emit = useBus().emit;\n\n  if (!isNullish(event)) {\n    emit(event, data);\n  }\n\n  return persist(emit);\n}\n\nexport function usePrepareEmitter<T = void>(event: string): (arg: T) => void {\n  const emit = useEmit();\n\n  return (arg: T) => emit(event, arg);\n}\n","export enum IsolateKeys {\n  Type = '$type',\n  Keys = 'keys',\n  Key = 'key',\n  Parent = 'parent',\n  Data = 'data',\n  AllowReorder = 'allowReorder',\n  Status = 'status',\n  AbortController = 'abortController',\n  Children = 'children',\n}\n\nexport const ExcludedFromDump = new Set([\n  IsolateKeys.AbortController,\n  IsolateKeys.Parent,\n  IsolateKeys.Keys,\n]);\n","import { Maybe } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateKeys } from 'IsolateKeys';\n\nexport function isIsolateType<I extends TIsolate>(\n  node: Maybe<TIsolate>,\n  type: string\n): node is I {\n  return node?.[IsolateKeys.Type] === type;\n}\n\nexport function isSameIsolateType<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return isIsolateType(a, b[IsolateKeys.Type]);\n}\n\nexport function isSameIsolateIdentity<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { type TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { isSameIsolateType } from 'IsolateSelectors';\nimport * as VestRuntime from 'VestRuntime';\nimport {\n  Maybe,\n  Nullable,\n  invariant,\n  isNullish,\n  optionalFunctionValue,\n} from 'vest-utils';\n// import { isSameIsolateType } from 'IsolateSelectors';\n\n// I would rather not use `any` here, but instead use `Isolate`.\n// The problem is that it breaks the actual implementation of `Isolate` in `IsolateTest`\n// As it is not properly extending `Isolate`.\nexport interface IRecociler<I = any> {\n  (currentNode: I, historyNode: I): Nullable<I>;\n}\n\nfunction BaseReconciler(\n  currentNode: TIsolate,\n  historyNode: TIsolate,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return currentNode;\n  }\n  return currentNode;\n}\n\nexport class Reconciler {\n  /**\n   * Reconciles the current isolate with the history isolate.\n   * If the current isolate is of a different type than the history isolate,\n   * the current isolate is returned.\n   * Otherwise, the reconciler function is called to determine the next isolate.\n   * If the reconciler function returns null or undefined, the base reconciler is used.\n   * If no history isolate exists, the current isolate is returned.\n   * @param node The current isolate to reconcile.\n   * @returns The next isolate after reconciliation.\n   */\n  static reconcile(node: TIsolate): TIsolate {\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const nextNodeResult = pickNextNode(node, localHistoryNode);\n\n    invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);\n\n    return nextNodeResult;\n  }\n\n  static dropNextNodesOnReorder<I extends TIsolate>(\n    reorderLogic: (newNode: I, prevNode: Maybe<TIsolate>) => boolean,\n    newNode: I,\n    prevNode: Maybe<TIsolate>,\n  ): boolean {\n    const didReorder = reorderLogic(newNode, prevNode);\n\n    if (didReorder) {\n      removeAllNextNodesInIsolate();\n    }\n\n    return didReorder;\n  }\n\n  static handleIsolateNodeWithKey<I extends TIsolate>(\n    node: TIsolate,\n\n    // The revoke function allows the caller to revoke the previous node\n    revoke: ((node: I) => boolean) | false,\n  ): TIsolate {\n    invariant(IsolateInspector.usesKey(node));\n\n    const prevNodeByKey = VestRuntime.useHistoryKey(node.key);\n    let nextNode = node;\n\n    if (\n      !isNullish(prevNodeByKey) &&\n      !optionalFunctionValue(revoke, prevNodeByKey)\n    ) {\n      nextNode = prevNodeByKey;\n    }\n\n    VestRuntime.useSetIsolateKey(node.key, nextNode);\n\n    return nextNode;\n  }\n}\n\nfunction pickNextNode(\n  currentNode: TIsolate,\n  historyNode: Nullable<TIsolate>,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return handleNoHistoryNode(currentNode);\n  }\n\n  if (!isSameIsolateType(currentNode, historyNode)) {\n    return currentNode;\n  }\n\n  const reconciler = VestRuntime.useReconciler();\n\n  return (\n    reconciler(currentNode, historyNode) ??\n    BaseReconciler(currentNode, historyNode)\n  );\n}\n\nfunction handleNoHistoryNode<I extends TIsolate>(newNode: I): I {\n  if (IsolateInspector.usesKey(newNode)) {\n    return Reconciler.handleIsolateNodeWithKey(newNode, false) as I;\n  }\n\n  return newNode;\n}\n\nfunction removeAllNextNodesInIsolate() {\n  const currentNode = VestRuntime.useIsolate();\n  const historyNode = VestRuntime.useHistoryIsolate();\n\n  if (!historyNode || !currentNode) {\n    // This is probably unreachable, but TS is not convinced.\n    // Let's play it safe.\n    /* istanbul ignore next */\n    return;\n  }\n\n  IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));\n}\n","import { CB, Maybe, Nullable, isNotNullish, isPromise } from 'vest-utils';\n\nimport { useEmit } from 'Bus';\nimport { IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { Reconciler } from 'Reconciler';\nimport { RuntimeEvents } from 'RuntimeEvents';\nimport * as VestRuntime from 'VestRuntime';\n\nexport type IsolateKey = Nullable<string>;\n\nexport type TIsolate<P extends IsolatePayload = IsolatePayload> = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Parent]: Nullable<TIsolate>;\n  [IsolateKeys.Type]: string;\n  [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;\n  [IsolateKeys.Data]: DataOnly<P>;\n  [IsolateKeys.Status]?: string;\n  [IsolateKeys.AbortController]: AbortController;\n  children: Nullable<TIsolate[]>;\n  key: IsolateKey;\n  output: any;\n} & UsedFeaturesOnly<P>;\n\ntype DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;\ntype UsedFeaturesOnly<P extends IsolatePayload> = Pick<\n  P,\n  keyof IsolateFeatures\n>;\n\nexport class Isolate {\n  static create<Payload extends IsolatePayload>(\n    type: string,\n    callback: CB,\n    payload: Maybe<Payload> = undefined,\n    key?: IsolateKey,\n  ): TIsolate<Payload> {\n    const parent = VestRuntime.useIsolate();\n\n    const newCreatedNode = IsolateMutator.setParent(\n      baseIsolate(type, payload, key),\n      parent,\n    );\n\n    const nextIsolateChild = Reconciler.reconcile(newCreatedNode);\n\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const shouldRunNew = Object.is(nextIsolateChild, newCreatedNode);\n\n    VestRuntime.addNodeToHistory(nextIsolateChild);\n\n    const output = shouldRunNew\n      ? useRunAsNew(localHistoryNode, newCreatedNode, callback)\n      : nextIsolateChild.output;\n\n    IsolateMutator.saveOutput(nextIsolateChild, output);\n\n    return nextIsolateChild as TIsolate<Payload>;\n  }\n\n  static isIsolate(node: any): node is TIsolate {\n    return isNotNullish(node) && node[IsolateKeys.Type];\n  }\n}\n\n/**\n * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.\n * Runs the callback function and returns its output.\n * @param localHistoryNode The local history node.\n * @param current The current isolate.\n * @param callback The callback function to execute.\n * @returns The output of the callback function.\n */\nfunction useRunAsNew<Callback extends CB = CB>(\n  localHistoryNode: Nullable<TIsolate>,\n  current: TIsolate,\n  callback: CB,\n): ReturnType<Callback> {\n  const runtimeRoot = VestRuntime.useRuntimeRoot();\n  const emit = useEmit();\n\n  // We're creating a new child isolate context where the local history node\n  // is the current history node, thus advancing the history cursor.\n  const output = VestRuntime.Run(\n    {\n      historyNode: localHistoryNode,\n      runtimeNode: current,\n      ...(!runtimeRoot && { runtimeRoot: current }),\n    },\n    () => {\n      emit(RuntimeEvents.ISOLATE_ENTER, current);\n      const output = callback(current);\n\n      if (isPromise(output)) {\n        emit(RuntimeEvents.ISOLATE_PENDING, current);\n        output.then(iso => {\n          if (Isolate.isIsolate(iso)) {\n            IsolateMutator.addChild(current, iso);\n          }\n\n          emit(RuntimeEvents.ISOLATE_DONE, current);\n        });\n      } else {\n        emit(RuntimeEvents.ISOLATE_DONE, current);\n      }\n\n      return output;\n    },\n  );\n\n  current.output = output;\n  return output;\n}\n\nfunction baseIsolate(\n  type: string,\n  payload: Maybe<IsolatePayload> = undefined,\n  key: IsolateKey = null,\n): TIsolate {\n  const { allowReorder, status, ...data } = payload ?? {};\n  return {\n    [IsolateKeys.AllowReorder]: allowReorder,\n    [IsolateKeys.AbortController]: new AbortController(),\n    [IsolateKeys.Keys]: null,\n    [IsolateKeys.Parent]: null,\n    [IsolateKeys.Type]: type,\n    [IsolateKeys.Data]: data as IsolateData,\n    ...(status && { [IsolateKeys.Status]: status }),\n    children: null,\n    key,\n    output: null,\n  };\n}\n\ntype IsolateData = Record<string, any>;\ntype IsolatePayload = IsolateData & IsolateFeatures;\ntype IsolateFeatures = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Status]?: string;\n};\n","import { CB, Nullable, isNullish, optionalFunctionValue } from 'vest-utils';\n\nimport { type TIsolate } from 'Isolate';\nimport { IsolateMutator } from 'IsolateMutator';\n\ntype VisitOnlyPredicate = (isolate: TIsolate) => boolean;\n\n// eslint-disable-next-line\nexport function walk(\n  startNode: TIsolate,\n  callback: (isolate: TIsolate, breakout: CB<void>) => void,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  // If the startNode has no children, there is nothing to walk.\n  if (isNullish(startNode.children)) {\n    return;\n  }\n\n  let broke = false;\n\n  // For each child Isolate object, call the callback function.\n  for (const isolate of startNode.children) {\n    if (broke) {\n      return;\n    }\n\n    // If visitOnly is not provided or the predicate is satisfied, call the callback function.\n    if (isNullish(visitOnly) || optionalFunctionValue(visitOnly, isolate)) {\n      callback(isolate, breakout);\n    }\n\n    // If the breakout function has been called, stop the walk.\n    if (broke) {\n      return;\n    }\n\n    // Recursively walk through the child Isolate object.\n    walk(\n      isolate,\n      (child, innerBreakout) => {\n        callback(child, () => {\n          innerBreakout();\n          breakout();\n        });\n      },\n      visitOnly,\n    );\n  }\n\n  function breakout() {\n    broke = true;\n  }\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function some(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = false;\n\n  // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        hasMatch = true;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function has(startNode: TIsolate, match: VisitOnlyPredicate): boolean {\n  return some(startNode, () => true, match);\n}\n\n// traverses up to a parent node that satisfies the predicate\n// and returns the first direct descendant that satisfies the predicate\nexport function findClosest<I extends TIsolate = TIsolate>(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<I> {\n  let found: Nullable<TIsolate> = null;\n  let current: Nullable<TIsolate> = startNode;\n\n  while (current) {\n    found = current.children?.find(predicate) ?? null;\n\n    if (found) {\n      break;\n    }\n\n    current = current.parent;\n  }\n\n  return found as Nullable<I>;\n}\n\n// This function returns the first Isolate object in the tree that satisfies the given predicate function.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function find(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): Nullable<TIsolate> {\n  let found = null;\n\n  // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        found = node;\n      }\n    },\n    visitOnly,\n  );\n\n  return found;\n}\n\n// This function returns true if the given predicate function returns true for every Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function every(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = true;\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (!predicate(node)) {\n        breakout();\n        hasMatch = false;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function removes all Isolate objects in the tree that\n// satisfy the given predicate function and have a parent.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function pluck(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  walk(\n    startNode,\n    node => {\n      if (predicate(node) && node.parent) {\n        IsolateMutator.removeChild(node.parent, node);\n      }\n    },\n    visitOnly,\n  );\n}\n\n// Returns the closest ancestor Isolate object of the given\n//startNode that satisfies the given predicate function.\nexport function closest(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<TIsolate> {\n  let current: Nullable<TIsolate> = startNode;\n  do {\n    if (predicate(current)) {\n      return current;\n    }\n    current = current.parent;\n  } while (current);\n  return null;\n}\n\n// This function returns true if the closest ancestor Isolates of the\n// given startNode that satisfies the given predicate function exists.\nexport function closestExists(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): boolean {\n  return !!closest(startNode, predicate);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Nullable,\n  hasOwnProperty,\n  invariant,\n  isNullish,\n  isStringValue,\n  text,\n} from 'vest-utils';\nimport { expandObject, minifyObject } from 'vest-utils/minifyObject';\n\nimport { TIsolate } from 'Isolate';\nimport { ExcludedFromDump, IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\n\nexport class IsolateSerializer {\n  // eslint-disable-next-line max-statements, complexity, max-lines-per-function\n  static deserialize(node: Record<string, any> | TIsolate | string): TIsolate {\n    // Validate the root object\n    const root = (\n      isStringValue(node) ? JSON.parse(node) : ({ ...node } as TIsolate)\n    ) as [any, any];\n\n    const expanded = expandObject(...root);\n\n    IsolateSerializer.validateIsolate(expanded);\n\n    const queue = [expanded];\n\n    // Iterate over the queue until it's empty\n    while (queue.length) {\n      // Get the next item from the queue\n      const current = queue.shift();\n\n      if (!current) {\n        continue;\n      }\n\n      const children = current.children;\n\n      // If there are no children, nothing to do.\n      if (!children) {\n        continue;\n      }\n\n      // Copy the children and set their parent to the current node.\n      current.children = children.map(child => {\n        const nextChild = { ...child };\n\n        IsolateMutator.setParent(nextChild, current);\n        queue.push(nextChild);\n\n        // If the child has a key, add it to the parent's keys.\n        const key = nextChild.key;\n\n        if (key) {\n          current.keys = current.keys ?? {};\n          current.keys[key] = nextChild;\n        }\n\n        return nextChild;\n      });\n    }\n\n    return expanded;\n  }\n\n  static serialize(isolate: Nullable<TIsolate>): string {\n    if (isNullish(isolate)) {\n      return '';\n    }\n\n    const minified = minifyObject(isolate, ExcludedFromDump);\n\n    return JSON.stringify(minified);\n  }\n\n  static validateIsolate(\n    node: Record<string, any> | TIsolate,\n  ): asserts node is TIsolate {\n    invariant(\n      hasOwnProperty(node, IsolateKeys.Type),\n      text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE),\n    );\n  }\n}\n"],"names":["RuntimeEvents","ISOLATE_ENTER","ISOLATE_PENDING","ISOLATE_DONE","ErrorStrings","IsolateInspector","static","isolate","at","isNullish","_b","_a","children","length","allowsReorder","parent","allowReorder","isNotNullish","key","keys","IsolateMutator","output","child","invariant","push","setParent","node","filter","data","reason","abortController","abort","PersistedContext","createCascade","stateRef","parentContext","historyRoot","historyRootNode","ctxRef","assign","historyNode","runtimeNode","runtimeRoot","Run","run","RuntimeApi","addNodeToHistory","createRef","Reconciler","setter","Object","freeze","Bus","bus","createBus","appData","optionalFunctionValue","tinyState","createTinyState","persist","reset","resetHistoryRoot","useHistoryRoot","useAvailableRoot","root","useRuntimeRoot","useCurrentCursor","useIsolate","cursor","useLoadRootNode","useSetHistory","useXAppData","useX","cb","prev","args","ctxToUse","use","useHistoryIsolate","useHistoryIsolateAtCurrentPosition","currentIsolate","NO_ACTIVE_ISOLATE","addChild","useSetNextIsolateChild","history","setHistoryRoot","useBus","useEmit","event","emit","IsolateKeys","arg","ExcludedFromDump","Set","AbortController","Parent","Keys","isIsolateType","type","Type","isSameIsolateType","a","b","is","nextNodeResult","currentNode","newNode","usesKey","handleIsolateNodeWithKey","handleNoHistoryNode","reconciler","BaseReconciler","pickNextNode","VestRuntime.useHistoryIsolateAtCurrentPosition","UNABLE_TO_PICK_NEXT_ISOLATE","reorderLogic","prevNode","didReorder","VestRuntime.useIsolate","VestRuntime.useHistoryIsolate","slice","removeAllNextNodesInIsolate","revoke","prevNodeByKey","getChildByKey","VestRuntime.useHistoryKey","nextNode","addChildKey","deferThrow","text","ENCOUNTERED_THE_SAME_KEY_TWICE","VestRuntime.useSetIsolateKey","Isolate","callback","payload","newCreatedNode","status","__rest","AllowReorder","Data","Status","baseIsolate","nextIsolateChild","reconcile","localHistoryNode","shouldRunNew","VestRuntime.addNodeToHistory","current","VestRuntime.useRuntimeRoot","VestRuntime.Run","isPromise","then","iso","isIsolate","useRunAsNew","saveOutput","walk","startNode","visitOnly","broke","breakout","innerBreakout","some","predicate","hasMatch","closest","found","find","match","removeChild","IsolateSerializer","isStringValue","JSON","parse","expanded","expandObject","validateIsolate","queue","shift","map","nextChild","minified","minifyObject","stringify","hasOwnProperty","INVALID_ISOLATE_CANNOT_PARSE"],"mappings":"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"}