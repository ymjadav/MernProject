{"version":3,"file":"vestjs-runtime.development.js","sources":["../../src/RuntimeEvents.ts","../../src/errors/ErrorStrings.ts","../../src/Isolate/IsolateInspector.ts","../../src/Isolate/IsolateMutator.ts","../../src/VestRuntime.ts","../../src/Bus.ts","../../src/Isolate/IsolateKeys.ts","../../src/Isolate/IsolateSelectors.ts","../../src/Reconciler.ts","../../src/Isolate/Isolate.ts","../../src/IsolateWalker.ts","../../src/exports/IsolateSerializer.ts"],"sourcesContent":["export const RuntimeEvents = {\n  ISOLATE_ENTER: 'ISOLATE_ENTER',\n  ISOLATE_PENDING: 'ISOLATE_PENDING',\n  ISOLATE_DONE: 'ISOLATE_DONE',\n};\n","export enum ErrorStrings {\n  NO_ACTIVE_ISOLATE = 'Not within an active isolate',\n  UNABLE_TO_PICK_NEXT_ISOLATE = 'Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.',\n  ENCOUNTERED_THE_SAME_KEY_TWICE = `Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.`,\n  INVALID_ISOLATE_CANNOT_PARSE = `Invalid isolate was passed to IsolateSerializer. Cannot proceed.`,\n}\n","import { Nullable, isNotNullish, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateInspector {\n  static at(isolate: Nullable<TIsolate>, at: number): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.children?.[at] ?? null;\n  }\n\n  static cursor(isolate: Nullable<TIsolate>): number {\n    if (isNullish(isolate)) {\n      return 0;\n    }\n    return isolate.children?.length ?? 0;\n  }\n\n  static canReorder<I extends TIsolate>(isolate: Nullable<I>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n\n    return IsolateInspector.allowsReorder(isolate.parent);\n  }\n\n  static allowsReorder<I extends Record<any, any>>(\n    isolate: Nullable<I>\n  ): boolean {\n    return isolate?.allowReorder === true;\n  }\n\n  static usesKey(isolate: Nullable<TIsolate>): boolean {\n    if (isNullish(isolate)) {\n      return false;\n    }\n    return isNotNullish(isolate.key);\n  }\n\n  static getChildByKey(\n    isolate: Nullable<TIsolate>,\n    key: string\n  ): Nullable<TIsolate> {\n    if (isNullish(isolate)) {\n      return null;\n    }\n    return isolate.keys?.[key] ?? null;\n  }\n}\n","import { Nullable, invariant, isNullish } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\n\nexport class IsolateMutator {\n  static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate {\n    isolate.parent = parent;\n    return isolate;\n  }\n\n  static saveOutput(isolate: TIsolate, output: any): TIsolate {\n    isolate.output = output;\n    return isolate;\n  }\n\n  static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate {\n    isolate.key = key;\n    return isolate;\n  }\n\n  static addChild(isolate: TIsolate, child: TIsolate): void {\n    invariant(isolate);\n\n    isolate.children = isolate.children ?? [];\n\n    isolate.children.push(child);\n    IsolateMutator.setParent(child, isolate);\n  }\n\n  static removeChild(isolate: TIsolate, node: TIsolate): void {\n    isolate.children =\n      isolate.children?.filter(child => child !== node) ?? null;\n  }\n\n  static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void {\n    invariant(isolate);\n\n    isolate.keys = isolate.keys ?? {};\n\n    isolate.keys[key] = node;\n  }\n\n  static slice(isolate: TIsolate, at: number): void {\n    if (isNullish(isolate.children)) {\n      return;\n    }\n    isolate.children.length = at;\n  }\n\n  static setData(isolate: TIsolate, data: any): void {\n    isolate.data = data;\n  }\n\n  static abort(isolate: TIsolate, reason?: string): void {\n    if (isNullish(isolate.abortController)) {\n      return;\n    }\n    isolate.abortController.abort(reason);\n  }\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { createCascade } from 'context';\nimport {\n  invariant,\n  deferThrow,\n  isNullish,\n  assign,\n  TinyState,\n  text,\n  optionalFunctionValue,\n  tinyState,\n  BusType,\n  bus,\n  Nullable,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { IRecociler } from 'Reconciler';\n\ntype CTXType = StateRefType & {\n  historyNode: Nullable<TIsolate>;\n  runtimeNode: Nullable<TIsolate>;\n  runtimeRoot: Nullable<TIsolate>;\n  stateRef: StateRefType;\n};\n\nexport type StateRefType = {\n  Bus: BusType;\n  appData: Record<string, any>;\n  historyRoot: TinyState<Nullable<TIsolate>>;\n  Reconciler: IRecociler;\n};\n\nconst PersistedContext = createCascade<CTXType>((stateRef, parentContext) => {\n  if (parentContext) {\n    return null;\n  }\n\n  invariant(stateRef.historyRoot);\n\n  const [historyRootNode] = stateRef.historyRoot();\n\n  const ctxRef = {} as CTXType;\n\n  assign(ctxRef, {\n    historyNode: historyRootNode,\n    runtimeNode: null,\n    runtimeRoot: null,\n    stateRef,\n  });\n\n  return ctxRef;\n});\n\nexport const Run = PersistedContext.run;\n\nexport const RuntimeApi = {\n  Run,\n  addNodeToHistory,\n  createRef,\n  persist,\n  reset,\n  useAvailableRoot,\n  useCurrentCursor,\n  useHistoryRoot,\n  useLoadRootNode,\n  useXAppData,\n};\n\nexport function useXAppData<T = object>() {\n  return useX().stateRef.appData as T;\n}\n\nexport function createRef(\n  Reconciler: IRecociler,\n  setter: DynamicValue<Record<string, any>>\n): StateRefType {\n  return Object.freeze({\n    Bus: bus.createBus(),\n    Reconciler,\n    appData: optionalFunctionValue(setter),\n    historyRoot: tinyState.createTinyState<Nullable<TIsolate>>(null),\n  });\n}\n\nexport function useReconciler() {\n  return useX().stateRef.Reconciler;\n}\n\nexport function persist<T extends (...args: any[]) => any>(cb: T): T {\n  const prev = PersistedContext.useX();\n\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    const ctxToUse = PersistedContext.use() ?? prev;\n    return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));\n  }) as T;\n}\nexport function useX<T = object>(): CTXType & T {\n  return PersistedContext.useX() as CTXType & T;\n}\n\nexport function useHistoryRoot() {\n  return useX().stateRef.historyRoot();\n}\nexport function useHistoryIsolate() {\n  return useX().historyNode;\n}\n\n/**\n * Returns the history isolate at the current position.\n * If there is a parent isolate, it returns the history node from the parent's children.\n * Otherwise, it returns the history node.\n * @returns {Nullable<TIsolate>} The history isolate at the current position.\n */\nexport function useHistoryIsolateAtCurrentPosition() {\n  const parent = useIsolate();\n\n  // This is most likely the historic counterpart of the parent node\n\n  const historyNode = useHistoryIsolate();\n\n  if (parent) {\n    // If we have a parent, we need to get the history node from the parent's children\n    // We take the history node from the cursor of the active node's children\n    return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));\n  }\n\n  return historyNode;\n}\n\nexport function addNodeToHistory(node: TIsolate): void {\n  const parent = useIsolate();\n  if (parent) {\n    useSetNextIsolateChild(node);\n  } else {\n    useSetHistory(node);\n  }\n\n  IsolateMutator.setParent(node, parent);\n}\n\nexport function useSetHistory(history: TIsolate) {\n  const [, setHistoryRoot] = useHistoryRoot();\n  setHistoryRoot(history);\n}\nexport function useHistoryKey(key?: Nullable<string>): Nullable<TIsolate> {\n  if (isNullish(key)) {\n    return null;\n  }\n\n  const historyNode = useX().historyNode;\n\n  return IsolateInspector.getChildByKey(historyNode, key);\n}\n\nexport function useIsolate() {\n  return useX().runtimeNode ?? null;\n}\nexport function useCurrentCursor() {\n  const isolate = useIsolate();\n  return isolate ? IsolateInspector.cursor(isolate) : 0;\n}\nexport function useRuntimeRoot() {\n  return useX().runtimeRoot;\n}\nexport function useSetNextIsolateChild(child: TIsolate): void {\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  IsolateMutator.addChild(currentIsolate, child);\n}\nexport function useSetIsolateKey(key: Nullable<string>, node: TIsolate): void {\n  if (!key) {\n    return;\n  }\n\n  const currentIsolate = useIsolate();\n\n  invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);\n\n  if (isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {\n    IsolateMutator.addChildKey(currentIsolate, key, node);\n\n    return;\n  }\n\n  deferThrow(text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));\n}\nexport function useAvailableRoot<I extends TIsolate = TIsolate>(): I {\n  const root = useRuntimeRoot();\n\n  if (root) {\n    return root as I;\n  }\n\n  const [historyRoot] = useHistoryRoot();\n\n  return historyRoot as I;\n}\n\nexport function reset() {\n  const [, , resetHistoryRoot] = useHistoryRoot();\n\n  resetHistoryRoot();\n}\n\nexport function useLoadRootNode(root: TIsolate): void {\n  useSetHistory(root);\n}\n","import { isNullish } from 'vest-utils';\n\nimport { persist, useX } from 'VestRuntime';\n\nexport function useBus() {\n  return useX().stateRef.Bus;\n}\n\n/*\n  Returns an emitter, but it also has a shortcut for emitting an event immediately\n  by passing an event name.\n*/\nexport function useEmit(event?: string, data?: any) {\n  const emit = useBus().emit;\n\n  if (!isNullish(event)) {\n    emit(event, data);\n  }\n\n  return persist(emit);\n}\n\nexport function usePrepareEmitter<T = void>(event: string): (arg: T) => void {\n  const emit = useEmit();\n\n  return (arg: T) => emit(event, arg);\n}\n","export enum IsolateKeys {\n  Type = '$type',\n  Keys = 'keys',\n  Key = 'key',\n  Parent = 'parent',\n  Data = 'data',\n  AllowReorder = 'allowReorder',\n  Status = 'status',\n  AbortController = 'abortController',\n  Children = 'children',\n}\n\nexport const ExcludedFromDump = new Set([\n  IsolateKeys.AbortController,\n  IsolateKeys.Parent,\n  IsolateKeys.Keys,\n]);\n","import { Maybe } from 'vest-utils';\n\nimport { TIsolate } from 'Isolate';\nimport { IsolateKeys } from 'IsolateKeys';\n\nexport function isIsolateType<I extends TIsolate>(\n  node: Maybe<TIsolate>,\n  type: string\n): node is I {\n  return node?.[IsolateKeys.Type] === type;\n}\n\nexport function isSameIsolateType<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return isIsolateType(a, b[IsolateKeys.Type]);\n}\n\nexport function isSameIsolateIdentity<A extends TIsolate, B extends TIsolate>(\n  a: A,\n  b: B\n): boolean {\n  return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport { type TIsolate } from 'Isolate';\nimport { IsolateInspector } from 'IsolateInspector';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { isSameIsolateType } from 'IsolateSelectors';\nimport * as VestRuntime from 'VestRuntime';\nimport {\n  Maybe,\n  Nullable,\n  invariant,\n  isNullish,\n  optionalFunctionValue,\n} from 'vest-utils';\n// import { isSameIsolateType } from 'IsolateSelectors';\n\n// I would rather not use `any` here, but instead use `Isolate`.\n// The problem is that it breaks the actual implementation of `Isolate` in `IsolateTest`\n// As it is not properly extending `Isolate`.\nexport interface IRecociler<I = any> {\n  (currentNode: I, historyNode: I): Nullable<I>;\n}\n\nfunction BaseReconciler(\n  currentNode: TIsolate,\n  historyNode: TIsolate,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return currentNode;\n  }\n  return currentNode;\n}\n\nexport class Reconciler {\n  /**\n   * Reconciles the current isolate with the history isolate.\n   * If the current isolate is of a different type than the history isolate,\n   * the current isolate is returned.\n   * Otherwise, the reconciler function is called to determine the next isolate.\n   * If the reconciler function returns null or undefined, the base reconciler is used.\n   * If no history isolate exists, the current isolate is returned.\n   * @param node The current isolate to reconcile.\n   * @returns The next isolate after reconciliation.\n   */\n  static reconcile(node: TIsolate): TIsolate {\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const nextNodeResult = pickNextNode(node, localHistoryNode);\n\n    invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);\n\n    return nextNodeResult;\n  }\n\n  static dropNextNodesOnReorder<I extends TIsolate>(\n    reorderLogic: (newNode: I, prevNode: Maybe<TIsolate>) => boolean,\n    newNode: I,\n    prevNode: Maybe<TIsolate>,\n  ): boolean {\n    const didReorder = reorderLogic(newNode, prevNode);\n\n    if (didReorder) {\n      removeAllNextNodesInIsolate();\n    }\n\n    return didReorder;\n  }\n\n  static handleIsolateNodeWithKey<I extends TIsolate>(\n    node: TIsolate,\n\n    // The revoke function allows the caller to revoke the previous node\n    revoke: ((node: I) => boolean) | false,\n  ): TIsolate {\n    invariant(IsolateInspector.usesKey(node));\n\n    const prevNodeByKey = VestRuntime.useHistoryKey(node.key);\n    let nextNode = node;\n\n    if (\n      !isNullish(prevNodeByKey) &&\n      !optionalFunctionValue(revoke, prevNodeByKey)\n    ) {\n      nextNode = prevNodeByKey;\n    }\n\n    VestRuntime.useSetIsolateKey(node.key, nextNode);\n\n    return nextNode;\n  }\n}\n\nfunction pickNextNode(\n  currentNode: TIsolate,\n  historyNode: Nullable<TIsolate>,\n): TIsolate {\n  if (isNullish(historyNode)) {\n    return handleNoHistoryNode(currentNode);\n  }\n\n  if (!isSameIsolateType(currentNode, historyNode)) {\n    return currentNode;\n  }\n\n  const reconciler = VestRuntime.useReconciler();\n\n  return (\n    reconciler(currentNode, historyNode) ??\n    BaseReconciler(currentNode, historyNode)\n  );\n}\n\nfunction handleNoHistoryNode<I extends TIsolate>(newNode: I): I {\n  if (IsolateInspector.usesKey(newNode)) {\n    return Reconciler.handleIsolateNodeWithKey(newNode, false) as I;\n  }\n\n  return newNode;\n}\n\nfunction removeAllNextNodesInIsolate() {\n  const currentNode = VestRuntime.useIsolate();\n  const historyNode = VestRuntime.useHistoryIsolate();\n\n  if (!historyNode || !currentNode) {\n    // This is probably unreachable, but TS is not convinced.\n    // Let's play it safe.\n    /* istanbul ignore next */\n    return;\n  }\n\n  IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));\n}\n","import { CB, Maybe, Nullable, isNotNullish, isPromise } from 'vest-utils';\n\nimport { useEmit } from 'Bus';\nimport { IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\nimport { Reconciler } from 'Reconciler';\nimport { RuntimeEvents } from 'RuntimeEvents';\nimport * as VestRuntime from 'VestRuntime';\n\nexport type IsolateKey = Nullable<string>;\n\nexport type TIsolate<P extends IsolatePayload = IsolatePayload> = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Parent]: Nullable<TIsolate>;\n  [IsolateKeys.Type]: string;\n  [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;\n  [IsolateKeys.Data]: DataOnly<P>;\n  [IsolateKeys.Status]?: string;\n  [IsolateKeys.AbortController]: AbortController;\n  children: Nullable<TIsolate[]>;\n  key: IsolateKey;\n  output: any;\n} & UsedFeaturesOnly<P>;\n\ntype DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;\ntype UsedFeaturesOnly<P extends IsolatePayload> = Pick<\n  P,\n  keyof IsolateFeatures\n>;\n\nexport class Isolate {\n  static create<Payload extends IsolatePayload>(\n    type: string,\n    callback: CB,\n    payload: Maybe<Payload> = undefined,\n    key?: IsolateKey,\n  ): TIsolate<Payload> {\n    const parent = VestRuntime.useIsolate();\n\n    const newCreatedNode = IsolateMutator.setParent(\n      baseIsolate(type, payload, key),\n      parent,\n    );\n\n    const nextIsolateChild = Reconciler.reconcile(newCreatedNode);\n\n    const localHistoryNode = VestRuntime.useHistoryIsolateAtCurrentPosition();\n\n    const shouldRunNew = Object.is(nextIsolateChild, newCreatedNode);\n\n    VestRuntime.addNodeToHistory(nextIsolateChild);\n\n    const output = shouldRunNew\n      ? useRunAsNew(localHistoryNode, newCreatedNode, callback)\n      : nextIsolateChild.output;\n\n    IsolateMutator.saveOutput(nextIsolateChild, output);\n\n    return nextIsolateChild as TIsolate<Payload>;\n  }\n\n  static isIsolate(node: any): node is TIsolate {\n    return isNotNullish(node) && node[IsolateKeys.Type];\n  }\n}\n\n/**\n * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.\n * Runs the callback function and returns its output.\n * @param localHistoryNode The local history node.\n * @param current The current isolate.\n * @param callback The callback function to execute.\n * @returns The output of the callback function.\n */\nfunction useRunAsNew<Callback extends CB = CB>(\n  localHistoryNode: Nullable<TIsolate>,\n  current: TIsolate,\n  callback: CB,\n): ReturnType<Callback> {\n  const runtimeRoot = VestRuntime.useRuntimeRoot();\n  const emit = useEmit();\n\n  // We're creating a new child isolate context where the local history node\n  // is the current history node, thus advancing the history cursor.\n  const output = VestRuntime.Run(\n    {\n      historyNode: localHistoryNode,\n      runtimeNode: current,\n      ...(!runtimeRoot && { runtimeRoot: current }),\n    },\n    () => {\n      emit(RuntimeEvents.ISOLATE_ENTER, current);\n      const output = callback(current);\n\n      if (isPromise(output)) {\n        emit(RuntimeEvents.ISOLATE_PENDING, current);\n        output.then(iso => {\n          if (Isolate.isIsolate(iso)) {\n            IsolateMutator.addChild(current, iso);\n          }\n\n          emit(RuntimeEvents.ISOLATE_DONE, current);\n        });\n      } else {\n        emit(RuntimeEvents.ISOLATE_DONE, current);\n      }\n\n      return output;\n    },\n  );\n\n  current.output = output;\n  return output;\n}\n\nfunction baseIsolate(\n  type: string,\n  payload: Maybe<IsolatePayload> = undefined,\n  key: IsolateKey = null,\n): TIsolate {\n  const { allowReorder, status, ...data } = payload ?? {};\n  return {\n    [IsolateKeys.AllowReorder]: allowReorder,\n    [IsolateKeys.AbortController]: new AbortController(),\n    [IsolateKeys.Keys]: null,\n    [IsolateKeys.Parent]: null,\n    [IsolateKeys.Type]: type,\n    [IsolateKeys.Data]: data as IsolateData,\n    ...(status && { [IsolateKeys.Status]: status }),\n    children: null,\n    key,\n    output: null,\n  };\n}\n\ntype IsolateData = Record<string, any>;\ntype IsolatePayload = IsolateData & IsolateFeatures;\ntype IsolateFeatures = {\n  [IsolateKeys.AllowReorder]?: boolean;\n  [IsolateKeys.Status]?: string;\n};\n","import { CB, Nullable, isNullish, optionalFunctionValue } from 'vest-utils';\n\nimport { type TIsolate } from 'Isolate';\nimport { IsolateMutator } from 'IsolateMutator';\n\ntype VisitOnlyPredicate = (isolate: TIsolate) => boolean;\n\n// eslint-disable-next-line\nexport function walk(\n  startNode: TIsolate,\n  callback: (isolate: TIsolate, breakout: CB<void>) => void,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  // If the startNode has no children, there is nothing to walk.\n  if (isNullish(startNode.children)) {\n    return;\n  }\n\n  let broke = false;\n\n  // For each child Isolate object, call the callback function.\n  for (const isolate of startNode.children) {\n    if (broke) {\n      return;\n    }\n\n    // If visitOnly is not provided or the predicate is satisfied, call the callback function.\n    if (isNullish(visitOnly) || optionalFunctionValue(visitOnly, isolate)) {\n      callback(isolate, breakout);\n    }\n\n    // If the breakout function has been called, stop the walk.\n    if (broke) {\n      return;\n    }\n\n    // Recursively walk through the child Isolate object.\n    walk(\n      isolate,\n      (child, innerBreakout) => {\n        callback(child, () => {\n          innerBreakout();\n          breakout();\n        });\n      },\n      visitOnly,\n    );\n  }\n\n  function breakout() {\n    broke = true;\n  }\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function some(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = false;\n\n  // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        hasMatch = true;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function returns true if the given predicate function returns true for any Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function has(startNode: TIsolate, match: VisitOnlyPredicate): boolean {\n  return some(startNode, () => true, match);\n}\n\n// traverses up to a parent node that satisfies the predicate\n// and returns the first direct descendant that satisfies the predicate\nexport function findClosest<I extends TIsolate = TIsolate>(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<I> {\n  let found: Nullable<TIsolate> = null;\n  let current: Nullable<TIsolate> = startNode;\n\n  while (current) {\n    found = current.children?.find(predicate) ?? null;\n\n    if (found) {\n      break;\n    }\n\n    current = current.parent;\n  }\n\n  return found as Nullable<I>;\n}\n\n// This function returns the first Isolate object in the tree that satisfies the given predicate function.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function find(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): Nullable<TIsolate> {\n  let found = null;\n\n  // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (predicate(node)) {\n        breakout();\n        found = node;\n      }\n    },\n    visitOnly,\n  );\n\n  return found;\n}\n\n// This function returns true if the given predicate function returns true for every Isolate object in the tree.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function every(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): boolean {\n  let hasMatch = true;\n  walk(\n    startNode,\n    (node, breakout) => {\n      if (!predicate(node)) {\n        breakout();\n        hasMatch = false;\n      }\n    },\n    visitOnly,\n  );\n\n  return hasMatch;\n}\n\n// This function removes all Isolate objects in the tree that\n// satisfy the given predicate function and have a parent.\n// If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.\nexport function pluck(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n  visitOnly?: VisitOnlyPredicate,\n): void {\n  walk(\n    startNode,\n    node => {\n      if (predicate(node) && node.parent) {\n        IsolateMutator.removeChild(node.parent, node);\n      }\n    },\n    visitOnly,\n  );\n}\n\n// Returns the closest ancestor Isolate object of the given\n//startNode that satisfies the given predicate function.\nexport function closest(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): Nullable<TIsolate> {\n  let current: Nullable<TIsolate> = startNode;\n  do {\n    if (predicate(current)) {\n      return current;\n    }\n    current = current.parent;\n  } while (current);\n  return null;\n}\n\n// This function returns true if the closest ancestor Isolates of the\n// given startNode that satisfies the given predicate function exists.\nexport function closestExists(\n  startNode: TIsolate,\n  predicate: (node: TIsolate) => boolean,\n): boolean {\n  return !!closest(startNode, predicate);\n}\n","import { ErrorStrings } from 'ErrorStrings';\nimport {\n  Nullable,\n  hasOwnProperty,\n  invariant,\n  isNullish,\n  isStringValue,\n  text,\n} from 'vest-utils';\nimport { expandObject, minifyObject } from 'vest-utils/minifyObject';\n\nimport { TIsolate } from 'Isolate';\nimport { ExcludedFromDump, IsolateKeys } from 'IsolateKeys';\nimport { IsolateMutator } from 'IsolateMutator';\n\nexport class IsolateSerializer {\n  // eslint-disable-next-line max-statements, complexity, max-lines-per-function\n  static deserialize(node: Record<string, any> | TIsolate | string): TIsolate {\n    // Validate the root object\n    const root = (\n      isStringValue(node) ? JSON.parse(node) : ({ ...node } as TIsolate)\n    ) as [any, any];\n\n    const expanded = expandObject(...root);\n\n    IsolateSerializer.validateIsolate(expanded);\n\n    const queue = [expanded];\n\n    // Iterate over the queue until it's empty\n    while (queue.length) {\n      // Get the next item from the queue\n      const current = queue.shift();\n\n      if (!current) {\n        continue;\n      }\n\n      const children = current.children;\n\n      // If there are no children, nothing to do.\n      if (!children) {\n        continue;\n      }\n\n      // Copy the children and set their parent to the current node.\n      current.children = children.map(child => {\n        const nextChild = { ...child };\n\n        IsolateMutator.setParent(nextChild, current);\n        queue.push(nextChild);\n\n        // If the child has a key, add it to the parent's keys.\n        const key = nextChild.key;\n\n        if (key) {\n          current.keys = current.keys ?? {};\n          current.keys[key] = nextChild;\n        }\n\n        return nextChild;\n      });\n    }\n\n    return expanded;\n  }\n\n  static serialize(isolate: Nullable<TIsolate>): string {\n    if (isNullish(isolate)) {\n      return '';\n    }\n\n    const minified = minifyObject(isolate, ExcludedFromDump);\n\n    return JSON.stringify(minified);\n  }\n\n  static validateIsolate(\n    node: Record<string, any> | TIsolate,\n  ): asserts node is TIsolate {\n    invariant(\n      hasOwnProperty(node, IsolateKeys.Type),\n      text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE),\n    );\n  }\n}\n"],"names":["isNullish","isNotNullish","invariant","createCascade","assign","bus","optionalFunctionValue","tinyState","deferThrow","text","VestRuntime.useHistoryIsolateAtCurrentPosition","VestRuntime.useHistoryKey","VestRuntime.useSetIsolateKey","VestRuntime.useReconciler","VestRuntime.useIsolate","VestRuntime.useHistoryIsolate","VestRuntime.addNodeToHistory","VestRuntime.useRuntimeRoot","VestRuntime.Run","isPromise","isStringValue","expandObject","minifyObject","hasOwnProperty"],"mappings":"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"}