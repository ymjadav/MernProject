(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vest-utils'), require('context'), require('vest-utils/minifyObject')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vest-utils', 'context', 'vest-utils/minifyObject'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["vestjs-runtime"] = {}, global["vest-utils"], global.context, global.minifyObject));
})(this, (function (exports, vestUtils, context, minifyObject) { 'use strict';

  const RuntimeEvents = {
      ISOLATE_ENTER: 'ISOLATE_ENTER',
      ISOLATE_PENDING: 'ISOLATE_PENDING',
      ISOLATE_DONE: 'ISOLATE_DONE',
  };

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol */


  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  var ErrorStrings;
  (function (ErrorStrings) {
      ErrorStrings["NO_ACTIVE_ISOLATE"] = "Not within an active isolate";
      ErrorStrings["UNABLE_TO_PICK_NEXT_ISOLATE"] = "Unable to pick next isolate. This is a bug, please report it to the Vest maintainers.";
      ErrorStrings["ENCOUNTERED_THE_SAME_KEY_TWICE"] = "Encountered the same key \"{key}\" twice. This may lead to inconsistent or overriding of results.";
      ErrorStrings["INVALID_ISOLATE_CANNOT_PARSE"] = "Invalid isolate was passed to IsolateSerializer. Cannot proceed.";
  })(ErrorStrings || (ErrorStrings = {}));

  class IsolateInspector {
      static at(isolate, at) {
          var _a, _b;
          if (vestUtils.isNullish(isolate)) {
              return null;
          }
          return (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a[at]) !== null && _b !== void 0 ? _b : null;
      }
      static cursor(isolate) {
          var _a, _b;
          if (vestUtils.isNullish(isolate)) {
              return 0;
          }
          return (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      static canReorder(isolate) {
          if (vestUtils.isNullish(isolate)) {
              return false;
          }
          return IsolateInspector.allowsReorder(isolate.parent);
      }
      static allowsReorder(isolate) {
          return (isolate === null || isolate === void 0 ? void 0 : isolate.allowReorder) === true;
      }
      static usesKey(isolate) {
          if (vestUtils.isNullish(isolate)) {
              return false;
          }
          return vestUtils.isNotNullish(isolate.key);
      }
      static getChildByKey(isolate, key) {
          var _a, _b;
          if (vestUtils.isNullish(isolate)) {
              return null;
          }
          return (_b = (_a = isolate.keys) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;
      }
  }

  class IsolateMutator {
      static setParent(isolate, parent) {
          isolate.parent = parent;
          return isolate;
      }
      static saveOutput(isolate, output) {
          isolate.output = output;
          return isolate;
      }
      static setKey(isolate, key) {
          isolate.key = key;
          return isolate;
      }
      static addChild(isolate, child) {
          var _a;
          vestUtils.invariant(isolate);
          isolate.children = (_a = isolate.children) !== null && _a !== void 0 ? _a : [];
          isolate.children.push(child);
          IsolateMutator.setParent(child, isolate);
      }
      static removeChild(isolate, node) {
          var _a, _b;
          isolate.children =
              (_b = (_a = isolate.children) === null || _a === void 0 ? void 0 : _a.filter(child => child !== node)) !== null && _b !== void 0 ? _b : null;
      }
      static addChildKey(isolate, key, node) {
          var _a;
          vestUtils.invariant(isolate);
          isolate.keys = (_a = isolate.keys) !== null && _a !== void 0 ? _a : {};
          isolate.keys[key] = node;
      }
      static slice(isolate, at) {
          if (vestUtils.isNullish(isolate.children)) {
              return;
          }
          isolate.children.length = at;
      }
      static setData(isolate, data) {
          isolate.data = data;
      }
      static abort(isolate, reason) {
          if (vestUtils.isNullish(isolate.abortController)) {
              return;
          }
          isolate.abortController.abort(reason);
      }
  }

  const PersistedContext = context.createCascade((stateRef, parentContext) => {
      if (parentContext) {
          return null;
      }
      vestUtils.invariant(stateRef.historyRoot);
      const [historyRootNode] = stateRef.historyRoot();
      const ctxRef = {};
      vestUtils.assign(ctxRef, {
          historyNode: historyRootNode,
          runtimeNode: null,
          runtimeRoot: null,
          stateRef,
      });
      return ctxRef;
  });
  const Run = PersistedContext.run;
  const RuntimeApi = {
      Run,
      addNodeToHistory,
      createRef,
      persist,
      reset,
      useAvailableRoot,
      useCurrentCursor,
      useHistoryRoot,
      useLoadRootNode,
      useXAppData,
  };
  function useXAppData() {
      return useX().stateRef.appData;
  }
  function createRef(Reconciler, setter) {
      return Object.freeze({
          Bus: vestUtils.bus.createBus(),
          Reconciler,
          appData: vestUtils.optionalFunctionValue(setter),
          historyRoot: vestUtils.tinyState.createTinyState(null),
      });
  }
  function useReconciler() {
      return useX().stateRef.Reconciler;
  }
  function persist(cb) {
      const prev = PersistedContext.useX();
      return ((...args) => {
          var _a;
          const ctxToUse = (_a = PersistedContext.use()) !== null && _a !== void 0 ? _a : prev;
          return PersistedContext.run(ctxToUse.stateRef, () => cb(...args));
      });
  }
  function useX() {
      return PersistedContext.useX();
  }
  function useHistoryRoot() {
      return useX().stateRef.historyRoot();
  }
  function useHistoryIsolate() {
      return useX().historyNode;
  }
  /**
   * Returns the history isolate at the current position.
   * If there is a parent isolate, it returns the history node from the parent's children.
   * Otherwise, it returns the history node.
   * @returns {Nullable<TIsolate>} The history isolate at the current position.
   */
  function useHistoryIsolateAtCurrentPosition() {
      const parent = useIsolate();
      // This is most likely the historic counterpart of the parent node
      const historyNode = useHistoryIsolate();
      if (parent) {
          // If we have a parent, we need to get the history node from the parent's children
          // We take the history node from the cursor of the active node's children
          return IsolateInspector.at(historyNode, IsolateInspector.cursor(parent));
      }
      return historyNode;
  }
  function addNodeToHistory(node) {
      const parent = useIsolate();
      if (parent) {
          useSetNextIsolateChild(node);
      }
      else {
          useSetHistory(node);
      }
      IsolateMutator.setParent(node, parent);
  }
  function useSetHistory(history) {
      const [, setHistoryRoot] = useHistoryRoot();
      setHistoryRoot(history);
  }
  function useHistoryKey(key) {
      if (vestUtils.isNullish(key)) {
          return null;
      }
      const historyNode = useX().historyNode;
      return IsolateInspector.getChildByKey(historyNode, key);
  }
  function useIsolate() {
      var _a;
      return (_a = useX().runtimeNode) !== null && _a !== void 0 ? _a : null;
  }
  function useCurrentCursor() {
      const isolate = useIsolate();
      return isolate ? IsolateInspector.cursor(isolate) : 0;
  }
  function useRuntimeRoot() {
      return useX().runtimeRoot;
  }
  function useSetNextIsolateChild(child) {
      const currentIsolate = useIsolate();
      vestUtils.invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);
      IsolateMutator.addChild(currentIsolate, child);
  }
  function useSetIsolateKey(key, node) {
      if (!key) {
          return;
      }
      const currentIsolate = useIsolate();
      vestUtils.invariant(currentIsolate, ErrorStrings.NO_ACTIVE_ISOLATE);
      if (vestUtils.isNullish(IsolateInspector.getChildByKey(currentIsolate, key))) {
          IsolateMutator.addChildKey(currentIsolate, key, node);
          return;
      }
      vestUtils.deferThrow(vestUtils.text(ErrorStrings.ENCOUNTERED_THE_SAME_KEY_TWICE, { key }));
  }
  function useAvailableRoot() {
      const root = useRuntimeRoot();
      if (root) {
          return root;
      }
      const [historyRoot] = useHistoryRoot();
      return historyRoot;
  }
  function reset() {
      const [, , resetHistoryRoot] = useHistoryRoot();
      resetHistoryRoot();
  }
  function useLoadRootNode(root) {
      useSetHistory(root);
  }

  function useBus() {
      return useX().stateRef.Bus;
  }
  /*
    Returns an emitter, but it also has a shortcut for emitting an event immediately
    by passing an event name.
  */
  function useEmit(event, data) {
      const emit = useBus().emit;
      if (!vestUtils.isNullish(event)) {
          emit(event, data);
      }
      return persist(emit);
  }
  function usePrepareEmitter(event) {
      const emit = useEmit();
      return (arg) => emit(event, arg);
  }

  var Bus = /*#__PURE__*/Object.freeze({
    __proto__: null,
    useBus: useBus,
    useEmit: useEmit,
    usePrepareEmitter: usePrepareEmitter
  });

  var IsolateKeys;
  (function (IsolateKeys) {
      IsolateKeys["Type"] = "$type";
      IsolateKeys["Keys"] = "keys";
      IsolateKeys["Key"] = "key";
      IsolateKeys["Parent"] = "parent";
      IsolateKeys["Data"] = "data";
      IsolateKeys["AllowReorder"] = "allowReorder";
      IsolateKeys["Status"] = "status";
      IsolateKeys["AbortController"] = "abortController";
      IsolateKeys["Children"] = "children";
  })(IsolateKeys || (IsolateKeys = {}));
  const ExcludedFromDump = new Set([
      IsolateKeys.AbortController,
      IsolateKeys.Parent,
      IsolateKeys.Keys,
  ]);

  function isIsolateType(node, type) {
      return (node === null || node === void 0 ? void 0 : node[IsolateKeys.Type]) === type;
  }
  function isSameIsolateType(a, b) {
      return isIsolateType(a, b[IsolateKeys.Type]);
  }
  function isSameIsolateIdentity(a, b) {
      return Object.is(a, b) || (isSameIsolateType(a, b) && a.key === b.key);
  }

  var IsolateSelectors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isIsolateType: isIsolateType,
    isSameIsolateIdentity: isSameIsolateIdentity,
    isSameIsolateType: isSameIsolateType
  });

  function BaseReconciler(currentNode, historyNode) {
      if (vestUtils.isNullish(historyNode)) {
          return currentNode;
      }
      return currentNode;
  }
  class Reconciler {
      /**
       * Reconciles the current isolate with the history isolate.
       * If the current isolate is of a different type than the history isolate,
       * the current isolate is returned.
       * Otherwise, the reconciler function is called to determine the next isolate.
       * If the reconciler function returns null or undefined, the base reconciler is used.
       * If no history isolate exists, the current isolate is returned.
       * @param node The current isolate to reconcile.
       * @returns The next isolate after reconciliation.
       */
      static reconcile(node) {
          const localHistoryNode = useHistoryIsolateAtCurrentPosition();
          const nextNodeResult = pickNextNode(node, localHistoryNode);
          vestUtils.invariant(nextNodeResult, ErrorStrings.UNABLE_TO_PICK_NEXT_ISOLATE);
          return nextNodeResult;
      }
      static dropNextNodesOnReorder(reorderLogic, newNode, prevNode) {
          const didReorder = reorderLogic(newNode, prevNode);
          if (didReorder) {
              removeAllNextNodesInIsolate();
          }
          return didReorder;
      }
      static handleIsolateNodeWithKey(node, 
      // The revoke function allows the caller to revoke the previous node
      revoke) {
          vestUtils.invariant(IsolateInspector.usesKey(node));
          const prevNodeByKey = useHistoryKey(node.key);
          let nextNode = node;
          if (!vestUtils.isNullish(prevNodeByKey) &&
              !vestUtils.optionalFunctionValue(revoke, prevNodeByKey)) {
              nextNode = prevNodeByKey;
          }
          useSetIsolateKey(node.key, nextNode);
          return nextNode;
      }
  }
  function pickNextNode(currentNode, historyNode) {
      var _a;
      if (vestUtils.isNullish(historyNode)) {
          return handleNoHistoryNode(currentNode);
      }
      if (!isSameIsolateType(currentNode, historyNode)) {
          return currentNode;
      }
      const reconciler = useReconciler();
      return ((_a = reconciler(currentNode, historyNode)) !== null && _a !== void 0 ? _a : BaseReconciler(currentNode, historyNode));
  }
  function handleNoHistoryNode(newNode) {
      if (IsolateInspector.usesKey(newNode)) {
          return Reconciler.handleIsolateNodeWithKey(newNode, false);
      }
      return newNode;
  }
  function removeAllNextNodesInIsolate() {
      const currentNode = useIsolate();
      const historyNode = useHistoryIsolate();
      if (!historyNode || !currentNode) {
          // This is probably unreachable, but TS is not convinced.
          // Let's play it safe.
          /* istanbul ignore next */
          return;
      }
      IsolateMutator.slice(historyNode, IsolateInspector.cursor(currentNode));
  }

  class Isolate {
      static create(type, callback, payload = undefined, key) {
          const parent = useIsolate();
          const newCreatedNode = IsolateMutator.setParent(baseIsolate(type, payload, key), parent);
          const nextIsolateChild = Reconciler.reconcile(newCreatedNode);
          const localHistoryNode = useHistoryIsolateAtCurrentPosition();
          const shouldRunNew = Object.is(nextIsolateChild, newCreatedNode);
          addNodeToHistory(nextIsolateChild);
          const output = shouldRunNew
              ? useRunAsNew(localHistoryNode, newCreatedNode, callback)
              : nextIsolateChild.output;
          IsolateMutator.saveOutput(nextIsolateChild, output);
          return nextIsolateChild;
      }
      static isIsolate(node) {
          return vestUtils.isNotNullish(node) && node[IsolateKeys.Type];
      }
  }
  /**
   * Creates a new child isolate context where the local history node is the current history node, thus advancing the history cursor.
   * Runs the callback function and returns its output.
   * @param localHistoryNode The local history node.
   * @param current The current isolate.
   * @param callback The callback function to execute.
   * @returns The output of the callback function.
   */
  function useRunAsNew(localHistoryNode, current, callback) {
      const runtimeRoot = useRuntimeRoot();
      const emit = useEmit();
      // We're creating a new child isolate context where the local history node
      // is the current history node, thus advancing the history cursor.
      const output = Run(Object.assign({ historyNode: localHistoryNode, runtimeNode: current }, (!runtimeRoot && { runtimeRoot: current })), () => {
          emit(RuntimeEvents.ISOLATE_ENTER, current);
          const output = callback(current);
          if (vestUtils.isPromise(output)) {
              emit(RuntimeEvents.ISOLATE_PENDING, current);
              output.then(iso => {
                  if (Isolate.isIsolate(iso)) {
                      IsolateMutator.addChild(current, iso);
                  }
                  emit(RuntimeEvents.ISOLATE_DONE, current);
              });
          }
          else {
              emit(RuntimeEvents.ISOLATE_DONE, current);
          }
          return output;
      });
      current.output = output;
      return output;
  }
  function baseIsolate(type, payload = undefined, key = null) {
      const _a = payload !== null && payload !== void 0 ? payload : {}, { allowReorder, status } = _a, data = __rest(_a, ["allowReorder", "status"]);
      return Object.assign(Object.assign({ [IsolateKeys.AllowReorder]: allowReorder, [IsolateKeys.AbortController]: new AbortController(), [IsolateKeys.Keys]: null, [IsolateKeys.Parent]: null, [IsolateKeys.Type]: type, [IsolateKeys.Data]: data }, (status && { [IsolateKeys.Status]: status })), { children: null, key, output: null });
  }

  // eslint-disable-next-line
  function walk(startNode, callback, visitOnly) {
      // If the startNode has no children, there is nothing to walk.
      if (vestUtils.isNullish(startNode.children)) {
          return;
      }
      let broke = false;
      // For each child Isolate object, call the callback function.
      for (const isolate of startNode.children) {
          if (broke) {
              return;
          }
          // If visitOnly is not provided or the predicate is satisfied, call the callback function.
          if (vestUtils.isNullish(visitOnly) || vestUtils.optionalFunctionValue(visitOnly, isolate)) {
              callback(isolate, breakout);
          }
          // If the breakout function has been called, stop the walk.
          if (broke) {
              return;
          }
          // Recursively walk through the child Isolate object.
          walk(isolate, (child, innerBreakout) => {
              callback(child, () => {
                  innerBreakout();
                  breakout();
              });
          }, visitOnly);
      }
      function breakout() {
          broke = true;
      }
  }
  // This function returns true if the given predicate function returns true for any Isolate object in the tree.
  // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
  function some(startNode, predicate, visitOnly) {
      let hasMatch = false;
      // Call the walk function with a callback function that sets hasMatch to true if the predicate is satisfied.
      walk(startNode, (node, breakout) => {
          if (predicate(node)) {
              breakout();
              hasMatch = true;
          }
      }, visitOnly);
      return hasMatch;
  }
  // This function returns true if the given predicate function returns true for any Isolate object in the tree.
  // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
  function has(startNode, match) {
      return some(startNode, () => true, match);
  }
  // traverses up to a parent node that satisfies the predicate
  // and returns the first direct descendant that satisfies the predicate
  function findClosest(startNode, predicate) {
      var _a, _b;
      let found = null;
      let current = startNode;
      while (current) {
          found = (_b = (_a = current.children) === null || _a === void 0 ? void 0 : _a.find(predicate)) !== null && _b !== void 0 ? _b : null;
          if (found) {
              break;
          }
          current = current.parent;
      }
      return found;
  }
  // This function returns the first Isolate object in the tree that satisfies the given predicate function.
  // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
  function find(startNode, predicate, visitOnly) {
      let found = null;
      // Call the walk function with a callback function that sets found to the current node if the predicate is satisfied.
      walk(startNode, (node, breakout) => {
          if (predicate(node)) {
              breakout();
              found = node;
          }
      }, visitOnly);
      return found;
  }
  // This function returns true if the given predicate function returns true for every Isolate object in the tree.
  // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
  function every(startNode, predicate, visitOnly) {
      let hasMatch = true;
      walk(startNode, (node, breakout) => {
          if (!predicate(node)) {
              breakout();
              hasMatch = false;
          }
      }, visitOnly);
      return hasMatch;
  }
  // This function removes all Isolate objects in the tree that
  // satisfy the given predicate function and have a parent.
  // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
  function pluck(startNode, predicate, visitOnly) {
      walk(startNode, node => {
          if (predicate(node) && node.parent) {
              IsolateMutator.removeChild(node.parent, node);
          }
      }, visitOnly);
  }
  // Returns the closest ancestor Isolate object of the given
  //startNode that satisfies the given predicate function.
  function closest(startNode, predicate) {
      let current = startNode;
      do {
          if (predicate(current)) {
              return current;
          }
          current = current.parent;
      } while (current);
      return null;
  }
  // This function returns true if the closest ancestor Isolates of the
  // given startNode that satisfies the given predicate function exists.
  function closestExists(startNode, predicate) {
      return !!closest(startNode, predicate);
  }

  var IsolateWalker = /*#__PURE__*/Object.freeze({
    __proto__: null,
    closest: closest,
    closestExists: closestExists,
    every: every,
    find: find,
    findClosest: findClosest,
    has: has,
    pluck: pluck,
    some: some,
    walk: walk
  });

  class IsolateSerializer {
      // eslint-disable-next-line max-statements, complexity, max-lines-per-function
      static deserialize(node) {
          // Validate the root object
          const root = (vestUtils.isStringValue(node) ? JSON.parse(node) : Object.assign({}, node));
          const expanded = minifyObject.expandObject(...root);
          IsolateSerializer.validateIsolate(expanded);
          const queue = [expanded];
          // Iterate over the queue until it's empty
          while (queue.length) {
              // Get the next item from the queue
              const current = queue.shift();
              if (!current) {
                  continue;
              }
              const children = current.children;
              // If there are no children, nothing to do.
              if (!children) {
                  continue;
              }
              // Copy the children and set their parent to the current node.
              current.children = children.map(child => {
                  var _a;
                  const nextChild = Object.assign({}, child);
                  IsolateMutator.setParent(nextChild, current);
                  queue.push(nextChild);
                  // If the child has a key, add it to the parent's keys.
                  const key = nextChild.key;
                  if (key) {
                      current.keys = (_a = current.keys) !== null && _a !== void 0 ? _a : {};
                      current.keys[key] = nextChild;
                  }
                  return nextChild;
              });
          }
          return expanded;
      }
      static serialize(isolate) {
          if (vestUtils.isNullish(isolate)) {
              return '';
          }
          const minified = minifyObject.minifyObject(isolate, ExcludedFromDump);
          return JSON.stringify(minified);
      }
      static validateIsolate(node) {
          vestUtils.invariant(vestUtils.hasOwnProperty(node, IsolateKeys.Type), vestUtils.text(ErrorStrings.INVALID_ISOLATE_CANNOT_PARSE));
      }
  }

  exports.Bus = Bus;
  exports.Isolate = Isolate;
  exports.IsolateInspector = IsolateInspector;
  exports.IsolateMutator = IsolateMutator;
  exports.IsolateSelectors = IsolateSelectors;
  exports.IsolateSerializer = IsolateSerializer;
  exports.Reconciler = Reconciler;
  exports.RuntimeEvents = RuntimeEvents;
  exports.VestRuntime = RuntimeApi;
  exports.Walker = IsolateWalker;

}));
//# sourceMappingURL=vestjs-runtime.development.js.map
