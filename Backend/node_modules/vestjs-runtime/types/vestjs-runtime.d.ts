/// <reference types="node" />
import { CB, Maybe, Nullable, TinyState, BusType, DynamicValue } from "vest-utils";
declare const RuntimeEvents: {
    ISOLATE_ENTER: string;
    ISOLATE_PENDING: string;
    ISOLATE_DONE: string;
};
declare enum IsolateKeys {
    Type = "$type",
    Keys = "keys",
    Key = "key",
    Parent = "parent",
    Data = "data",
    AllowReorder = "allowReorder",
    Status = "status",
    AbortController = "abortController",
    Children = "children"
}
type IsolateKey = Nullable<string>;
type TIsolate<P extends IsolatePayload = IsolatePayload> = {
    [IsolateKeys.AllowReorder]?: boolean;
    [IsolateKeys.Parent]: Nullable<TIsolate>;
    [IsolateKeys.Type]: string;
    [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;
    [IsolateKeys.Data]: DataOnly<P>;
    [IsolateKeys.Status]?: string;
    [IsolateKeys.AbortController]: AbortController;
    children: Nullable<TIsolate[]>;
    key: IsolateKey;
    output: any;
} & UsedFeaturesOnly<P>;
type DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;
type UsedFeaturesOnly<P extends IsolatePayload> = Pick<P, keyof IsolateFeatures>;
declare class Isolate {
    static create<Payload extends IsolatePayload>(type: string, callback: CB, payload?: Maybe<Payload>, key?: IsolateKey): TIsolate<Payload>;
    static isIsolate(node: any): node is TIsolate;
}
type IsolateData = Record<string, any>;
type IsolatePayload = IsolateData & IsolateFeatures;
type IsolateFeatures = {
    [IsolateKeys.AllowReorder]?: boolean;
    [IsolateKeys.Status]?: string;
};
// import { isSameIsolateType } from 'IsolateSelectors';
// I would rather not use `any` here, but instead use `Isolate`.
// The problem is that it breaks the actual implementation of `Isolate` in `IsolateTest`
// As it is not properly extending `Isolate`.
interface IRecociler<I = any> {
    (currentNode: I, historyNode: I): Nullable<I>;
}
declare class Reconciler {
    /**
     * Reconciles the current isolate with the history isolate.
     * If the current isolate is of a different type than the history isolate,
     * the current isolate is returned.
     * Otherwise, the reconciler function is called to determine the next isolate.
     * If the reconciler function returns null or undefined, the base reconciler is used.
     * If no history isolate exists, the current isolate is returned.
     * @param node The current isolate to reconcile.
     * @returns The next isolate after reconciliation.
     */
    static reconcile(node: TIsolate): TIsolate;
    static dropNextNodesOnReorder<I extends TIsolate>(reorderLogic: (newNode: I, prevNode: Maybe<TIsolate>) => boolean, newNode: I, prevNode: Maybe<TIsolate>): boolean;
    static handleIsolateNodeWithKey<I extends TIsolate>(node: TIsolate, 
    // The revoke function allows the caller to revoke the previous node
    revoke: ((node: I) => boolean) | false): TIsolate;
}
declare namespace Walker {
    enum IsolateKeys {
        Type = "$type",
        Keys = "keys",
        Key = "key",
        Parent = "parent",
        Data = "data",
        AllowReorder = "allowReorder",
        Status = "status",
        AbortController = "abortController",
        Children = "children"
    }
    const ExcludedFromDump: Set<IsolateKeys>;
    type IsolateKey = Nullable<string>;
    type TIsolate<P extends IsolatePayload = IsolatePayload> = {
        [IsolateKeys.AllowReorder]?: boolean;
        [IsolateKeys.Parent]: Nullable<TIsolate>;
        [IsolateKeys.Type]: string;
        [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;
        [IsolateKeys.Data]: DataOnly<P>;
        [IsolateKeys.Status]?: string;
        [IsolateKeys.AbortController]: AbortController;
        children: Nullable<TIsolate[]>;
        key: IsolateKey;
        output: any;
    } & UsedFeaturesOnly<P>;
    type DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;
    type UsedFeaturesOnly<P extends IsolatePayload> = Pick<P, keyof IsolateFeatures>;
    class Isolate {
        static create<Payload extends IsolatePayload>(type: string, callback: CB, payload?: Maybe<Payload>, key?: IsolateKey): TIsolate<Payload>;
        static isIsolate(node: any): node is TIsolate;
    }
    type IsolateData = Record<string, any>;
    type IsolatePayload = IsolateData & IsolateFeatures;
    type IsolateFeatures = {
        [IsolateKeys.AllowReorder]?: boolean;
        [IsolateKeys.Status]?: string;
    };
    type VisitOnlyPredicate = (isolate: TIsolate) => boolean;
    // eslint-disable-next-line
    function walk(startNode: TIsolate, callback: (isolate: TIsolate, breakout: CB<void>) => void, visitOnly?: VisitOnlyPredicate): void;
    // This function returns true if the given predicate function returns true for any Isolate object in the tree.
    // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
    function some(startNode: TIsolate, predicate: (node: TIsolate) => boolean, visitOnly?: VisitOnlyPredicate): boolean;
    // This function returns true if the given predicate function returns true for any Isolate object in the tree.
    // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
    function has(startNode: TIsolate, match: VisitOnlyPredicate): boolean;
    // traverses up to a parent node that satisfies the predicate
    // and returns the first direct descendant that satisfies the predicate
    function findClosest<I extends TIsolate = TIsolate>(startNode: TIsolate, predicate: (node: TIsolate) => boolean): Nullable<I>;
    // This function returns the first Isolate object in the tree that satisfies the given predicate function.
    // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
    function find(startNode: TIsolate, predicate: (node: TIsolate) => boolean, visitOnly?: VisitOnlyPredicate): Nullable<TIsolate>;
    // This function returns true if the given predicate function returns true for every Isolate object in the tree.
    // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
    function every(startNode: TIsolate, predicate: (node: TIsolate) => boolean, visitOnly?: VisitOnlyPredicate): boolean;
    // This function removes all Isolate objects in the tree that
    // satisfy the given predicate function and have a parent.
    // If visitOnly is provided, only Isolate objects that satisfy the predicate are visited.
    function pluck(startNode: TIsolate, predicate: (node: TIsolate) => boolean, visitOnly?: VisitOnlyPredicate): void;
    // Returns the closest ancestor Isolate object of the given
    //startNode that satisfies the given predicate function.
    function closest(startNode: TIsolate, predicate: (node: TIsolate) => boolean): Nullable<TIsolate>;
    // This function returns true if the closest ancestor Isolates of the
    // given startNode that satisfies the given predicate function exists.
    function closestExists(startNode: TIsolate, predicate: (node: TIsolate) => boolean): boolean;
}
type CTXType = StateRefType & {
    historyNode: Nullable<TIsolate>;
    runtimeNode: Nullable<TIsolate>;
    runtimeRoot: Nullable<TIsolate>;
    stateRef: StateRefType;
};
type StateRefType = {
    Bus: BusType;
    appData: Record<string, any>;
    historyRoot: TinyState<Nullable<TIsolate>>;
    Reconciler: IRecociler;
};
declare const RuntimeApi: {
    Run: <R>(value: Partial<CTXType>, fn: () => R) => R;
    addNodeToHistory: typeof addNodeToHistory;
    createRef: typeof createRef;
    persist: typeof persist;
    reset: typeof reset;
    useAvailableRoot: typeof useAvailableRoot;
    useCurrentCursor: typeof useCurrentCursor;
    useHistoryRoot: typeof useHistoryRoot;
    useLoadRootNode: typeof useLoadRootNode;
    useXAppData: typeof useXAppData;
};
declare function useXAppData<T = object>(): T;
declare function createRef(Reconciler: IRecociler, setter: DynamicValue<Record<string, any>>): StateRefType;
declare function persist<T extends (...args: any[]) => any>(cb: T): T;
declare function useHistoryRoot(): [
    value: Nullable<TIsolate<{
        [x: string]: any;
    } & {
        allowReorder?: boolean | undefined;
        status?: string | undefined;
    }>>,
    setValue: (next: Nullable<TIsolate<{
        [x: string]: any;
    } & {
        allowReorder?: boolean | undefined;
        status?: string | undefined;
    }>> | import("vest-utils").CB<Nullable<TIsolate<{
        [x: string]: any;
    } & {
        allowReorder?: boolean | undefined;
        status?: string | undefined;
    }>>, [
        prev: Nullable<TIsolate<{
            [x: string]: any;
        } & {
            allowReorder?: boolean | undefined;
            status?: string | undefined;
        }>>
    ]>) => void,
    resetValue: () => void
];
declare function addNodeToHistory(node: TIsolate): void;
declare function useCurrentCursor(): number;
declare function useAvailableRoot<I extends TIsolate = TIsolate>(): I;
declare function reset(): void;
declare function useLoadRootNode(root: TIsolate): void;
declare class IsolateInspector {
    static at(isolate: Nullable<TIsolate>, at: number): Nullable<TIsolate>;
    static cursor(isolate: Nullable<TIsolate>): number;
    static canReorder<I extends TIsolate>(isolate: Nullable<I>): boolean;
    static allowsReorder<I extends Record<any, any>>(isolate: Nullable<I>): boolean;
    static usesKey(isolate: Nullable<TIsolate>): boolean;
    static getChildByKey(isolate: Nullable<TIsolate>, key: string): Nullable<TIsolate>;
}
declare class IsolateMutator {
    static setParent(isolate: TIsolate, parent: Nullable<TIsolate>): TIsolate;
    static saveOutput(isolate: TIsolate, output: any): TIsolate;
    static setKey(isolate: TIsolate, key: Nullable<string>): TIsolate;
    static addChild(isolate: TIsolate, child: TIsolate): void;
    static removeChild(isolate: TIsolate, node: TIsolate): void;
    static addChildKey(isolate: TIsolate, key: string, node: TIsolate): void;
    static slice(isolate: TIsolate, at: number): void;
    static setData(isolate: TIsolate, data: any): void;
    static abort(isolate: TIsolate, reason?: string): void;
}
declare namespace Bus {
    function useBus(): import("vest-utils").BusType;
    /*
    Returns an emitter, but it also has a shortcut for emitting an event immediately
    by passing an event name.
    */
    function useEmit(event?: string, data?: any): (event: string, data?: any) => void;
    function usePrepareEmitter<T = void>(event: string): (arg: T) => void;
}
declare namespace IsolateSelectors {
    enum IsolateKeys {
        Type = "$type",
        Keys = "keys",
        Key = "key",
        Parent = "parent",
        Data = "data",
        AllowReorder = "allowReorder",
        Status = "status",
        AbortController = "abortController",
        Children = "children"
    }
    const ExcludedFromDump: Set<IsolateKeys>;
    type IsolateKey = Nullable<string>;
    type TIsolate<P extends IsolatePayload = IsolatePayload> = {
        [IsolateKeys.AllowReorder]?: boolean;
        [IsolateKeys.Parent]: Nullable<TIsolate>;
        [IsolateKeys.Type]: string;
        [IsolateKeys.Keys]: Nullable<Record<string, TIsolate>>;
        [IsolateKeys.Data]: DataOnly<P>;
        [IsolateKeys.Status]?: string;
        [IsolateKeys.AbortController]: AbortController;
        children: Nullable<TIsolate[]>;
        key: IsolateKey;
        output: any;
    } & UsedFeaturesOnly<P>;
    type DataOnly<P extends IsolatePayload> = Omit<P, keyof IsolateFeatures>;
    type UsedFeaturesOnly<P extends IsolatePayload> = Pick<P, keyof IsolateFeatures>;
    class Isolate {
        static create<Payload extends IsolatePayload>(type: string, callback: CB, payload?: Maybe<Payload>, key?: IsolateKey): TIsolate<Payload>;
        static isIsolate(node: any): node is TIsolate;
    }
    type IsolateData = Record<string, any>;
    type IsolatePayload = IsolateData & IsolateFeatures;
    type IsolateFeatures = {
        [IsolateKeys.AllowReorder]?: boolean;
        [IsolateKeys.Status]?: string;
    };
    function isIsolateType<I extends TIsolate>(node: Maybe<TIsolate>, type: string): node is I;
    function isSameIsolateType<A extends TIsolate, B extends TIsolate>(a: A, b: B): boolean;
    function isSameIsolateIdentity<A extends TIsolate, B extends TIsolate>(a: A, b: B): boolean;
}
declare class IsolateSerializer {
    // eslint-disable-next-line max-statements, complexity, max-lines-per-function
    static deserialize(node: Record<string, any> | TIsolate | string): TIsolate;
    static serialize(isolate: Nullable<TIsolate>): string;
    static validateIsolate(node: Record<string, any> | TIsolate): asserts node is TIsolate;
}
export { RuntimeEvents, IsolateKey, TIsolate, Isolate, Reconciler, IRecociler, Walker, RuntimeApi as VestRuntime, IsolateInspector, IsolateMutator, Bus, IsolateSelectors, IsolateSerializer };
//# sourceMappingURL=vestjs-runtime.d.ts.map