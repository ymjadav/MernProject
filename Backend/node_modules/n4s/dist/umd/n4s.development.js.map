{"version":3,"file":"n4s.development.js","sources":["../../src/runtime/enforceContext.ts","../../src/rules/endsWith.ts","../../src/rules/equals.ts","../../src/rules/greaterThanOrEquals.ts","../../src/rules/inside.ts","../../src/rules/lessThan.ts","../../src/rules/lessThanOrEquals.ts","../../src/rules/isBetween.ts","../../src/rules/isBlank.ts","../../src/rules/isBoolean.ts","../../src/rules/isEven.ts","../../src/rules/isKeyOf.ts","../../src/rules/isNaN.ts","../../src/rules/isNegative.ts","../../src/rules/isNumber.ts","../../src/rules/isOdd.ts","../../src/rules/isString.ts","../../src/rules/isTruthy.ts","../../src/rules/isValueOf.ts","../../src/rules/longerThanOrEquals.ts","../../src/rules/matches.ts","../../src/rules/ruleCondition.ts","../../src/rules/shorterThan.ts","../../src/rules/shorterThanOrEquals.ts","../../src/rules/startsWith.ts","../../src/runtime/rules.ts","../../src/runtime/runtimeRules.ts","../../src/lib/ruleReturn.ts","../../src/lib/transformResult.ts","../../src/runtime/enforceEager.ts","../../src/runtime/genEnforceLazy.ts","../../src/runtime/enforce.ts"],"sourcesContent":["import { createCascade } from 'context';\nimport { assign, Nullable } from 'vest-utils';\n\nexport const ctx = createCascade<CTXType>((ctxRef, parentContext): CTXType => {\n  const base = {\n    value: ctxRef.value,\n    meta: ctxRef.meta || {},\n  };\n\n  if (!parentContext) {\n    return assign(base, {\n      parent: emptyParent,\n    });\n  } else if (ctxRef.set) {\n    return assign(base, {\n      parent: (): EnforceContext => stripContext(parentContext),\n    });\n  }\n\n  return parentContext;\n});\n\nfunction stripContext(ctx: CTXType): EnforceContext {\n  return {\n    value: ctx.value,\n    meta: ctx.meta,\n    parent: ctx.parent,\n  };\n}\n\ntype CTXType = {\n  meta: Record<string, any>;\n  value: any;\n  set?: boolean;\n  parent: () => Nullable<CTXType>;\n};\n\nexport type EnforceContext = Nullable<{\n  meta: Record<string, any>;\n  value: any;\n  parent: () => EnforceContext;\n}>;\n\nfunction emptyParent(): null {\n  return null;\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function endsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.endsWith(arg1);\n}\n\nexport const doesNotEndWith = bindNot(endsWith);\n","import { bindNot } from 'vest-utils';\n\nexport function equals(value: unknown, arg1: unknown): boolean {\n  return value === arg1;\n}\n\nexport const notEquals = bindNot(equals);\n","import { greaterThan, numberEquals } from 'vest-utils';\n\nexport function greaterThanOrEquals(\n  value: string | number,\n  gte: string | number\n): boolean {\n  return numberEquals(value, gte) || greaterThan(value, gte);\n}\n","import { isStringValue as isString, bindNot, isArray } from 'vest-utils';\n\nexport function inside(value: unknown, arg1: string | unknown[]): boolean {\n  if (isArray(arg1)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  // both value and arg1 are strings\n  if (isString(arg1) && isString(value)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  return false;\n}\n\nexport const notInside = bindNot(inside);\n","import { isNumeric } from 'vest-utils';\n\nexport function lessThan(value: string | number, lt: string | number): boolean {\n  return isNumeric(value) && isNumeric(lt) && Number(value) < Number(lt);\n}\n","import { numberEquals } from 'vest-utils';\n\nimport { lessThan } from 'lessThan';\n\nexport function lessThanOrEquals(\n  value: string | number,\n  lte: string | number\n): boolean {\n  return numberEquals(value, lte) || lessThan(value, lte);\n}\n","import { bindNot } from 'vest-utils';\n\nimport { greaterThanOrEquals as gte } from 'greaterThanOrEquals';\nimport { lessThanOrEquals as lte } from 'lessThanOrEquals';\n\nexport function isBetween(\n  value: number | string,\n  min: number | string,\n  max: number | string\n): boolean {\n  return gte(value, min) && lte(value, max);\n}\n\nexport const isNotBetween = bindNot(isBetween);\n","import { isStringValue, bindNot, isNullish, BlankValue } from 'vest-utils';\n\nexport function isBlank(value: unknown): value is BlankValue {\n  return isNullish(value) || (isStringValue(value) && !value.trim());\n}\n\nexport const isNotBlank = bindNot(isBlank);\n","import { bindNot, isBoolean } from 'vest-utils';\n\nexport const isNotBoolean = bindNot(isBoolean);\nexport { isBoolean };\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n\n/**\n * Validates that a given value is an even number\n */\nexport const isEven = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 === 0;\n  }\n  return false;\n};\n","import { bindNot } from 'vest-utils';\n\nexport function isKeyOf(key: string | symbol | number, obj: any): boolean {\n  return key in obj;\n}\n\nexport const isNotKeyOf = bindNot(isKeyOf);\n","import { bindNot } from 'vest-utils';\n\nexport function isNaN(value: unknown): boolean {\n  return Number.isNaN(value);\n}\n\nexport const isNotNaN = bindNot(isNaN);\n","import { lessThan } from 'lessThan';\n\nexport function isNegative(value: number | string): boolean {\n  return lessThan(value, 0);\n}\n","import { bindNot } from 'vest-utils';\n\nexport function isNumber(value: unknown): value is number {\n  return Boolean(typeof value === 'number');\n}\n\nexport const isNotNumber = bindNot(isNumber);\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n/**\n * Validates that a given value is an odd number\n */\nexport const isOdd = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 !== 0;\n  }\n\n  return false;\n};\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport const isNotString = bindNot(isString);\nexport { isString };\n","import { bindNot } from 'vest-utils';\n\nexport function isTruthy(value: unknown): boolean {\n  return !!value;\n}\n\nexport const isFalsy = bindNot(isTruthy);\n","import { bindNot, isNullish } from 'vest-utils';\n\nexport function isValueOf(value: any, objectToCheck: any): boolean {\n  if (isNullish(objectToCheck)) {\n    return false;\n  }\n\n  for (const key in objectToCheck) {\n    if (objectToCheck[key] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport const isNotValueOf = bindNot(isValueOf);\n","import { greaterThanOrEquals } from 'greaterThanOrEquals';\n\nexport function longerThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return greaterThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function matches(value: string, regex: RegExp | string): boolean {\n  if (regex instanceof RegExp) {\n    return regex.test(value);\n  } else if (isString(regex)) {\n    return new RegExp(regex).test(value);\n  }\n  return false;\n}\n\nexport const notMatches = bindNot(matches);\n","import type { RuleReturn } from 'ruleReturn';\n\nexport function condition(\n  value: any,\n  callback: (value: any) => RuleReturn\n): RuleReturn {\n  try {\n    return callback(value);\n  } catch {\n    return false;\n  }\n}\n","import { lessThan } from 'lessThan';\n\nexport function shorterThan(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThan(value.length, arg1);\n}\n","import { lessThanOrEquals } from 'lessThanOrEquals';\n\nexport function shorterThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function startsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.startsWith(arg1);\n}\n\nexport const doesNotStartWith = bindNot(startsWith);\n","import {\n  greaterThan,\n  isNull,\n  isNotNull,\n  isNullish,\n  isNotNullish,\n  isNumeric,\n  isNotNumeric,\n  isUndefined,\n  isNotUndefined,\n  lengthEquals,\n  lengthNotEquals,\n  longerThan,\n  numberEquals,\n  numberNotEquals,\n  isArray,\n  isNotArray,\n  isPositive,\n  isEmpty,\n  isNotEmpty,\n} from 'vest-utils';\n\nimport { endsWith, doesNotEndWith } from 'endsWith';\nimport { equals, notEquals } from 'equals';\nimport { greaterThanOrEquals } from 'greaterThanOrEquals';\nimport { inside, notInside } from 'inside';\nimport { isBetween, isNotBetween } from 'isBetween';\nimport { isBlank, isNotBlank } from 'isBlank';\nimport { isBoolean, isNotBoolean } from 'isBoolean';\nimport { isEven } from 'isEven';\nimport { isKeyOf, isNotKeyOf } from 'isKeyOf';\nimport { isNaN, isNotNaN } from 'isNaN';\nimport { isNegative } from 'isNegative';\nimport { isNumber, isNotNumber } from 'isNumber';\nimport { isOdd } from 'isOdd';\nimport { isString, isNotString } from 'isString';\nimport { isTruthy, isFalsy } from 'isTruthy';\nimport { isValueOf, isNotValueOf } from 'isValueOf';\nimport { lessThan } from 'lessThan';\nimport { lessThanOrEquals } from 'lessThanOrEquals';\nimport { longerThanOrEquals } from 'longerThanOrEquals';\nimport { matches, notMatches } from 'matches';\nimport { condition } from 'ruleCondition';\nimport { shorterThan } from 'shorterThan';\nimport { shorterThanOrEquals } from 'shorterThanOrEquals';\nimport { startsWith, doesNotStartWith } from 'startsWith';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, max-lines-per-function\nexport default function rules() {\n  return {\n    condition,\n    doesNotEndWith,\n    doesNotStartWith,\n    endsWith,\n    equals,\n    greaterThan,\n    greaterThanOrEquals,\n    gt: greaterThan,\n    gte: greaterThanOrEquals,\n    inside,\n    isArray,\n    isBetween,\n    isBlank,\n    isBoolean,\n    isEmpty,\n    isEven,\n    isFalsy,\n    isKeyOf,\n    isNaN,\n    isNegative,\n    isNotArray,\n    isNotBetween,\n    isNotBlank,\n    isNotBoolean,\n    isNotEmpty,\n    isNotKeyOf,\n    isNotNaN,\n    isNotNull,\n    isNotNullish,\n    isNotNumber,\n    isNotNumeric,\n    isNotString,\n    isNotUndefined,\n    isNotValueOf,\n    isNull,\n    isNullish,\n    isNumber,\n    isNumeric,\n    isOdd,\n    isPositive,\n    isString,\n    isTruthy,\n    isUndefined,\n    isValueOf,\n    lengthEquals,\n    lengthNotEquals,\n    lessThan,\n    lessThanOrEquals,\n    longerThan,\n    longerThanOrEquals,\n    lt: lessThan,\n    lte: lessThanOrEquals,\n    matches,\n    notEquals,\n    notInside,\n    notMatches,\n    numberEquals,\n    numberNotEquals,\n    shorterThan,\n    shorterThanOrEquals,\n    startsWith,\n  };\n}\n","import type { DropFirst } from 'vest-utils';\n\nimport type { RuleReturn } from 'ruleReturn';\nimport rules from 'rules';\n\nexport type Args = any[];\n\nexport type RuleValue = any;\n\nexport type RuleBase = (value: RuleValue, ...args: Args) => RuleReturn;\n\nexport type Rule = Record<string, RuleBase>;\n\ntype BaseRules = typeof baseRules;\ntype KBaseRules = keyof BaseRules;\n\nconst baseRules = rules();\n\nfunction getRule(ruleName: string): RuleBase {\n  return baseRules[ruleName as KBaseRules];\n}\n\nexport { baseRules, getRule };\n\ntype Rules<E = Record<string, unknown>> = n4s.EnforceCustomMatchers<\n  Rules<E> & E\n> &\n  Record<string, (...args: Args) => Rules<E> & E> & {\n    [P in KBaseRules]: (\n      ...args: DropFirst<Parameters<BaseRules[P]>> | Args\n    ) => Rules<E> & E;\n  };\n\n/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-empty-interface */\ndeclare global {\n  namespace n4s {\n    interface IRules<E> extends Rules<E> {}\n  }\n}\n","import type { Stringable } from 'vest-utils';\nimport { defaultTo } from 'vest-utils';\n\nexport default function ruleReturn(\n  pass: boolean,\n  message?: string\n): RuleDetailedResult {\n  const output: RuleDetailedResult = { pass };\n\n  if (message) {\n    output.message = message;\n  }\n\n  return output;\n}\n\nexport function failing(): RuleDetailedResult {\n  return ruleReturn(false);\n}\n\nexport function passing(): RuleDetailedResult {\n  return ruleReturn(true);\n}\n\nexport function defaultToFailing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, failing());\n}\n\nexport function defaultToPassing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, passing());\n}\n\nexport type RuleReturn =\n  | boolean\n  | {\n      pass: boolean;\n      message?: Stringable;\n    };\n\nexport type RuleDetailedResult = { pass: boolean; message?: string };\n","import { invariant, optionalFunctionValue, isBoolean } from 'vest-utils';\n\nimport ruleReturn, { RuleReturn, RuleDetailedResult } from 'ruleReturn';\nimport type { RuleValue, Args } from 'runtimeRules';\n\n/**\n * Transform the result of a rule into a standard format\n */\nexport function transformResult(\n  result: RuleReturn,\n  ruleName: string,\n  value: RuleValue,\n  ...args: Args\n): RuleDetailedResult {\n  validateResult(result);\n\n  // if result is boolean\n  if (isBoolean(result)) {\n    return ruleReturn(result);\n  }\n  return ruleReturn(\n    result.pass,\n    optionalFunctionValue(result.message, ruleName, value, ...args)\n  );\n}\n\nfunction validateResult(result: RuleReturn): void {\n  // if result is boolean, or if result.pass is boolean\n  invariant(\n    isBoolean(result) || (result && isBoolean(result.pass)),\n    'Incorrect return value for rule: ' + JSON.stringify(result)\n  );\n}\n","import { invariant, StringObject, isNullish, Maybe } from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport { getRule, RuleValue, Args, RuleBase } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\ntype IRules = n4s.IRules<Record<string, any> & EnforceEagerReturn>;\ntype TModifiers = {\n  message: (input: string) => EnforceEagerReturn;\n};\n\ntype EnforceEagerReturn = IRules &\n  TModifiers & {\n    pass: boolean;\n  };\n\n// eslint-disable-next-line max-lines-per-function\nexport default function enforceEager(value: RuleValue): EnforceEagerReturn {\n  const target = {\n    message,\n    pass: false,\n  } as EnforceEagerReturn;\n  let customMessage: Maybe<string> = undefined;\n\n  // We create a proxy intercepting access to the target object (which is empty).\n  const proxy: EnforceEagerReturn = new Proxy(target, {\n    get: (_, key: string) => {\n      // On property access, we identify if it is a rule or not.\n      const rule = getRule(key);\n\n      // If it is a rule, we wrap it with `genRuleCall` that adds the base enforce behavior\n      if (rule) {\n        return genRuleCall(proxy, rule, key);\n      }\n      return target[key];\n    },\n  });\n\n  return proxy;\n\n  // This function is used to wrap a rule with the base enforce behavior\n  // It takes the target object, the rule function, and the rule name\n  // It then returns the rule, in a manner that can be used by enforce\n  function genRuleCall(\n    target: EnforceEagerReturn,\n    rule: RuleBase,\n    ruleName: string,\n  ) {\n    return function ruleCall(...args: Args): EnforceEagerReturn {\n      // Order of operation:\n      // 1. Create a context with the value being enforced\n      // 2. Call the rule within the context, and pass over the arguments passed to it\n      // 3. Transform the result to the correct output format\n      const transformedResult = ctx.run({ value }, () => {\n        return transformResult(rule(value, ...args), ruleName, value, ...args);\n      });\n\n      function enforceMessage() {\n        if (!isNullish(customMessage)) return StringObject(customMessage);\n        if (isNullish(transformedResult.message)) {\n          return `enforce/${ruleName} failed with ${JSON.stringify(value)}`;\n        }\n        return StringObject(transformedResult.message);\n      }\n\n      // On rule failure (the result is false), we either throw an error\n      // or throw a string value if the rule has a message defined in it.\n      invariant(transformedResult.pass, enforceMessage());\n\n      // This is not really needed because it will always be true\n      // As we're throwing an error on failure\n      // but it is here so that users have a sense of what is happening\n      // when they try to log the result of enforce and not just see a proxy object\n      target.pass = transformedResult.pass;\n\n      return target;\n    };\n  }\n\n  function message(input: string): EnforceEagerReturn {\n    customMessage = input;\n    return proxy;\n  }\n}\n\nexport type EnforceEager = typeof enforceEager;\n","import {\n  mapFirst,\n  optionalFunctionValue,\n  CB,\n  Stringable,\n  Maybe,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport ruleReturn, { defaultToPassing, RuleDetailedResult } from 'ruleReturn';\nimport { RuleValue, Args, getRule } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\n// eslint-disable-next-line max-lines-per-function\nexport default function genEnforceLazy(key: string) {\n  const registeredRules: RegisteredRules = [];\n  let lazyMessage: Maybe<LazyMessage>;\n\n  return addLazyRule(key);\n\n  // eslint-disable-next-line max-lines-per-function\n  function addLazyRule(ruleName: string) {\n    // eslint-disable-next-line max-lines-per-function\n    return (...args: Args): Lazy => {\n      const rule = getRule(ruleName);\n\n      registeredRules.push((value: RuleValue) =>\n        transformResult(rule(value, ...args), ruleName, value, ...args)\n      );\n\n      let proxy = {\n        run: (value: RuleValue): RuleDetailedResult => {\n          return defaultToPassing(\n            mapFirst(registeredRules, (rule, breakout) => {\n              const res = ctx.run({ value }, () => rule(value));\n\n              breakout(\n                !res.pass,\n                ruleReturn(\n                  !!res.pass,\n                  optionalFunctionValue(lazyMessage, value, res.message) ??\n                    res.message\n                )\n              );\n            })\n          );\n        },\n        test: (value: RuleValue): boolean => proxy.run(value).pass,\n        message: (message: Stringable): Lazy => {\n          if (message) {\n            lazyMessage = message;\n          }\n\n          return proxy;\n        },\n      } as Lazy;\n\n      // reassigning the proxy here is not pretty\n      // but it's a cleaner way of getting `run` and `test` for free\n      proxy = new Proxy(proxy, {\n        get: (target, key: string) => {\n          if (getRule(key)) {\n            return addLazyRule(key);\n          }\n\n          return target[key]; // already has `run` and `test` on it\n        },\n      });\n      return proxy;\n    };\n  }\n}\n\nexport type LazyRules = n4s.IRules<LazyRuleMethods>;\n\nexport type Lazy = LazyRules &\n  LazyRuleMethods &\n  // This is a \"catch all\" hack to make TS happy while not\n  // losing type hints\n  Record<string, CB>;\n\ntype LazyRuleMethods = LazyRuleRunners & {\n  message: (message: LazyMessage) => Lazy;\n};\n\nexport type LazyRuleRunners = {\n  test: (value: unknown) => boolean;\n  run: (value: unknown) => RuleDetailedResult;\n};\n\nexport type ComposeResult = LazyRuleRunners & ((value: any) => void);\n\ntype RegisteredRules = Array<(value: RuleValue) => RuleDetailedResult>;\ntype LazyMessage = DynamicValue<\n  string,\n  [value: unknown, originalMessage?: Stringable]\n>;\n","import { assign } from 'vest-utils';\n\nimport { ctx, EnforceContext } from 'enforceContext';\nimport enforceEager, { EnforceEager } from 'enforceEager';\nimport genEnforceLazy, { LazyRules } from 'genEnforceLazy';\nimport { Rule, baseRules, getRule } from 'runtimeRules';\n/**\n * Enforce is quite complicated, I want to explain it in detail.\n * It is dynamic in nature, so a lot of proxy objects are involved.\n *\n * Enforce has two main interfaces\n * 1. eager\n * 2. lazy\n *\n * The eager interface is the most commonly used, and the easier to understand.\n * It throws an error when a rule is not satisfied.\n * The eager interface is declared in enforceEager.ts and it is quite simple to understand.\n * enforce is called with a value, and the return value is a proxy object that points back to all the rules.\n * When a rule is called, the value is mapped as its first argument, and if the rule passes, the same\n * proxy object is returned. Otherwise, an error is thrown.\n *\n * The lazy interface works quite differently. It is declared in genEnforceLazy.ts.\n * Rather than calling enforce directly, the lazy interface has all the rules as \"methods\" (only by proxy).\n * Calling the first function in the chain will initialize an array of calls. It stores the different rule calls\n * and the parameters passed to them. None of the rules are called yet.\n * The rules are only invoked in sequence once either of these chained functions are called:\n * 1. test(value)\n * 2. run(value)\n *\n * Calling run or test will call all the rules in sequence, with the difference that test will only return a boolean value,\n * while run will return an object with the validation result and an optional message created by the rule.\n */\n\nfunction genEnforce(): Enforce {\n  const target = {\n    context: () => ctx.useX(),\n    extend: (customRules: Rule) => {\n      assign(baseRules, customRules);\n    },\n  } as Enforce;\n\n  return new Proxy(assign(enforceEager, target) as Enforce, {\n    get: (target: Enforce, key: string) => {\n      if (key in target) {\n        return target[key];\n      }\n\n      if (!getRule(key)) {\n        return;\n      }\n\n      // Only on the first rule access - start the chain of calls\n      return genEnforceLazy(key);\n    },\n  });\n}\n\nexport const enforce = genEnforce();\n\ntype Enforce = EnforceMethods & LazyRules & EnforceEager;\n\ntype EnforceMethods = {\n  context: () => EnforceContext;\n  extend: (customRules: Rule) => void;\n};\n"],"names":["createCascade","assign","isString","bindNot","numberEquals","greaterThan","isArray","isNumeric","gte","lte","isNullish","isStringValue","isBoolean","isEmpty","isNotArray","isNotEmpty","isNotNull","isNotNullish","isNotNumeric","isNotUndefined","isNull","isPositive","isUndefined","lengthEquals","lengthNotEquals","longerThan","numberNotEquals","defaultTo","optionalFunctionValue","invariant","StringObject","mapFirst"],"mappings":";;;;;;AAGa,QAAA,GAAG,GAAGA,qBAAa,CAAU,CAAC,MAAM,EAAE,aAAa,KAAa;EAC3E,IAAA,MAAM,IAAI,GAAG;UACX,KAAK,EAAE,MAAM,CAAC,KAAK;EACnB,QAAA,IAAI,EAAE,MAAM,CAAC,IAAI,IAAI,EAAE;OACxB,CAAC;MAEF,IAAI,CAAC,aAAa,EAAE;UAClB,OAAOC,gBAAM,CAAC,IAAI,EAAE;EAClB,YAAA,MAAM,EAAE,WAAW;EACpB,SAAA,CAAC,CAAC;EACJ,KAAA;WAAM,IAAI,MAAM,CAAC,GAAG,EAAE;UACrB,OAAOA,gBAAM,CAAC,IAAI,EAAE;EAClB,YAAA,MAAM,EAAE,MAAsB,YAAY,CAAC,aAAa,CAAC;EAC1D,SAAA,CAAC,CAAC;EACJ,KAAA;EAED,IAAA,OAAO,aAAa,CAAC;EACvB,CAAC,EAAE;EAEH,SAAS,YAAY,CAAC,GAAY,EAAA;MAChC,OAAO;UACL,KAAK,EAAE,GAAG,CAAC,KAAK;UAChB,IAAI,EAAE,GAAG,CAAC,IAAI;UACd,MAAM,EAAE,GAAG,CAAC,MAAM;OACnB,CAAC;EACJ,CAAC;EAeD,SAAS,WAAW,GAAA;EAClB,IAAA,OAAO,IAAI,CAAC;EACd;;EC3CgB,SAAA,QAAQ,CAAC,KAAa,EAAE,IAAY,EAAA;EAClD,IAAA,OAAOC,uBAAQ,CAAC,KAAK,CAAC,IAAIA,uBAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;EACnE,CAAC;EAEM,MAAM,cAAc,GAAGC,iBAAO,CAAC,QAAQ,CAAC;;ECJ/B,SAAA,MAAM,CAAC,KAAc,EAAE,IAAa,EAAA;MAClD,OAAO,KAAK,KAAK,IAAI,CAAC;EACxB,CAAC;EAEM,MAAM,SAAS,GAAGA,iBAAO,CAAC,MAAM,CAAC;;ECJxB,SAAA,mBAAmB,CACjC,KAAsB,EACtB,GAAoB,EAAA;EAEpB,IAAA,OAAOC,sBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,IAAIC,qBAAW,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;EAC7D;;ECLgB,SAAA,MAAM,CAAC,KAAc,EAAE,IAAwB,EAAA;EAC7D,IAAA,IAAIC,iBAAO,CAAC,IAAI,CAAC,EAAE;UACjB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;EACnC,KAAA;;MAGD,IAAIJ,uBAAQ,CAAC,IAAI,CAAC,IAAIA,uBAAQ,CAAC,KAAK,CAAC,EAAE;UACrC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;EACnC,KAAA;EAED,IAAA,OAAO,KAAK,CAAC;EACf,CAAC;EAEM,MAAM,SAAS,GAAGC,iBAAO,CAAC,MAAM,CAAC;;ECbxB,SAAA,QAAQ,CAAC,KAAsB,EAAE,EAAmB,EAAA;EAClE,IAAA,OAAOI,mBAAS,CAAC,KAAK,CAAC,IAAIA,mBAAS,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;EACzE;;ECAgB,SAAA,gBAAgB,CAC9B,KAAsB,EACtB,GAAoB,EAAA;EAEpB,IAAA,OAAOH,sBAAY,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,QAAQ,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;EAC1D;;WCJgB,SAAS,CACvB,KAAsB,EACtB,GAAoB,EACpB,GAAoB,EAAA;EAEpB,IAAA,OAAOI,mBAAG,CAAC,KAAK,EAAE,GAAG,CAAC,IAAIC,gBAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;EAC5C,CAAC;EAEM,MAAM,YAAY,GAAGN,iBAAO,CAAC,SAAS,CAAC;;ECXxC,SAAU,OAAO,CAAC,KAAc,EAAA;EACpC,IAAA,OAAOO,mBAAS,CAAC,KAAK,CAAC,KAAKC,uBAAa,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;EACrE,CAAC;EAEM,MAAM,UAAU,GAAGR,iBAAO,CAAC,OAAO,CAAC;;ECJnC,MAAM,YAAY,GAAGA,iBAAO,CAACS,mBAAS,CAAC;;ECE9C;;EAEG;EACI,MAAM,MAAM,GAAG,CAAC,KAAgB,KAAa;EAClD,IAAA,IAAIL,mBAAS,CAAC,KAAK,CAAC,EAAE;EACpB,QAAA,OAAO,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;EACxB,KAAA;EACD,IAAA,OAAO,KAAK,CAAC;EACf,CAAC;;ECVe,SAAA,OAAO,CAAC,GAA6B,EAAE,GAAQ,EAAA;MAC7D,OAAO,GAAG,IAAI,GAAG,CAAC;EACpB,CAAC;EAEM,MAAM,UAAU,GAAGJ,iBAAO,CAAC,OAAO,CAAC;;ECJpC,SAAU,KAAK,CAAC,KAAc,EAAA;EAClC,IAAA,OAAO,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;EAC7B,CAAC;EAEM,MAAM,QAAQ,GAAGA,iBAAO,CAAC,KAAK,CAAC;;ECJhC,SAAU,UAAU,CAAC,KAAsB,EAAA;EAC/C,IAAA,OAAO,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;EAC5B;;ECFM,SAAU,QAAQ,CAAC,KAAc,EAAA;EACrC,IAAA,OAAO,OAAO,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC;EAC5C,CAAC;EAEM,MAAM,WAAW,GAAGA,iBAAO,CAAC,QAAQ,CAAC;;ECH5C;;EAEG;EACI,MAAM,KAAK,GAAG,CAAC,KAAgB,KAAa;EACjD,IAAA,IAAII,mBAAS,CAAC,KAAK,CAAC,EAAE;EACpB,QAAA,OAAO,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;EACxB,KAAA;EAED,IAAA,OAAO,KAAK,CAAC;EACf,CAAC;;ECVM,MAAM,WAAW,GAAGJ,iBAAO,CAACD,uBAAQ,CAAC;;ECAtC,SAAU,QAAQ,CAAC,KAAc,EAAA;MACrC,OAAO,CAAC,CAAC,KAAK,CAAC;EACjB,CAAC;EAEM,MAAM,OAAO,GAAGC,iBAAO,CAAC,QAAQ,CAAC;;ECJxB,SAAA,SAAS,CAAC,KAAU,EAAE,aAAkB,EAAA;EACtD,IAAA,IAAIO,mBAAS,CAAC,aAAa,CAAC,EAAE;EAC5B,QAAA,OAAO,KAAK,CAAC;EACd,KAAA;EAED,IAAA,KAAK,MAAM,GAAG,IAAI,aAAa,EAAE;EAC/B,QAAA,IAAI,aAAa,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE;EAChC,YAAA,OAAO,IAAI,CAAC;EACb,SAAA;EACF,KAAA;EAED,IAAA,OAAO,KAAK,CAAC;EACf,CAAC;EACM,MAAM,YAAY,GAAGP,iBAAO,CAAC,SAAS,CAAC;;ECb9B,SAAA,kBAAkB,CAChC,KAAyB,EACzB,IAAqB,EAAA;MAErB,OAAO,mBAAmB,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;EACjD;;ECLgB,SAAA,OAAO,CAAC,KAAa,EAAE,KAAsB,EAAA;MAC3D,IAAI,KAAK,YAAY,MAAM,EAAE;EAC3B,QAAA,OAAO,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EAC1B,KAAA;EAAM,SAAA,IAAID,uBAAQ,CAAC,KAAK,CAAC,EAAE;UAC1B,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EACtC,KAAA;EACD,IAAA,OAAO,KAAK,CAAC;EACf,CAAC;EAEM,MAAM,UAAU,GAAGC,iBAAO,CAAC,OAAO,CAAC;;ECT1B,SAAA,SAAS,CACvB,KAAU,EACV,QAAoC,EAAA;MAEpC,IAAI;EACF,QAAA,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC;EACxB,KAAA;MAAC,OAAM,EAAA,EAAA;EACN,QAAA,OAAO,KAAK,CAAC;EACd,KAAA;EACH;;ECTgB,SAAA,WAAW,CACzB,KAAyB,EACzB,IAAqB,EAAA;MAErB,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;EACtC;;ECLgB,SAAA,mBAAmB,CACjC,KAAyB,EACzB,IAAqB,EAAA;MAErB,OAAO,gBAAgB,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;EAC9C;;ECLgB,SAAA,UAAU,CAAC,KAAa,EAAE,IAAY,EAAA;EACpD,IAAA,OAAOD,uBAAQ,CAAC,KAAK,CAAC,IAAIA,uBAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;EACrE,CAAC;EAEM,MAAM,gBAAgB,GAAGC,iBAAO,CAAC,UAAU,CAAC;;ECyCnD;EACc,SAAU,KAAK,GAAA;MAC3B,OAAO;UACL,SAAS;UACT,cAAc;UACd,gBAAgB;UAChB,QAAQ;UACR,MAAM;uBACNE,qBAAW;UACX,mBAAmB;EACnB,QAAA,EAAE,EAAEA,qBAAW;EACf,QAAA,GAAG,EAAE,mBAAmB;UACxB,MAAM;mBACNC,iBAAO;UACP,SAAS;UACT,OAAO;qBACPM,mBAAS;mBACTC,iBAAO;UACP,MAAM;UACN,OAAO;UACP,OAAO;UACP,KAAK;UACL,UAAU;sBACVC,oBAAU;UACV,YAAY;UACZ,UAAU;UACV,YAAY;sBACZC,oBAAU;UACV,UAAU;UACV,QAAQ;qBACRC,mBAAS;wBACTC,sBAAY;UACZ,WAAW;wBACXC,sBAAY;UACZ,WAAW;0BACXC,wBAAc;UACd,YAAY;kBACZC,gBAAM;qBACNV,mBAAS;UACT,QAAQ;qBACRH,mBAAS;UACT,KAAK;sBACLc,oBAAU;oBACVnB,uBAAQ;UACR,QAAQ;uBACRoB,qBAAW;UACX,SAAS;wBACTC,sBAAY;2BACZC,yBAAe;UACf,QAAQ;UACR,gBAAgB;sBAChBC,oBAAU;UACV,kBAAkB;EAClB,QAAA,EAAE,EAAE,QAAQ;EACZ,QAAA,GAAG,EAAE,gBAAgB;UACrB,OAAO;UACP,SAAS;UACT,SAAS;UACT,UAAU;wBACVrB,sBAAY;2BACZsB,yBAAe;UACf,WAAW;UACX,mBAAmB;UACnB,UAAU;OACX,CAAC;EACJ;;EChGA,MAAM,SAAS,GAAG,KAAK,EAAE,CAAC;EAE1B,SAAS,OAAO,CAAC,QAAgB,EAAA;EAC/B,IAAA,OAAO,SAAS,CAAC,QAAsB,CAAC,CAAC;EAC3C;;ECjBc,SAAU,UAAU,CAChC,IAAa,EACb,OAAgB,EAAA;EAEhB,IAAA,MAAM,MAAM,GAAuB,EAAE,IAAI,EAAE,CAAC;EAE5C,IAAA,IAAI,OAAO,EAAE;EACX,QAAA,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;EAC1B,KAAA;EAED,IAAA,OAAO,MAAM,CAAC;EAChB,CAAC;WAMe,OAAO,GAAA;EACrB,IAAA,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;EAC1B,CAAC;EAQK,SAAU,gBAAgB,CAC9B,QAAgD,EAAA;EAEhD,IAAA,OAAOC,mBAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC;EACxC;;EC7BA;;EAEG;EACG,SAAU,eAAe,CAC7B,MAAkB,EAClB,QAAgB,EAChB,KAAgB,EAChB,GAAG,IAAU,EAAA;MAEb,cAAc,CAAC,MAAM,CAAC,CAAC;;EAGvB,IAAA,IAAIf,mBAAS,CAAC,MAAM,CAAC,EAAE;EACrB,QAAA,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC;EAC3B,KAAA;MACD,OAAO,UAAU,CACf,MAAM,CAAC,IAAI,EACXgB,+BAAqB,CAAC,MAAM,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAChE,CAAC;EACJ,CAAC;EAED,SAAS,cAAc,CAAC,MAAkB,EAAA;;MAExCC,mBAAS,CACPjB,mBAAS,CAAC,MAAM,CAAC,KAAK,MAAM,IAAIA,mBAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EACvD,mCAAmC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAC7D,CAAC;EACJ;;EChBA;EACwB,SAAA,YAAY,CAAC,KAAgB,EAAA;EACnD,IAAA,MAAM,MAAM,GAAG;UACb,OAAO;EACP,QAAA,IAAI,EAAE,KAAK;OACU,CAAC;MACxB,IAAI,aAAa,GAAkB,SAAS,CAAC;;EAG7C,IAAA,MAAM,KAAK,GAAuB,IAAI,KAAK,CAAC,MAAM,EAAE;EAClD,QAAA,GAAG,EAAE,CAAC,CAAC,EAAE,GAAW,KAAI;;EAEtB,YAAA,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;;EAG1B,YAAA,IAAI,IAAI,EAAE;kBACR,OAAO,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;EACtC,aAAA;EACD,YAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;WACpB;EACF,KAAA,CAAC,CAAC;EAEH,IAAA,OAAO,KAAK,CAAC;;;;EAKb,IAAA,SAAS,WAAW,CAClB,MAA0B,EAC1B,IAAc,EACd,QAAgB,EAAA;EAEhB,QAAA,OAAO,SAAS,QAAQ,CAAC,GAAG,IAAU,EAAA;;;;;cAKpC,MAAM,iBAAiB,GAAG,GAAG,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,MAAK;EAChD,gBAAA,OAAO,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;EACzE,aAAC,CAAC,CAAC;EAEH,YAAA,SAAS,cAAc,GAAA;EACrB,gBAAA,IAAI,CAACF,mBAAS,CAAC,aAAa,CAAC;EAAE,oBAAA,OAAOoB,sBAAY,CAAC,aAAa,CAAC,CAAC;EAClE,gBAAA,IAAIpB,mBAAS,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE;sBACxC,OAAO,CAAA,QAAA,EAAW,QAAQ,CAAA,aAAA,EAAgB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA,CAAE,CAAC;EACnE,iBAAA;EACD,gBAAA,OAAOoB,sBAAY,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;eAChD;;;cAIDD,mBAAS,CAAC,iBAAiB,CAAC,IAAI,EAAE,cAAc,EAAE,CAAC,CAAC;;;;;EAMpD,YAAA,MAAM,CAAC,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC;EAErC,YAAA,OAAO,MAAM,CAAC;EAChB,SAAC,CAAC;OACH;MAED,SAAS,OAAO,CAAC,KAAa,EAAA;UAC5B,aAAa,GAAG,KAAK,CAAC;EACtB,QAAA,OAAO,KAAK,CAAC;OACd;EACH;;ECrEA;EACwB,SAAA,cAAc,CAAC,GAAW,EAAA;MAChD,MAAM,eAAe,GAAoB,EAAE,CAAC;EAC5C,IAAA,IAAI,WAA+B,CAAC;EAEpC,IAAA,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;;MAGxB,SAAS,WAAW,CAAC,QAAgB,EAAA;;EAEnC,QAAA,OAAO,CAAC,GAAG,IAAU,KAAU;EAC7B,YAAA,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;cAE/B,eAAe,CAAC,IAAI,CAAC,CAAC,KAAgB,KACpC,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAChE,CAAC;EAEF,YAAA,IAAI,KAAK,GAAG;EACV,gBAAA,GAAG,EAAE,CAAC,KAAgB,KAAwB;sBAC5C,OAAO,gBAAgB,CACrBE,kBAAQ,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,QAAQ,KAAI;;EAC3C,wBAAA,MAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;EAElD,wBAAA,QAAQ,CACN,CAAC,GAAG,CAAC,IAAI,EACT,UAAU,CACR,CAAC,CAAC,GAAG,CAAC,IAAI,EACV,CAAA,EAAA,GAAAH,+BAAqB,CAAC,WAAW,EAAE,KAAK,EAAE,GAAG,CAAC,OAAO,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GACpD,GAAG,CAAC,OAAO,CACd,CACF,CAAC;uBACH,CAAC,CACH,CAAC;mBACH;EACD,gBAAA,IAAI,EAAE,CAAC,KAAgB,KAAc,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI;EAC1D,gBAAA,OAAO,EAAE,CAAC,OAAmB,KAAU;EACrC,oBAAA,IAAI,OAAO,EAAE;0BACX,WAAW,GAAG,OAAO,CAAC;EACvB,qBAAA;EAED,oBAAA,OAAO,KAAK,CAAC;mBACd;eACM,CAAC;;;EAIV,YAAA,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE;EACvB,gBAAA,GAAG,EAAE,CAAC,MAAM,EAAE,GAAW,KAAI;EAC3B,oBAAA,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;EAChB,wBAAA,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;EACzB,qBAAA;EAED,oBAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;mBACpB;EACF,aAAA,CAAC,CAAC;EACH,YAAA,OAAO,KAAK,CAAC;EACf,SAAC,CAAC;OACH;EACH;;EClEA;;;;;;;;;;;;;;;;;;;;;;;;;EAyBG;EAEH,SAAS,UAAU,GAAA;EACjB,IAAA,MAAM,MAAM,GAAG;EACb,QAAA,OAAO,EAAE,MAAM,GAAG,CAAC,IAAI,EAAE;EACzB,QAAA,MAAM,EAAE,CAAC,WAAiB,KAAI;EAC5B,YAAA3B,gBAAM,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;WAChC;OACS,CAAC;MAEb,OAAO,IAAI,KAAK,CAACA,gBAAM,CAAC,YAAY,EAAE,MAAM,CAAY,EAAE;EACxD,QAAA,GAAG,EAAE,CAAC,MAAe,EAAE,GAAW,KAAI;cACpC,IAAI,GAAG,IAAI,MAAM,EAAE;EACjB,gBAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;EACpB,aAAA;EAED,YAAA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;kBACjB,OAAO;EACR,aAAA;;EAGD,YAAA,OAAO,cAAc,CAAC,GAAG,CAAC,CAAC;WAC5B;EACF,KAAA,CAAC,CAAC;EACL,CAAC;AAEY,QAAA,OAAO,GAAG,UAAU;;;;;;;;;"}