{"version":3,"file":"n4s.production.js","sources":["../../src/runtime/enforceContext.ts","../../src/rules/endsWith.ts","../../src/rules/equals.ts","../../src/rules/greaterThanOrEquals.ts","../../src/rules/inside.ts","../../src/rules/lessThan.ts","../../src/rules/lessThanOrEquals.ts","../../src/rules/isBetween.ts","../../src/rules/isBlank.ts","../../src/rules/isBoolean.ts","../../src/rules/isEven.ts","../../src/rules/isKeyOf.ts","../../src/rules/isNaN.ts","../../src/rules/isNegative.ts","../../src/rules/isNumber.ts","../../src/rules/isOdd.ts","../../src/rules/isString.ts","../../src/rules/isTruthy.ts","../../src/rules/isValueOf.ts","../../src/rules/longerThanOrEquals.ts","../../src/rules/matches.ts","../../src/rules/ruleCondition.ts","../../src/rules/shorterThan.ts","../../src/rules/shorterThanOrEquals.ts","../../src/rules/startsWith.ts","../../src/runtime/runtimeRules.ts","../../src/runtime/rules.ts","../../src/lib/ruleReturn.ts","../../src/lib/transformResult.ts","../../src/runtime/enforceEager.ts","../../src/runtime/enforce.ts","../../src/runtime/genEnforceLazy.ts"],"sourcesContent":["import { createCascade } from 'context';\nimport { assign, Nullable } from 'vest-utils';\n\nexport const ctx = createCascade<CTXType>((ctxRef, parentContext): CTXType => {\n  const base = {\n    value: ctxRef.value,\n    meta: ctxRef.meta || {},\n  };\n\n  if (!parentContext) {\n    return assign(base, {\n      parent: emptyParent,\n    });\n  } else if (ctxRef.set) {\n    return assign(base, {\n      parent: (): EnforceContext => stripContext(parentContext),\n    });\n  }\n\n  return parentContext;\n});\n\nfunction stripContext(ctx: CTXType): EnforceContext {\n  return {\n    value: ctx.value,\n    meta: ctx.meta,\n    parent: ctx.parent,\n  };\n}\n\ntype CTXType = {\n  meta: Record<string, any>;\n  value: any;\n  set?: boolean;\n  parent: () => Nullable<CTXType>;\n};\n\nexport type EnforceContext = Nullable<{\n  meta: Record<string, any>;\n  value: any;\n  parent: () => EnforceContext;\n}>;\n\nfunction emptyParent(): null {\n  return null;\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function endsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.endsWith(arg1);\n}\n\nexport const doesNotEndWith = bindNot(endsWith);\n","import { bindNot } from 'vest-utils';\n\nexport function equals(value: unknown, arg1: unknown): boolean {\n  return value === arg1;\n}\n\nexport const notEquals = bindNot(equals);\n","import { greaterThan, numberEquals } from 'vest-utils';\n\nexport function greaterThanOrEquals(\n  value: string | number,\n  gte: string | number\n): boolean {\n  return numberEquals(value, gte) || greaterThan(value, gte);\n}\n","import { isStringValue as isString, bindNot, isArray } from 'vest-utils';\n\nexport function inside(value: unknown, arg1: string | unknown[]): boolean {\n  if (isArray(arg1)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  // both value and arg1 are strings\n  if (isString(arg1) && isString(value)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  return false;\n}\n\nexport const notInside = bindNot(inside);\n","import { isNumeric } from 'vest-utils';\n\nexport function lessThan(value: string | number, lt: string | number): boolean {\n  return isNumeric(value) && isNumeric(lt) && Number(value) < Number(lt);\n}\n","import { numberEquals } from 'vest-utils';\n\nimport { lessThan } from 'lessThan';\n\nexport function lessThanOrEquals(\n  value: string | number,\n  lte: string | number\n): boolean {\n  return numberEquals(value, lte) || lessThan(value, lte);\n}\n","import { bindNot } from 'vest-utils';\n\nimport { greaterThanOrEquals as gte } from 'greaterThanOrEquals';\nimport { lessThanOrEquals as lte } from 'lessThanOrEquals';\n\nexport function isBetween(\n  value: number | string,\n  min: number | string,\n  max: number | string\n): boolean {\n  return gte(value, min) && lte(value, max);\n}\n\nexport const isNotBetween = bindNot(isBetween);\n","import { isStringValue, bindNot, isNullish, BlankValue } from 'vest-utils';\n\nexport function isBlank(value: unknown): value is BlankValue {\n  return isNullish(value) || (isStringValue(value) && !value.trim());\n}\n\nexport const isNotBlank = bindNot(isBlank);\n","import { bindNot, isBoolean } from 'vest-utils';\n\nexport const isNotBoolean = bindNot(isBoolean);\nexport { isBoolean };\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n\n/**\n * Validates that a given value is an even number\n */\nexport const isEven = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 === 0;\n  }\n  return false;\n};\n","import { bindNot } from 'vest-utils';\n\nexport function isKeyOf(key: string | symbol | number, obj: any): boolean {\n  return key in obj;\n}\n\nexport const isNotKeyOf = bindNot(isKeyOf);\n","import { bindNot } from 'vest-utils';\n\nexport function isNaN(value: unknown): boolean {\n  return Number.isNaN(value);\n}\n\nexport const isNotNaN = bindNot(isNaN);\n","import { lessThan } from 'lessThan';\n\nexport function isNegative(value: number | string): boolean {\n  return lessThan(value, 0);\n}\n","import { bindNot } from 'vest-utils';\n\nexport function isNumber(value: unknown): value is number {\n  return Boolean(typeof value === 'number');\n}\n\nexport const isNotNumber = bindNot(isNumber);\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n/**\n * Validates that a given value is an odd number\n */\nexport const isOdd = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 !== 0;\n  }\n\n  return false;\n};\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport const isNotString = bindNot(isString);\nexport { isString };\n","import { bindNot } from 'vest-utils';\n\nexport function isTruthy(value: unknown): boolean {\n  return !!value;\n}\n\nexport const isFalsy = bindNot(isTruthy);\n","import { bindNot, isNullish } from 'vest-utils';\n\nexport function isValueOf(value: any, objectToCheck: any): boolean {\n  if (isNullish(objectToCheck)) {\n    return false;\n  }\n\n  for (const key in objectToCheck) {\n    if (objectToCheck[key] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport const isNotValueOf = bindNot(isValueOf);\n","import { greaterThanOrEquals } from 'greaterThanOrEquals';\n\nexport function longerThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return greaterThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function matches(value: string, regex: RegExp | string): boolean {\n  if (regex instanceof RegExp) {\n    return regex.test(value);\n  } else if (isString(regex)) {\n    return new RegExp(regex).test(value);\n  }\n  return false;\n}\n\nexport const notMatches = bindNot(matches);\n","import type { RuleReturn } from 'ruleReturn';\n\nexport function condition(\n  value: any,\n  callback: (value: any) => RuleReturn\n): RuleReturn {\n  try {\n    return callback(value);\n  } catch {\n    return false;\n  }\n}\n","import { lessThan } from 'lessThan';\n\nexport function shorterThan(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThan(value.length, arg1);\n}\n","import { lessThanOrEquals } from 'lessThanOrEquals';\n\nexport function shorterThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function startsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.startsWith(arg1);\n}\n\nexport const doesNotStartWith = bindNot(startsWith);\n","import type { DropFirst } from 'vest-utils';\n\nimport type { RuleReturn } from 'ruleReturn';\nimport rules from 'rules';\n\nexport type Args = any[];\n\nexport type RuleValue = any;\n\nexport type RuleBase = (value: RuleValue, ...args: Args) => RuleReturn;\n\nexport type Rule = Record<string, RuleBase>;\n\ntype BaseRules = typeof baseRules;\ntype KBaseRules = keyof BaseRules;\n\nconst baseRules = rules();\n\nfunction getRule(ruleName: string): RuleBase {\n  return baseRules[ruleName as KBaseRules];\n}\n\nexport { baseRules, getRule };\n\ntype Rules<E = Record<string, unknown>> = n4s.EnforceCustomMatchers<\n  Rules<E> & E\n> &\n  Record<string, (...args: Args) => Rules<E> & E> & {\n    [P in KBaseRules]: (\n      ...args: DropFirst<Parameters<BaseRules[P]>> | Args\n    ) => Rules<E> & E;\n  };\n\n/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-empty-interface */\ndeclare global {\n  namespace n4s {\n    interface IRules<E> extends Rules<E> {}\n  }\n}\n","import {\n  greaterThan,\n  isNull,\n  isNotNull,\n  isNullish,\n  isNotNullish,\n  isNumeric,\n  isNotNumeric,\n  isUndefined,\n  isNotUndefined,\n  lengthEquals,\n  lengthNotEquals,\n  longerThan,\n  numberEquals,\n  numberNotEquals,\n  isArray,\n  isNotArray,\n  isPositive,\n  isEmpty,\n  isNotEmpty,\n} from 'vest-utils';\n\nimport { endsWith, doesNotEndWith } from 'endsWith';\nimport { equals, notEquals } from 'equals';\nimport { greaterThanOrEquals } from 'greaterThanOrEquals';\nimport { inside, notInside } from 'inside';\nimport { isBetween, isNotBetween } from 'isBetween';\nimport { isBlank, isNotBlank } from 'isBlank';\nimport { isBoolean, isNotBoolean } from 'isBoolean';\nimport { isEven } from 'isEven';\nimport { isKeyOf, isNotKeyOf } from 'isKeyOf';\nimport { isNaN, isNotNaN } from 'isNaN';\nimport { isNegative } from 'isNegative';\nimport { isNumber, isNotNumber } from 'isNumber';\nimport { isOdd } from 'isOdd';\nimport { isString, isNotString } from 'isString';\nimport { isTruthy, isFalsy } from 'isTruthy';\nimport { isValueOf, isNotValueOf } from 'isValueOf';\nimport { lessThan } from 'lessThan';\nimport { lessThanOrEquals } from 'lessThanOrEquals';\nimport { longerThanOrEquals } from 'longerThanOrEquals';\nimport { matches, notMatches } from 'matches';\nimport { condition } from 'ruleCondition';\nimport { shorterThan } from 'shorterThan';\nimport { shorterThanOrEquals } from 'shorterThanOrEquals';\nimport { startsWith, doesNotStartWith } from 'startsWith';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, max-lines-per-function\nexport default function rules() {\n  return {\n    condition,\n    doesNotEndWith,\n    doesNotStartWith,\n    endsWith,\n    equals,\n    greaterThan,\n    greaterThanOrEquals,\n    gt: greaterThan,\n    gte: greaterThanOrEquals,\n    inside,\n    isArray,\n    isBetween,\n    isBlank,\n    isBoolean,\n    isEmpty,\n    isEven,\n    isFalsy,\n    isKeyOf,\n    isNaN,\n    isNegative,\n    isNotArray,\n    isNotBetween,\n    isNotBlank,\n    isNotBoolean,\n    isNotEmpty,\n    isNotKeyOf,\n    isNotNaN,\n    isNotNull,\n    isNotNullish,\n    isNotNumber,\n    isNotNumeric,\n    isNotString,\n    isNotUndefined,\n    isNotValueOf,\n    isNull,\n    isNullish,\n    isNumber,\n    isNumeric,\n    isOdd,\n    isPositive,\n    isString,\n    isTruthy,\n    isUndefined,\n    isValueOf,\n    lengthEquals,\n    lengthNotEquals,\n    lessThan,\n    lessThanOrEquals,\n    longerThan,\n    longerThanOrEquals,\n    lt: lessThan,\n    lte: lessThanOrEquals,\n    matches,\n    notEquals,\n    notInside,\n    notMatches,\n    numberEquals,\n    numberNotEquals,\n    shorterThan,\n    shorterThanOrEquals,\n    startsWith,\n  };\n}\n","import type { Stringable } from 'vest-utils';\nimport { defaultTo } from 'vest-utils';\n\nexport default function ruleReturn(\n  pass: boolean,\n  message?: string\n): RuleDetailedResult {\n  const output: RuleDetailedResult = { pass };\n\n  if (message) {\n    output.message = message;\n  }\n\n  return output;\n}\n\nexport function failing(): RuleDetailedResult {\n  return ruleReturn(false);\n}\n\nexport function passing(): RuleDetailedResult {\n  return ruleReturn(true);\n}\n\nexport function defaultToFailing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, failing());\n}\n\nexport function defaultToPassing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, passing());\n}\n\nexport type RuleReturn =\n  | boolean\n  | {\n      pass: boolean;\n      message?: Stringable;\n    };\n\nexport type RuleDetailedResult = { pass: boolean; message?: string };\n","import { invariant, optionalFunctionValue, isBoolean } from 'vest-utils';\n\nimport ruleReturn, { RuleReturn, RuleDetailedResult } from 'ruleReturn';\nimport type { RuleValue, Args } from 'runtimeRules';\n\n/**\n * Transform the result of a rule into a standard format\n */\nexport function transformResult(\n  result: RuleReturn,\n  ruleName: string,\n  value: RuleValue,\n  ...args: Args\n): RuleDetailedResult {\n  validateResult(result);\n\n  // if result is boolean\n  if (isBoolean(result)) {\n    return ruleReturn(result);\n  }\n  return ruleReturn(\n    result.pass,\n    optionalFunctionValue(result.message, ruleName, value, ...args)\n  );\n}\n\nfunction validateResult(result: RuleReturn): void {\n  // if result is boolean, or if result.pass is boolean\n  invariant(\n    isBoolean(result) || (result && isBoolean(result.pass)),\n    'Incorrect return value for rule: ' + JSON.stringify(result)\n  );\n}\n","import { invariant, StringObject, isNullish, Maybe } from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport { getRule, RuleValue, Args, RuleBase } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\ntype IRules = n4s.IRules<Record<string, any> & EnforceEagerReturn>;\ntype TModifiers = {\n  message: (input: string) => EnforceEagerReturn;\n};\n\ntype EnforceEagerReturn = IRules &\n  TModifiers & {\n    pass: boolean;\n  };\n\n// eslint-disable-next-line max-lines-per-function\nexport default function enforceEager(value: RuleValue): EnforceEagerReturn {\n  const target = {\n    message,\n    pass: false,\n  } as EnforceEagerReturn;\n  let customMessage: Maybe<string> = undefined;\n\n  // We create a proxy intercepting access to the target object (which is empty).\n  const proxy: EnforceEagerReturn = new Proxy(target, {\n    get: (_, key: string) => {\n      // On property access, we identify if it is a rule or not.\n      const rule = getRule(key);\n\n      // If it is a rule, we wrap it with `genRuleCall` that adds the base enforce behavior\n      if (rule) {\n        return genRuleCall(proxy, rule, key);\n      }\n      return target[key];\n    },\n  });\n\n  return proxy;\n\n  // This function is used to wrap a rule with the base enforce behavior\n  // It takes the target object, the rule function, and the rule name\n  // It then returns the rule, in a manner that can be used by enforce\n  function genRuleCall(\n    target: EnforceEagerReturn,\n    rule: RuleBase,\n    ruleName: string,\n  ) {\n    return function ruleCall(...args: Args): EnforceEagerReturn {\n      // Order of operation:\n      // 1. Create a context with the value being enforced\n      // 2. Call the rule within the context, and pass over the arguments passed to it\n      // 3. Transform the result to the correct output format\n      const transformedResult = ctx.run({ value }, () => {\n        return transformResult(rule(value, ...args), ruleName, value, ...args);\n      });\n\n      function enforceMessage() {\n        if (!isNullish(customMessage)) return StringObject(customMessage);\n        if (isNullish(transformedResult.message)) {\n          return `enforce/${ruleName} failed with ${JSON.stringify(value)}`;\n        }\n        return StringObject(transformedResult.message);\n      }\n\n      // On rule failure (the result is false), we either throw an error\n      // or throw a string value if the rule has a message defined in it.\n      invariant(transformedResult.pass, enforceMessage());\n\n      // This is not really needed because it will always be true\n      // As we're throwing an error on failure\n      // but it is here so that users have a sense of what is happening\n      // when they try to log the result of enforce and not just see a proxy object\n      target.pass = transformedResult.pass;\n\n      return target;\n    };\n  }\n\n  function message(input: string): EnforceEagerReturn {\n    customMessage = input;\n    return proxy;\n  }\n}\n\nexport type EnforceEager = typeof enforceEager;\n","import { assign } from 'vest-utils';\n\nimport { ctx, EnforceContext } from 'enforceContext';\nimport enforceEager, { EnforceEager } from 'enforceEager';\nimport genEnforceLazy, { LazyRules } from 'genEnforceLazy';\nimport { Rule, baseRules, getRule } from 'runtimeRules';\n/**\n * Enforce is quite complicated, I want to explain it in detail.\n * It is dynamic in nature, so a lot of proxy objects are involved.\n *\n * Enforce has two main interfaces\n * 1. eager\n * 2. lazy\n *\n * The eager interface is the most commonly used, and the easier to understand.\n * It throws an error when a rule is not satisfied.\n * The eager interface is declared in enforceEager.ts and it is quite simple to understand.\n * enforce is called with a value, and the return value is a proxy object that points back to all the rules.\n * When a rule is called, the value is mapped as its first argument, and if the rule passes, the same\n * proxy object is returned. Otherwise, an error is thrown.\n *\n * The lazy interface works quite differently. It is declared in genEnforceLazy.ts.\n * Rather than calling enforce directly, the lazy interface has all the rules as \"methods\" (only by proxy).\n * Calling the first function in the chain will initialize an array of calls. It stores the different rule calls\n * and the parameters passed to them. None of the rules are called yet.\n * The rules are only invoked in sequence once either of these chained functions are called:\n * 1. test(value)\n * 2. run(value)\n *\n * Calling run or test will call all the rules in sequence, with the difference that test will only return a boolean value,\n * while run will return an object with the validation result and an optional message created by the rule.\n */\n\nfunction genEnforce(): Enforce {\n  const target = {\n    context: () => ctx.useX(),\n    extend: (customRules: Rule) => {\n      assign(baseRules, customRules);\n    },\n  } as Enforce;\n\n  return new Proxy(assign(enforceEager, target) as Enforce, {\n    get: (target: Enforce, key: string) => {\n      if (key in target) {\n        return target[key];\n      }\n\n      if (!getRule(key)) {\n        return;\n      }\n\n      // Only on the first rule access - start the chain of calls\n      return genEnforceLazy(key);\n    },\n  });\n}\n\nexport const enforce = genEnforce();\n\ntype Enforce = EnforceMethods & LazyRules & EnforceEager;\n\ntype EnforceMethods = {\n  context: () => EnforceContext;\n  extend: (customRules: Rule) => void;\n};\n","import {\n  mapFirst,\n  optionalFunctionValue,\n  CB,\n  Stringable,\n  Maybe,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport ruleReturn, { defaultToPassing, RuleDetailedResult } from 'ruleReturn';\nimport { RuleValue, Args, getRule } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\n// eslint-disable-next-line max-lines-per-function\nexport default function genEnforceLazy(key: string) {\n  const registeredRules: RegisteredRules = [];\n  let lazyMessage: Maybe<LazyMessage>;\n\n  return addLazyRule(key);\n\n  // eslint-disable-next-line max-lines-per-function\n  function addLazyRule(ruleName: string) {\n    // eslint-disable-next-line max-lines-per-function\n    return (...args: Args): Lazy => {\n      const rule = getRule(ruleName);\n\n      registeredRules.push((value: RuleValue) =>\n        transformResult(rule(value, ...args), ruleName, value, ...args)\n      );\n\n      let proxy = {\n        run: (value: RuleValue): RuleDetailedResult => {\n          return defaultToPassing(\n            mapFirst(registeredRules, (rule, breakout) => {\n              const res = ctx.run({ value }, () => rule(value));\n\n              breakout(\n                !res.pass,\n                ruleReturn(\n                  !!res.pass,\n                  optionalFunctionValue(lazyMessage, value, res.message) ??\n                    res.message\n                )\n              );\n            })\n          );\n        },\n        test: (value: RuleValue): boolean => proxy.run(value).pass,\n        message: (message: Stringable): Lazy => {\n          if (message) {\n            lazyMessage = message;\n          }\n\n          return proxy;\n        },\n      } as Lazy;\n\n      // reassigning the proxy here is not pretty\n      // but it's a cleaner way of getting `run` and `test` for free\n      proxy = new Proxy(proxy, {\n        get: (target, key: string) => {\n          if (getRule(key)) {\n            return addLazyRule(key);\n          }\n\n          return target[key]; // already has `run` and `test` on it\n        },\n      });\n      return proxy;\n    };\n  }\n}\n\nexport type LazyRules = n4s.IRules<LazyRuleMethods>;\n\nexport type Lazy = LazyRules &\n  LazyRuleMethods &\n  // This is a \"catch all\" hack to make TS happy while not\n  // losing type hints\n  Record<string, CB>;\n\ntype LazyRuleMethods = LazyRuleRunners & {\n  message: (message: LazyMessage) => Lazy;\n};\n\nexport type LazyRuleRunners = {\n  test: (value: unknown) => boolean;\n  run: (value: unknown) => RuleDetailedResult;\n};\n\nexport type ComposeResult = LazyRuleRunners & ((value: any) => void);\n\ntype RegisteredRules = Array<(value: RuleValue) => RuleDetailedResult>;\ntype LazyMessage = DynamicValue<\n  string,\n  [value: unknown, originalMessage?: Stringable]\n>;\n"],"names":["ctx","createCascade","ctxRef","parentContext","base","value","meta","set","assign","parent","stripContext","emptyParent","endsWith","arg1","isString","isStringValue","doesNotEndWith","bindNot","equals","notEquals","greaterThanOrEquals","gte","numberEquals","greaterThan","inside","isArray","indexOf","notInside","lessThan","lt","isNumeric","Number","lessThanOrEquals","lte","isBetween","min","max","isNotBetween","isBlank","isNullish","trim","isNotBlank","isNotBoolean","isBoolean","isEven","isKeyOf","key","obj","isNotKeyOf","isNaN","isNotNaN","isNegative","isNumber","Boolean","isNotNumber","isOdd","isNotString","isTruthy","isFalsy","isValueOf","objectToCheck","isNotValueOf","longerThanOrEquals","length","matches","regex","RegExp","test","notMatches","condition","callback","_a","shorterThan","shorterThanOrEquals","startsWith","doesNotStartWith","baseRules","gt","isEmpty","isNotArray","isNotEmpty","isNotNull","isNotNullish","isNotNumeric","isNotUndefined","isNull","isPositive","isUndefined","lengthEquals","lengthNotEquals","longerThan","numberNotEquals","getRule","ruleName","ruleReturn","pass","message","output","defaultToPassing","defaultTo","transformResult","result","args","invariant","JSON","stringify","validateResult","optionalFunctionValue","enforceEager","target","input","customMessage","proxy","Proxy","get","_","rule","transformedResult","run","enforceMessage","StringObject","genRuleCall","enforce","context","useX","extend","customRules","registeredRules","lazyMessage","addLazyRule","push","mapFirst","breakout","res","genEnforceLazy","genEnforce"],"mappings":"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"}