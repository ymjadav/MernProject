{"version":3,"file":"n4s.development.js","sources":["../../src/runtime/enforceContext.ts","../../src/rules/endsWith.ts","../../src/rules/equals.ts","../../src/rules/greaterThanOrEquals.ts","../../src/rules/inside.ts","../../src/rules/lessThan.ts","../../src/rules/lessThanOrEquals.ts","../../src/rules/isBetween.ts","../../src/rules/isBlank.ts","../../src/rules/isBoolean.ts","../../src/rules/isEven.ts","../../src/rules/isKeyOf.ts","../../src/rules/isNaN.ts","../../src/rules/isNegative.ts","../../src/rules/isNumber.ts","../../src/rules/isOdd.ts","../../src/rules/isString.ts","../../src/rules/isTruthy.ts","../../src/rules/isValueOf.ts","../../src/rules/longerThanOrEquals.ts","../../src/rules/matches.ts","../../src/rules/ruleCondition.ts","../../src/rules/shorterThan.ts","../../src/rules/shorterThanOrEquals.ts","../../src/rules/startsWith.ts","../../src/runtime/rules.ts","../../src/runtime/runtimeRules.ts","../../src/lib/ruleReturn.ts","../../src/lib/transformResult.ts","../../src/runtime/enforceEager.ts","../../src/runtime/genEnforceLazy.ts","../../src/runtime/enforce.ts"],"sourcesContent":["import { createCascade } from 'context';\nimport { assign, Nullable } from 'vest-utils';\n\nexport const ctx = createCascade<CTXType>((ctxRef, parentContext): CTXType => {\n  const base = {\n    value: ctxRef.value,\n    meta: ctxRef.meta || {},\n  };\n\n  if (!parentContext) {\n    return assign(base, {\n      parent: emptyParent,\n    });\n  } else if (ctxRef.set) {\n    return assign(base, {\n      parent: (): EnforceContext => stripContext(parentContext),\n    });\n  }\n\n  return parentContext;\n});\n\nfunction stripContext(ctx: CTXType): EnforceContext {\n  return {\n    value: ctx.value,\n    meta: ctx.meta,\n    parent: ctx.parent,\n  };\n}\n\ntype CTXType = {\n  meta: Record<string, any>;\n  value: any;\n  set?: boolean;\n  parent: () => Nullable<CTXType>;\n};\n\nexport type EnforceContext = Nullable<{\n  meta: Record<string, any>;\n  value: any;\n  parent: () => EnforceContext;\n}>;\n\nfunction emptyParent(): null {\n  return null;\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function endsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.endsWith(arg1);\n}\n\nexport const doesNotEndWith = bindNot(endsWith);\n","import { bindNot } from 'vest-utils';\n\nexport function equals(value: unknown, arg1: unknown): boolean {\n  return value === arg1;\n}\n\nexport const notEquals = bindNot(equals);\n","import { greaterThan, numberEquals } from 'vest-utils';\n\nexport function greaterThanOrEquals(\n  value: string | number,\n  gte: string | number\n): boolean {\n  return numberEquals(value, gte) || greaterThan(value, gte);\n}\n","import { isStringValue as isString, bindNot, isArray } from 'vest-utils';\n\nexport function inside(value: unknown, arg1: string | unknown[]): boolean {\n  if (isArray(arg1)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  // both value and arg1 are strings\n  if (isString(arg1) && isString(value)) {\n    return arg1.indexOf(value) !== -1;\n  }\n\n  return false;\n}\n\nexport const notInside = bindNot(inside);\n","import { isNumeric } from 'vest-utils';\n\nexport function lessThan(value: string | number, lt: string | number): boolean {\n  return isNumeric(value) && isNumeric(lt) && Number(value) < Number(lt);\n}\n","import { numberEquals } from 'vest-utils';\n\nimport { lessThan } from 'lessThan';\n\nexport function lessThanOrEquals(\n  value: string | number,\n  lte: string | number\n): boolean {\n  return numberEquals(value, lte) || lessThan(value, lte);\n}\n","import { bindNot } from 'vest-utils';\n\nimport { greaterThanOrEquals as gte } from 'greaterThanOrEquals';\nimport { lessThanOrEquals as lte } from 'lessThanOrEquals';\n\nexport function isBetween(\n  value: number | string,\n  min: number | string,\n  max: number | string\n): boolean {\n  return gte(value, min) && lte(value, max);\n}\n\nexport const isNotBetween = bindNot(isBetween);\n","import { isStringValue, bindNot, isNullish, BlankValue } from 'vest-utils';\n\nexport function isBlank(value: unknown): value is BlankValue {\n  return isNullish(value) || (isStringValue(value) && !value.trim());\n}\n\nexport const isNotBlank = bindNot(isBlank);\n","import { bindNot, isBoolean } from 'vest-utils';\n\nexport const isNotBoolean = bindNot(isBoolean);\nexport { isBoolean };\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n\n/**\n * Validates that a given value is an even number\n */\nexport const isEven = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 === 0;\n  }\n  return false;\n};\n","import { bindNot } from 'vest-utils';\n\nexport function isKeyOf(key: string | symbol | number, obj: any): boolean {\n  return key in obj;\n}\n\nexport const isNotKeyOf = bindNot(isKeyOf);\n","import { bindNot } from 'vest-utils';\n\nexport function isNaN(value: unknown): boolean {\n  return Number.isNaN(value);\n}\n\nexport const isNotNaN = bindNot(isNaN);\n","import { lessThan } from 'lessThan';\n\nexport function isNegative(value: number | string): boolean {\n  return lessThan(value, 0);\n}\n","import { bindNot } from 'vest-utils';\n\nexport function isNumber(value: unknown): value is number {\n  return Boolean(typeof value === 'number');\n}\n\nexport const isNotNumber = bindNot(isNumber);\n","import { isNumeric } from 'vest-utils';\n\nimport type { RuleValue } from 'runtimeRules';\n/**\n * Validates that a given value is an odd number\n */\nexport const isOdd = (value: RuleValue): boolean => {\n  if (isNumeric(value)) {\n    return value % 2 !== 0;\n  }\n\n  return false;\n};\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport const isNotString = bindNot(isString);\nexport { isString };\n","import { bindNot } from 'vest-utils';\n\nexport function isTruthy(value: unknown): boolean {\n  return !!value;\n}\n\nexport const isFalsy = bindNot(isTruthy);\n","import { bindNot, isNullish } from 'vest-utils';\n\nexport function isValueOf(value: any, objectToCheck: any): boolean {\n  if (isNullish(objectToCheck)) {\n    return false;\n  }\n\n  for (const key in objectToCheck) {\n    if (objectToCheck[key] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport const isNotValueOf = bindNot(isValueOf);\n","import { greaterThanOrEquals } from 'greaterThanOrEquals';\n\nexport function longerThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return greaterThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function matches(value: string, regex: RegExp | string): boolean {\n  if (regex instanceof RegExp) {\n    return regex.test(value);\n  } else if (isString(regex)) {\n    return new RegExp(regex).test(value);\n  }\n  return false;\n}\n\nexport const notMatches = bindNot(matches);\n","import type { RuleReturn } from 'ruleReturn';\n\nexport function condition(\n  value: any,\n  callback: (value: any) => RuleReturn\n): RuleReturn {\n  try {\n    return callback(value);\n  } catch {\n    return false;\n  }\n}\n","import { lessThan } from 'lessThan';\n\nexport function shorterThan(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThan(value.length, arg1);\n}\n","import { lessThanOrEquals } from 'lessThanOrEquals';\n\nexport function shorterThanOrEquals(\n  value: string | unknown[],\n  arg1: string | number\n): boolean {\n  return lessThanOrEquals(value.length, arg1);\n}\n","import { isStringValue as isString, bindNot } from 'vest-utils';\n\nexport function startsWith(value: string, arg1: string): boolean {\n  return isString(value) && isString(arg1) && value.startsWith(arg1);\n}\n\nexport const doesNotStartWith = bindNot(startsWith);\n","import {\n  greaterThan,\n  isNull,\n  isNotNull,\n  isNullish,\n  isNotNullish,\n  isNumeric,\n  isNotNumeric,\n  isUndefined,\n  isNotUndefined,\n  lengthEquals,\n  lengthNotEquals,\n  longerThan,\n  numberEquals,\n  numberNotEquals,\n  isArray,\n  isNotArray,\n  isPositive,\n  isEmpty,\n  isNotEmpty,\n} from 'vest-utils';\n\nimport { endsWith, doesNotEndWith } from 'endsWith';\nimport { equals, notEquals } from 'equals';\nimport { greaterThanOrEquals } from 'greaterThanOrEquals';\nimport { inside, notInside } from 'inside';\nimport { isBetween, isNotBetween } from 'isBetween';\nimport { isBlank, isNotBlank } from 'isBlank';\nimport { isBoolean, isNotBoolean } from 'isBoolean';\nimport { isEven } from 'isEven';\nimport { isKeyOf, isNotKeyOf } from 'isKeyOf';\nimport { isNaN, isNotNaN } from 'isNaN';\nimport { isNegative } from 'isNegative';\nimport { isNumber, isNotNumber } from 'isNumber';\nimport { isOdd } from 'isOdd';\nimport { isString, isNotString } from 'isString';\nimport { isTruthy, isFalsy } from 'isTruthy';\nimport { isValueOf, isNotValueOf } from 'isValueOf';\nimport { lessThan } from 'lessThan';\nimport { lessThanOrEquals } from 'lessThanOrEquals';\nimport { longerThanOrEquals } from 'longerThanOrEquals';\nimport { matches, notMatches } from 'matches';\nimport { condition } from 'ruleCondition';\nimport { shorterThan } from 'shorterThan';\nimport { shorterThanOrEquals } from 'shorterThanOrEquals';\nimport { startsWith, doesNotStartWith } from 'startsWith';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, max-lines-per-function\nexport default function rules() {\n  return {\n    condition,\n    doesNotEndWith,\n    doesNotStartWith,\n    endsWith,\n    equals,\n    greaterThan,\n    greaterThanOrEquals,\n    gt: greaterThan,\n    gte: greaterThanOrEquals,\n    inside,\n    isArray,\n    isBetween,\n    isBlank,\n    isBoolean,\n    isEmpty,\n    isEven,\n    isFalsy,\n    isKeyOf,\n    isNaN,\n    isNegative,\n    isNotArray,\n    isNotBetween,\n    isNotBlank,\n    isNotBoolean,\n    isNotEmpty,\n    isNotKeyOf,\n    isNotNaN,\n    isNotNull,\n    isNotNullish,\n    isNotNumber,\n    isNotNumeric,\n    isNotString,\n    isNotUndefined,\n    isNotValueOf,\n    isNull,\n    isNullish,\n    isNumber,\n    isNumeric,\n    isOdd,\n    isPositive,\n    isString,\n    isTruthy,\n    isUndefined,\n    isValueOf,\n    lengthEquals,\n    lengthNotEquals,\n    lessThan,\n    lessThanOrEquals,\n    longerThan,\n    longerThanOrEquals,\n    lt: lessThan,\n    lte: lessThanOrEquals,\n    matches,\n    notEquals,\n    notInside,\n    notMatches,\n    numberEquals,\n    numberNotEquals,\n    shorterThan,\n    shorterThanOrEquals,\n    startsWith,\n  };\n}\n","import type { DropFirst } from 'vest-utils';\n\nimport type { RuleReturn } from 'ruleReturn';\nimport rules from 'rules';\n\nexport type Args = any[];\n\nexport type RuleValue = any;\n\nexport type RuleBase = (value: RuleValue, ...args: Args) => RuleReturn;\n\nexport type Rule = Record<string, RuleBase>;\n\ntype BaseRules = typeof baseRules;\ntype KBaseRules = keyof BaseRules;\n\nconst baseRules = rules();\n\nfunction getRule(ruleName: string): RuleBase {\n  return baseRules[ruleName as KBaseRules];\n}\n\nexport { baseRules, getRule };\n\ntype Rules<E = Record<string, unknown>> = n4s.EnforceCustomMatchers<\n  Rules<E> & E\n> &\n  Record<string, (...args: Args) => Rules<E> & E> & {\n    [P in KBaseRules]: (\n      ...args: DropFirst<Parameters<BaseRules[P]>> | Args\n    ) => Rules<E> & E;\n  };\n\n/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-empty-interface */\ndeclare global {\n  namespace n4s {\n    interface IRules<E> extends Rules<E> {}\n  }\n}\n","import type { Stringable } from 'vest-utils';\nimport { defaultTo } from 'vest-utils';\n\nexport default function ruleReturn(\n  pass: boolean,\n  message?: string\n): RuleDetailedResult {\n  const output: RuleDetailedResult = { pass };\n\n  if (message) {\n    output.message = message;\n  }\n\n  return output;\n}\n\nexport function failing(): RuleDetailedResult {\n  return ruleReturn(false);\n}\n\nexport function passing(): RuleDetailedResult {\n  return ruleReturn(true);\n}\n\nexport function defaultToFailing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, failing());\n}\n\nexport function defaultToPassing(\n  callback: (...args: any[]) => RuleDetailedResult\n): RuleDetailedResult {\n  return defaultTo(callback, passing());\n}\n\nexport type RuleReturn =\n  | boolean\n  | {\n      pass: boolean;\n      message?: Stringable;\n    };\n\nexport type RuleDetailedResult = { pass: boolean; message?: string };\n","import { invariant, optionalFunctionValue, isBoolean } from 'vest-utils';\n\nimport ruleReturn, { RuleReturn, RuleDetailedResult } from 'ruleReturn';\nimport type { RuleValue, Args } from 'runtimeRules';\n\n/**\n * Transform the result of a rule into a standard format\n */\nexport function transformResult(\n  result: RuleReturn,\n  ruleName: string,\n  value: RuleValue,\n  ...args: Args\n): RuleDetailedResult {\n  validateResult(result);\n\n  // if result is boolean\n  if (isBoolean(result)) {\n    return ruleReturn(result);\n  }\n  return ruleReturn(\n    result.pass,\n    optionalFunctionValue(result.message, ruleName, value, ...args)\n  );\n}\n\nfunction validateResult(result: RuleReturn): void {\n  // if result is boolean, or if result.pass is boolean\n  invariant(\n    isBoolean(result) || (result && isBoolean(result.pass)),\n    'Incorrect return value for rule: ' + JSON.stringify(result)\n  );\n}\n","import { invariant, StringObject, isNullish, Maybe } from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport { getRule, RuleValue, Args, RuleBase } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\ntype IRules = n4s.IRules<Record<string, any> & EnforceEagerReturn>;\ntype TModifiers = {\n  message: (input: string) => EnforceEagerReturn;\n};\n\ntype EnforceEagerReturn = IRules &\n  TModifiers & {\n    pass: boolean;\n  };\n\n// eslint-disable-next-line max-lines-per-function\nexport default function enforceEager(value: RuleValue): EnforceEagerReturn {\n  const target = {\n    message,\n    pass: false,\n  } as EnforceEagerReturn;\n  let customMessage: Maybe<string> = undefined;\n\n  // We create a proxy intercepting access to the target object (which is empty).\n  const proxy: EnforceEagerReturn = new Proxy(target, {\n    get: (_, key: string) => {\n      // On property access, we identify if it is a rule or not.\n      const rule = getRule(key);\n\n      // If it is a rule, we wrap it with `genRuleCall` that adds the base enforce behavior\n      if (rule) {\n        return genRuleCall(proxy, rule, key);\n      }\n      return target[key];\n    },\n  });\n\n  return proxy;\n\n  // This function is used to wrap a rule with the base enforce behavior\n  // It takes the target object, the rule function, and the rule name\n  // It then returns the rule, in a manner that can be used by enforce\n  function genRuleCall(\n    target: EnforceEagerReturn,\n    rule: RuleBase,\n    ruleName: string,\n  ) {\n    return function ruleCall(...args: Args): EnforceEagerReturn {\n      // Order of operation:\n      // 1. Create a context with the value being enforced\n      // 2. Call the rule within the context, and pass over the arguments passed to it\n      // 3. Transform the result to the correct output format\n      const transformedResult = ctx.run({ value }, () => {\n        return transformResult(rule(value, ...args), ruleName, value, ...args);\n      });\n\n      function enforceMessage() {\n        if (!isNullish(customMessage)) return StringObject(customMessage);\n        if (isNullish(transformedResult.message)) {\n          return `enforce/${ruleName} failed with ${JSON.stringify(value)}`;\n        }\n        return StringObject(transformedResult.message);\n      }\n\n      // On rule failure (the result is false), we either throw an error\n      // or throw a string value if the rule has a message defined in it.\n      invariant(transformedResult.pass, enforceMessage());\n\n      // This is not really needed because it will always be true\n      // As we're throwing an error on failure\n      // but it is here so that users have a sense of what is happening\n      // when they try to log the result of enforce and not just see a proxy object\n      target.pass = transformedResult.pass;\n\n      return target;\n    };\n  }\n\n  function message(input: string): EnforceEagerReturn {\n    customMessage = input;\n    return proxy;\n  }\n}\n\nexport type EnforceEager = typeof enforceEager;\n","import {\n  mapFirst,\n  optionalFunctionValue,\n  CB,\n  Stringable,\n  Maybe,\n  DynamicValue,\n} from 'vest-utils';\n\nimport { ctx } from 'enforceContext';\nimport ruleReturn, { defaultToPassing, RuleDetailedResult } from 'ruleReturn';\nimport { RuleValue, Args, getRule } from 'runtimeRules';\nimport { transformResult } from 'transformResult';\n\n// eslint-disable-next-line max-lines-per-function\nexport default function genEnforceLazy(key: string) {\n  const registeredRules: RegisteredRules = [];\n  let lazyMessage: Maybe<LazyMessage>;\n\n  return addLazyRule(key);\n\n  // eslint-disable-next-line max-lines-per-function\n  function addLazyRule(ruleName: string) {\n    // eslint-disable-next-line max-lines-per-function\n    return (...args: Args): Lazy => {\n      const rule = getRule(ruleName);\n\n      registeredRules.push((value: RuleValue) =>\n        transformResult(rule(value, ...args), ruleName, value, ...args)\n      );\n\n      let proxy = {\n        run: (value: RuleValue): RuleDetailedResult => {\n          return defaultToPassing(\n            mapFirst(registeredRules, (rule, breakout) => {\n              const res = ctx.run({ value }, () => rule(value));\n\n              breakout(\n                !res.pass,\n                ruleReturn(\n                  !!res.pass,\n                  optionalFunctionValue(lazyMessage, value, res.message) ??\n                    res.message\n                )\n              );\n            })\n          );\n        },\n        test: (value: RuleValue): boolean => proxy.run(value).pass,\n        message: (message: Stringable): Lazy => {\n          if (message) {\n            lazyMessage = message;\n          }\n\n          return proxy;\n        },\n      } as Lazy;\n\n      // reassigning the proxy here is not pretty\n      // but it's a cleaner way of getting `run` and `test` for free\n      proxy = new Proxy(proxy, {\n        get: (target, key: string) => {\n          if (getRule(key)) {\n            return addLazyRule(key);\n          }\n\n          return target[key]; // already has `run` and `test` on it\n        },\n      });\n      return proxy;\n    };\n  }\n}\n\nexport type LazyRules = n4s.IRules<LazyRuleMethods>;\n\nexport type Lazy = LazyRules &\n  LazyRuleMethods &\n  // This is a \"catch all\" hack to make TS happy while not\n  // losing type hints\n  Record<string, CB>;\n\ntype LazyRuleMethods = LazyRuleRunners & {\n  message: (message: LazyMessage) => Lazy;\n};\n\nexport type LazyRuleRunners = {\n  test: (value: unknown) => boolean;\n  run: (value: unknown) => RuleDetailedResult;\n};\n\nexport type ComposeResult = LazyRuleRunners & ((value: any) => void);\n\ntype RegisteredRules = Array<(value: RuleValue) => RuleDetailedResult>;\ntype LazyMessage = DynamicValue<\n  string,\n  [value: unknown, originalMessage?: Stringable]\n>;\n","import { assign } from 'vest-utils';\n\nimport { ctx, EnforceContext } from 'enforceContext';\nimport enforceEager, { EnforceEager } from 'enforceEager';\nimport genEnforceLazy, { LazyRules } from 'genEnforceLazy';\nimport { Rule, baseRules, getRule } from 'runtimeRules';\n/**\n * Enforce is quite complicated, I want to explain it in detail.\n * It is dynamic in nature, so a lot of proxy objects are involved.\n *\n * Enforce has two main interfaces\n * 1. eager\n * 2. lazy\n *\n * The eager interface is the most commonly used, and the easier to understand.\n * It throws an error when a rule is not satisfied.\n * The eager interface is declared in enforceEager.ts and it is quite simple to understand.\n * enforce is called with a value, and the return value is a proxy object that points back to all the rules.\n * When a rule is called, the value is mapped as its first argument, and if the rule passes, the same\n * proxy object is returned. Otherwise, an error is thrown.\n *\n * The lazy interface works quite differently. It is declared in genEnforceLazy.ts.\n * Rather than calling enforce directly, the lazy interface has all the rules as \"methods\" (only by proxy).\n * Calling the first function in the chain will initialize an array of calls. It stores the different rule calls\n * and the parameters passed to them. None of the rules are called yet.\n * The rules are only invoked in sequence once either of these chained functions are called:\n * 1. test(value)\n * 2. run(value)\n *\n * Calling run or test will call all the rules in sequence, with the difference that test will only return a boolean value,\n * while run will return an object with the validation result and an optional message created by the rule.\n */\n\nfunction genEnforce(): Enforce {\n  const target = {\n    context: () => ctx.useX(),\n    extend: (customRules: Rule) => {\n      assign(baseRules, customRules);\n    },\n  } as Enforce;\n\n  return new Proxy(assign(enforceEager, target) as Enforce, {\n    get: (target: Enforce, key: string) => {\n      if (key in target) {\n        return target[key];\n      }\n\n      if (!getRule(key)) {\n        return;\n      }\n\n      // Only on the first rule access - start the chain of calls\n      return genEnforceLazy(key);\n    },\n  });\n}\n\nexport const enforce = genEnforce();\n\ntype Enforce = EnforceMethods & LazyRules & EnforceEager;\n\ntype EnforceMethods = {\n  context: () => EnforceContext;\n  extend: (customRules: Rule) => void;\n};\n"],"names":["createCascade","assign","isString","bindNot","numberEquals","greaterThan","isArray","isNumeric","gte","lte","isNullish","isStringValue","isBoolean","isEmpty","isNotArray","isNotEmpty","isNotNull","isNotNullish","isNotNumeric","isNotUndefined","isNull","isPositive","isUndefined","lengthEquals","lengthNotEquals","longerThan","numberNotEquals","defaultTo","optionalFunctionValue","invariant","StringObject","mapFirst"],"mappings":"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"}