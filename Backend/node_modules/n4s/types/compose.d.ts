import { CB, Stringable, DynamicValue, DropFirst, BlankValue } from "vest-utils";
type RuleReturn = boolean | {
    pass: boolean;
    message?: Stringable;
};
type RuleDetailedResult = {
    pass: boolean;
    message?: string;
};
type Args = any[];
type BaseRules = typeof baseRules;
type KBaseRules = keyof BaseRules;
declare function condition(value: any, callback: (value: any) => RuleReturn): RuleReturn;
declare function endsWith(value: string, arg1: string): boolean;
declare function equals(value: unknown, arg1: unknown): boolean;
declare function greaterThanOrEquals(value: string | number, gte: string | number): boolean;
declare function inside(value: unknown, arg1: string | unknown[]): boolean;
declare function isBetween(value: number | string, min: number | string, max: number | string): boolean;
declare function isBlank(value: unknown): value is BlankValue;
declare function isKeyOf(key: string | symbol | number, obj: any): boolean;
declare function isNaN(value: unknown): boolean;
declare function isNegative(value: number | string): boolean;
declare function isNumber(value: unknown): value is number;
declare function isTruthy(value: unknown): boolean;
declare function isValueOf(value: any, objectToCheck: any): boolean;
declare function lessThan(value: string | number, lt: string | number): boolean;
declare function lessThanOrEquals(value: string | number, lte: string | number): boolean;
declare function longerThanOrEquals(value: string | unknown[], arg1: string | number): boolean;
declare function matches(value: string, regex: RegExp | string): boolean;
declare function shorterThan(value: string | unknown[], arg1: string | number): boolean;
declare function shorterThanOrEquals(value: string | unknown[], arg1: string | number): boolean;
declare function startsWith(value: string, arg1: string): boolean;
declare const baseRules: {
    condition: typeof condition;
    doesNotEndWith: (value: string, arg1: string) => boolean;
    doesNotStartWith: (value: string, arg1: string) => boolean;
    endsWith: typeof endsWith;
    equals: typeof equals;
    greaterThan: typeof import("vest-utils").greaterThan;
    greaterThanOrEquals: typeof greaterThanOrEquals;
    gt: typeof import("vest-utils").greaterThan;
    gte: typeof greaterThanOrEquals;
    inside: typeof inside;
    isArray: typeof import("vest-utils").isArray;
    isBetween: typeof isBetween;
    isBlank: typeof isBlank;
    isBoolean: typeof import("vest-utils").isBoolean;
    isEmpty: typeof import("vest-utils").isEmpty;
    isEven: (value: any) => boolean;
    isFalsy: (value: unknown) => boolean;
    isKeyOf: typeof isKeyOf;
    isNaN: typeof isNaN;
    isNegative: typeof isNegative;
    isNotArray: (value: unknown) => boolean;
    isNotBetween: (value: string | number, min: string | number, max: string | number) => boolean;
    isNotBlank: (value: unknown) => boolean;
    isNotBoolean: (value: unknown) => boolean;
    isNotEmpty: (value: unknown) => boolean;
    isNotKeyOf: (key: string | number | symbol, obj: any) => boolean;
    isNotNaN: (value: unknown) => boolean;
    isNotNull: (value: unknown) => boolean;
    isNotNullish: (value: any) => boolean;
    isNotNumber: (value: unknown) => boolean;
    isNotNumeric: (value: string | number) => boolean;
    isNotString: (v: unknown) => boolean;
    isNotUndefined: (value?: unknown) => boolean;
    isNotValueOf: (value: any, objectToCheck: any) => boolean;
    isNull: typeof import("vest-utils").isNull;
    isNullish: typeof import("vest-utils").isNullish;
    isNumber: typeof isNumber;
    isNumeric: typeof import("vest-utils").isNumeric;
    isOdd: (value: any) => boolean;
    isPositive: typeof import("vest-utils").isPositive;
    isString: typeof import("vest-utils").isStringValue;
    isTruthy: typeof isTruthy;
    isUndefined: typeof import("vest-utils").isUndefined;
    isValueOf: typeof isValueOf;
    lengthEquals: typeof import("vest-utils").lengthEquals;
    lengthNotEquals: (value: string | unknown[], arg1: string | number) => boolean;
    lessThan: typeof lessThan;
    lessThanOrEquals: typeof lessThanOrEquals;
    longerThan: typeof import("vest-utils").longerThan;
    longerThanOrEquals: typeof longerThanOrEquals;
    lt: typeof lessThan;
    lte: typeof lessThanOrEquals;
    matches: typeof matches;
    notEquals: (value: unknown, arg1: unknown) => boolean;
    notInside: (value: unknown, arg1: string | unknown[]) => boolean;
    notMatches: (value: string, regex: string | RegExp) => boolean;
    numberEquals: typeof import("vest-utils").numberEquals;
    numberNotEquals: (value: string | number, eq: string | number) => boolean;
    shorterThan: typeof shorterThan;
    shorterThanOrEquals: typeof shorterThanOrEquals;
    startsWith: typeof startsWith;
};
type Rules<E = Record<string, unknown>> = n4s.EnforceCustomMatchers<Rules<E> & E> & Record<string, (...args: Args) => Rules<E> & E> & {
    [P in KBaseRules]: (...args: DropFirst<Parameters<BaseRules[P]>> | Args) => Rules<E> & E;
};
/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-empty-interface */
declare global {
    namespace n4s {
        interface IRules<E> extends Rules<E> {
        }
    }
}
type LazyRules = n4s.IRules<LazyRuleMethods>;
type Lazy = LazyRules & LazyRuleMethods & 
// This is a "catch all" hack to make TS happy while not
// losing type hints
Record<string, CB>;
type LazyRuleMethods = LazyRuleRunners & {
    message: (message: LazyMessage) => Lazy;
};
type LazyRuleRunners = {
    test: (value: unknown) => boolean;
    run: (value: unknown) => RuleDetailedResult;
};
type ComposeResult = LazyRuleRunners & ((value: any) => void);
type LazyMessage = DynamicValue<string, [
    value: unknown,
    originalMessage?: Stringable
]>;
declare function compose(...composites: LazyRuleRunners[]): ComposeResult;
export { compose as default };
//# sourceMappingURL=compose.d.ts.map